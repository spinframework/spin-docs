[{"project":"index.md","title":"Introducing Spin","subheading":"","content":"{{suh_cards}}\n{{card_element \"sample\" \"Checklist Sample App\" \"A checklist app that persists data in a key value store\" \"/hub/preview/sample_checklist\" \"Typescript,Http,Kv\" true }}\n{{card_element \"template\" \"Zola SSG Template\" \"A template for using Zola framework to create a static webpage\" \"/hub/preview/template_zola_ssg\" \"rust\" true }}\n{{card_element \"sample\" \"AI-assisted News Summarizer\" \"Read an RSS newsfeed and have AI summarize it for you\" \"/hub/preview/sample_newsreader_ai\" \"Typescript,Javascript,Ai\" true }}\n{{blockEnd}}Spin is a framework for building and running event-driven microservice applications with WebAssembly (Wasm) components.Spin uses Wasm because it is undefined.  Millisecond cold start times mean no need to keep applications \"warm\".Many languages have Wasm implementations, so undefined.Spin is undefined and undefined, meaning you can take your Spin applications anywhere.  There are Spin implementations for local development, for self-hosted servers, for Kubernetes, and for cloud-hosted services.undefined  Check out what's undefined!Or dive into the documentation and get started:undefinedundefined","subsectionKeywords":"","url":"/index"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedArtificial Intelligence (AI) Inferencing performs well on GPUs. However, GPU infrastructure is both scarce and expensive. This tutorial will show you how to use Fermyon Serverless AI to quickly build advanced AI-enabled serverless applications that can run on Fermyon Cloud. Your applications will benefit from 50 millisecond cold start times and operate 100x faster than other on-demand AI infrastructure services. Take a quick look at the video below to learn about executing inferencing on LLMs with no extra setup.In this tutorial we will:undefinedundefinedundefined","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Tutorial Prerequisites","content":"","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#tutorial-prerequisites"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Spin","content":"You will need to undefined. Serverless AI is supported on Spin versions 1.5 and above.If you already have Spin installed, undefined if required.","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#spin"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Dependencies","content":"The above installation script automatically installs the latest SDKs for Rust (which will enable us to write Serverless AI applications in Rust). However, some of the Serverless AI examples are written using TypeScript/Javascript and Python. To enable Serverless AI functionality via TypeScript/Javascript and Python, please ensure you have the latest TypeScript/JavaScript and Python template installed:undefined$ spin templates install --git https://github.com/spinframework/spin-js-sdk --upgradeundefinedSome of the Serverless AI examples are written using Python. To enable Serverless AI functionality via Python, please ensure you have the latest Python template installed:$ spin templates install --git https://github.com/spinframework/spin-python-sdk --upgrade","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#dependencies"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Licenses","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#licenses"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Serverless AI Inferencing With Spin Applications","content":"Now, let's dive deep into a comprehensive tutorial and unlock your potential to use Fermyon Serverless AI.\nundefined The full source code with other examples can be found in our undefined","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#serverless-ai-inferencing-with-spin-applications"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Creating a New Spin Application","content":"{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}The Rust code snippets below are taken from the undefinedundefined$ spin new http-rust\nEnter a name for your new application: sentiment-analysis\nDescription: A sentiment analysis API that demonstrates using LLM inferencing and KV stores together\nHTTP base: /\nHTTP path: /api/...{{ blockEnd }}{{ startTab \"TypeScript\" }}The TypeScript code snippets below are taken from the undefinedundefined$ spin new http-ts\nEnter a name for your new application: sentiment-analysis\nDescription: A sentiment analysis API that demonstrates using LLM inferencing and KV stores together\nHTTP base: /\nHTTP path: /api/...{{ blockEnd }}{{ startTab \"Python\" }}The Python code snippets below are taken from the undefinedundefined$ spin new http-py\nEnter a name for your new application: sentiment-analysis\nDescription: A sentiment analysis API that demonstrates using LLM inferencing and KV stores together\nHTTP base: /\nHTTP path: /api/...{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#creating-a-new-spin-application"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Supported AI Models","content":"Fermyon's Spin and Serverless AI currently support:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#supported-ai-models"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Model Optimization","content":"The models need to be in a particular format for Spin to be able to use them (quantized, which is a form of optimization). The official download links for the models (in non-quantized format) are listed in the previous section. However, for your convenience, the code examples below fetch models which are already in the special quantized format.","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#model-optimization"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Application Structure","content":"Next, we need to create the appropriate folder structure from within the application directory (alongside our spin.toml file). The code below demonstrates the variations in folder structure depending on which model is being used. Once the folder structure is in place, we then fetch the pre-trained AI model for our application:undefinedundefined# llama2-chat\n$ mkdir -p .spin/ai-models/llama\n$ cd .spin/ai-models/llama\n$ wget https://huggingface.co/TheBloke/Llama-2-13B-chat-GGML/resolve/a17885f653039bd07ed0f8ff4ecc373abf5425fd/llama-2-13b-chat.ggmlv3.q3_K_L.bin\n$ mv llama-2-13b-chat.ggmlv3.q3_K_L.bin llama2-chattree .spin\n.spin\n└── ai-models\n    └── llama\n        └── llama2-chatundefinedundefined# codellama-instruct\n$ mkdir -p .spin/ai-models/llama\n$ cd .spin/ai-models/llama\n$ wget https://huggingface.co/TheBloke/CodeLlama-13B-Instruct-GGML/resolve/b3dc9d8df8b4143ee18407169f09bc12c0ae09ef/codellama-13b-instruct.ggmlv3.Q3_K_L.bin\n$ mv codellama-13b-instruct.ggmlv3.Q3_K_L.bin codellama-instructtree .spin\n.spin\n└── ai-models\n    └── llama\n        └── codellama-instructundefinedThe following section fetches a specific version of the undefined model:$ mkdir -p .spin/ai-models/all-minilm-l6-v2\n$ cd .spin/ai-models/all-minilm-l6-v2\n$ wget https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2/resolve/7dbbc90392e2f80f3d3c277d6e90027e55de9125/tokenizer.json\n$ wget https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2/resolve/0b6dc4ef7c29dba0d2e99a5db0c855c3102310d8/model.safetensorstree .spin\n.spin\n└── ai-models\n    └── all-minilm-l6-v2\n        ├── model.safetensors\n        └── tokenizer.jsonundefinedln -s ~/my-ai-models/ ~/application-one/.spin/ai-models","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#application-structure"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Application Configuration","content":"Then, we configure the [[component]] section of our application's manifest (the spin.toml file); explicitly naming our model of choice. For example, in the case of the sentiment analysis application, we specify the llama2-chat value for our ai_models configuration:ai_models = [\"llama2-chat\"]\nkey_value_stores = [\"default\"]Note the positioning, of the ai_models configuration, shown below:[[component]]\nid = \"sentiment-analysis\"\nsource = \"target/spin-http-js.wasm\"\nexclude_files = [\"**/node_modules\"]\nkey_value_stores = [\"default\"]\nai_models = [\"llama2-chat\"]\n[component.trigger]\nroute = \"/api/...\"\n[component.build]\ncommand = \"npm run build\"\nwatch = [\"src/**/*\", \"package.json\", \"package-lock.json\"]","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#application-configuration"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Source Code","content":"Now let's use the Spin SDK to access the model from our app:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}The Rust source code for this sentiment analysis example uses serde. There are a couple of ways to add the required serde dependencies:undefinedundefinedserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0.85\"Once you have added serde, as explained above, modify your src/lib.rs file to match the following content:use std::str::FromStr;\n\nuse anyhow::Result;\nuse spin_sdk::{\n    http::{Params, Request, Response, Router},\n    http_component,\n    key_value::Store,\n    llm::{infer_with_options, InferencingModel::Llama2Chat},\n};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize)]\npub struct SentimentAnalysisRequest {\n    pub sentence: String,\n}\n\n#[derive(Serialize)]\npub struct SentimentAnalysisResponse {\n    pub sentiment: String,\n}\n\nconst PROMPT: &str = r#\"\\\n<<SYS>>\nYou are a bot that generates sentiment analysis responses. Respond with a single positive, negative, or neutral.\n<</SYS>>\n<INST>\nFollow the pattern of the following examples:\n\nUser: Hi, my name is Bob\nBot: neutral\n\nUser: I am so happy today\nBot: positive\n\nUser: I am so sad today\nBot: negative\n</INST>\n\nUser: {SENTENCE}\n\"#;\n\n/// A Spin HTTP component that internally routes requests.\n#[http_component]\nfn handle_route(req: Request) -> Result<Response> {\n    let mut router = Router::new();\n    router.post(\"/api/sentiment-analysis\", perform_sentiment_analysis);\n    router.any(\"/api/*\", not_found);\n    router.handle(req)\n}\n\nfn not_found(_: Request, _: Params) -> Result<Response> {\n    Ok(http::Response::builder()\n        .status(404)\n        .body(Some(\"Not found\".into()))?)\n}\n\nfn perform_sentiment_analysis(req: Request, _params: Params) -> Result<Response> {\n    let request = body_json_to_map(&req)?;\n    // Do some basic clean up on the input\n    let sentence = request.sentence.trim();\n    println!(\"Performing sentiment analysis on: {}\", sentence);\n\n    // Prepare the KV store\n    let kv = Store::open_default()?;\n\n    // If the sentiment of the sentence is already in the KV store, return it\n    if kv.exists(sentence).unwrap_or(false) {\n        println!(\"Found sentence in KV store returning cached sentiment\");\n        let sentiment = kv.get(sentence)?;\n        let resp = SentimentAnalysisResponse {\n            sentiment: String::from_utf8(sentiment)?,\n        };\n        let resp_str = serde_json::to_string(&resp)?;\n\n        return send_ok_response(200, resp_str)\n    }\n    println!(\"Sentence not found in KV store\");\n\n    // Otherwise, perform sentiment analysis\n    println!(\"Running inference\");\n    let inferencing_result = infer_with_options(\n        Llama2Chat,\n        &PROMPT.replace(\"{SENTENCE}\", sentence),\n        spin_sdk::llm::InferencingParams {\n            max_tokens: 6,\n            ..Default::default()\n        },\n    )?;\n    println!(\"Inference result {:?}\", inferencing_result);\n    let sentiment = inferencing_result\n        .text\n        .lines()\n        .next()\n        .unwrap_or_default()\n        .strip_prefix(\"Bot:\")\n        .unwrap_or_default()\n        .parse::<Sentiment>();\n    println!(\"Got sentiment: {sentiment:?}\");\n\n    if let Ok(sentiment) = sentiment {\n        println!(\"Caching sentiment in KV store\");\n        let _ = kv.set(sentence, sentiment);\n    }\n    // Cache the result in the KV store\n    let resp = SentimentAnalysisResponse {\n        sentiment: sentiment\n            .as_ref()\n            .map(ToString::to_string)\n            .unwrap_or_default(),\n    };\n\n    let resp_str = serde_json::to_string(&resp)?;\n    send_ok_response(200, resp_str)\n}\n\nfn send_ok_response(code: u16, resp_str: String) -> Result<Response> {\n    Ok(http::Response::builder()\n    .status(code)\n    .body(Some(resp_str.into()))?)\n}\n\nfn body_json_to_map(req: &Request) -> Result<SentimentAnalysisRequest> {\n    let body = match req.body().as_ref() {\n        Some(bytes) => bytes,\n        None => anyhow::bail!(\"Request body was unexpectedly empty\"),\n    };\n\n    Ok(serde_json::from_slice(&body)?)\n}\n\n#[derive(Copy, Clone, Debug)]\nenum Sentiment {\n    Positive,\n    Negative,\n    Neutral,\n}\n\nimpl Sentiment {\n    fn as_str(&self) -> &str {\n        match self {\n            Self::Positive => \"positive\",\n            Self::Negative => \"negative\",\n            Self::Neutral => \"neutral\",\n        }\n    }\n}\n\nimpl std::fmt::Display for Sentiment {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.write_str(self.as_str())\n    }\n}\n\nimpl AsRef<[u8]> for Sentiment {\n    fn as_ref(&self) -> &[u8] {\n        self.as_str().as_bytes()\n    }\n}\n\nimpl FromStr for Sentiment {\n    type Err = String;\n\n    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {\n        let sentiment = match s.trim() {\n            \"positive\" => Self::Positive,\n            \"negative\" => Self::Negative,\n            \"neutral\" => Self::Neutral,\n            _ => return Err(s.into()),\n        };\n        Ok(sentiment)\n    }\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}import {\n  HandleRequest,\n  HttpRequest,\n  HttpResponse,\n  Llm,\n  InferencingModels,\n  InferencingOptions,\n  Router,\n  Kv,\n} from \"@fermyon/spin-sdk\";\n\ninterface SentimentAnalysisRequest {\n  sentence: string;\n}\n\ninterface SentimentAnalysisResponse {\n  sentiment: \"negative\" | \"neutral\" | \"positive\";\n}\n\nconst decoder = new TextDecoder();\n\nconst PROMPT = `\\\nYou are a bot that generates sentiment analysis responses. Respond with a single positive, negative, or neutral.\n\nHi, my name is Bob\nneutral\n\nI am so happy today\npositive\n\nI am so sad today\nnegative\n\n<SENTENCE>\n`;\n\nasync function performSentimentAnalysis(request: HttpRequest) {\n  // Parse sentence out of request\n  let data = request.json() as SentimentAnalysisRequest;\n  let sentence = data.sentence;\n  console.log(\"Performing sentiment analysis on: \" + sentence);\n\n  // Prepare the KV store\n  let kv = Kv.openDefault();\n\n  // If the sentiment of the sentence is already in the KV store, return it\n  if (kv.exists(sentence)) {\n    console.log(\"Found sentence in KV store returning cached sentiment\");\n    return {\n      status: 200,\n      body: JSON.stringify({\n        sentiment: decoder.decode(kv.get(sentence)),\n      } as SentimentAnalysisResponse),\n    };\n  }\n  console.log(\"Sentence not found in KV store\");\n\n  // Otherwise, perform sentiment analysis\n  console.log(\"Running inference\");\n  let options: InferencingOptions = { max_tokens: 10, temperature: 0.5 };\n  let inferenceResult = Llm.infer(\n    InferencingModels.Llama2Chat,\n    PROMPT.replace(\"<SENTENCE>\", sentence),\n    options\n  );\n  console.log(\n    `Inference result (${inferenceResult.usage.generatedTokenCount} tokens): ${inferenceResult.text}`\n  );\n  let sentiment = inferenceResult.text.split(/\\s+/)[0]?.trim();\n\n  // Clean up result from inference\n  if (\n    sentiment === undefined ||\n    ![\"negative\", \"neutral\", \"positive\"].includes(sentiment)\n  ) {\n    sentiment = \"neutral\";\n    console.log(\"Invalid sentiment, marking it as neutral\");\n  }\n\n  // Cache the result in the KV store\n  console.log(\"Caching sentiment in KV store\");\n  kv.set(sentence, sentiment);\n\n  return {\n    status: 200,\n    body: JSON.stringify({\n      sentiment,\n    } as SentimentAnalysisResponse),\n  };\n}\n\nlet router = Router();\n\n// Map the route to the handler\nrouter.post(\"/api/sentiment-analysis\", async (_, req) => {\n  console.log(`${new Date().toISOString()} POST /sentiment-analysis`);\n  return await performSentimentAnalysis(req);\n});\n\n// Catch all 404 handler\nrouter.all(\"/api/*\", async (_, req) => {\n  return {\n    status: 404,\n    body: \"Not found\",\n  };\n});\n\n// Entry point to the Spin handler\nexport const handleRequest: HandleRequest = async function (\n  request: HttpRequest\n): Promise<HttpResponse> {\n  return await router.handleRequest(request, request);\n};{{ blockEnd }}{{ startTab \"Python\"}}from spin_http import Response\nfrom spin_llm import llm_infer\nimport json\nimport re\n\nPROMPT=\"\"\"<<SYS>>\nYou are a bot that generates sentiment analysis responses. Respond with a single positive, negative, or neutral.\n<</SYS>>\n[INST]\nFollow the pattern of the following examples:\nUser: Hi, my name is Bob\nBot: neutral\nUser: I am so happy today\nBot: positive\nUser: I am so sad today\nBot: negative\n[/INST]\nUser: \"\"\"\n\ndef handle_request(request):\n    request_body=json.loads(request.body)\n    sentence=request_body[\"sentence\"].strip()\n    result=llm_infer(\"llama2-chat\", PROMPT+sentence)\n    response_body=json.dumps({\"sentence\": re.sub(\"\\\\nBot\\: \", \"\", result.text)})\n    return Response(200,\n                    {\"content-type\": \"application/json\"},\n                    bytes(response_body, \"utf-8\")){{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#source-code"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Additional Functionality","content":"This application also includes two more components, a key/value explorer and static-fileserver component. Let's quickly go ahead and create those (letting Spin do all of the scaffolding for us).","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#additional-functionality"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Static Fileserver Component For The UI","content":"We use the spin add command to add the new static-fileserver that we will name ui:$ spin add static-fileserver\nEnter a name for your new component: ui\nHTTP path: /...\nDirectory containing the files to serve: assets\nWe create an assets directory where we can store files to serve statically (see the spin.toml file for more configuration information):$ mkdir assets","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#static-fileserver-component-for-the-ui"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Add the Front-End","content":"We can add a webpage that asks the user for some text and does the sentiment analysis on it. In your assets folder, create two files dynamic.js and index.html.Here's the code snippet for index.html<!DOCTYPE html>\n<html data-theme=\"cupcake\">\n  <head>\n    <title>Sentiment Analyzer</title>\n    <meta name=\"description\" content=\"Perform sentiment analysis\" />\n\n    <!-- Tailwind and Daisy UI -->\n    <link\n      href=\"https://cdn.jsdelivr.net/npm/daisyui@3.2.1/dist/full.css\"\n      rel=\"stylesheet\"\n      type=\"text/css\"\n    />\n    <script src=\"https://cdn.tailwindcss.com?plugins=typography\"></script>\n\n    <!-- Import script to make page dynamic -->\n    <script src=\"dynamic.js\"></script>\n  </head>\n\n  <body class=\"bg-base-200\">\n    <div id=\"alert\" class=\"fixed top-20 inset-x-0 w-1/2 mx-auto\"></div>\n    <div class=\"flex flex-col min-h-screen\">\n      <div\n        class=\"sticky top-0 z-30 flex h-16 w-full justify-center bg-opacity-90 backdrop-blur transition-all duration-100 bg-base-100 text-base-content shadow-md\"\n      >\n        <nav class=\"navbar w-full\">\n          <div class=\"flex-1\">\n            <a href=\"/\" class=\"btn btn-ghost text-4xl font-bold\"\n              >Sentiment Analyzer</a\n            >\n          </div>\n          <div class=\"flex-none\">\n            <a href=\"\" class=\"btn btn-warning\">Restart</a>\n          </div>\n        </nav>\n      </div>\n      <main class=\"mx-auto my-10 prose\">\n        <p>\n          This Sentiment Analyzer is a demonstration of how you can use Fermyon\n          Serverless AI to easily make an AI-powered API. When you type in a\n          sentence it is sent to a Spin app running in the Fermyon Cloud,\n          inferencing is performed using the Fermyon serverless AI feature, and\n          the response is cached in a Fermyon key/value store.\n        </p>\n        <p>\n          Note that LLM's are not perfect and the sentiment analysis performed\n          by this application is not guaranteed to be perfect.\n        </p>\n        <p>\n          To get started type a sentence below and press\n          <kbd class=\"kbd kbd-sm\">enter</kbd>.\n        </p>\n\n        <div class=\"flex flex-col gap-8 w-full\">\n          <input\n            id=\"sentence-input\"\n            type=\"text\"\n            placeholder=\"Type the sentence you want to analyze here\"\n            class=\"input w-full\"\n          />\n          <div>\n            <button class=\"btn btn-primary\" onclick=\"newCard()\">Analyze</button>\n          </div>\n        </div>\n      </main>\n    </div>\n  </body>\n</html>Here's the code snippet for dynamic.js// Listen for the Enter key being pressed\ndocument.addEventListener(\"keydown\", function (event) {\n  if (event.keyCode === 13) {\n    newCard();\n  }\n});\n\nvar globalCardCount = 0;\nvar runningInference = false;\n\nfunction newCard() {\n  if (runningInference) {\n    console.log(\"Already running inference, please wait...\");\n    setAlert(\"Already running inference, please wait...\");\n    return;\n  }\n  var inputElement = document.getElementById(\"sentence-input\");\n  var sentence = inputElement.value;\n  if (sentence === \"\") {\n    console.log(\"Please enter a sentence to analyze\");\n    setAlert(\"Please enter a sentence to analyze\");\n    return;\n  }\n  inputElement.value = \"\";\n\n  var cardIndex = globalCardCount;\n  globalCardCount++;\n  var newCard = document.createElement(\"div\");\n  newCard.id = \"card-\" + cardIndex;\n  newCard.innerHTML = `\n    <div class=\"card bg-base-100 shadow-xl w-full\">\n        <div class=\"m-4 flex flex-col gap-2\">\n            <div>${sentence}</div>\n            <div class=\"flex flex-row justify-end\">\n                <span class=\"loading loading-dots loading-sm\"></span>\n            </div>\n        </div>\n    </div>\n    `;\n  document.getElementById(\"sentence-input\").before(newCard);\n\n  console.log(\"Running inference on sentence: \" + sentence);\n  runningInference = true;\n  fetch(\"/api/sentiment-analysis\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({ sentence: sentence }),\n  })\n    .then((response) => response.json())\n    .then((data) => {\n      console.log(data);\n      updateCard(cardIndex, sentence, data.sentiment);\n    })\n    .catch((error) => {\n      console.log(error);\n    });\n}\n\nfunction updateCard(cardIndex, sentence, sentiment) {\n  badge = \"\";\n  if (sentiment === \"positive\") {\n    badge = `<span class=\"badge badge-success\">Positive</span>`;\n  } else if (sentiment === \"negative\") {\n    badge = `<span class=\"badge badge-error\">Negative</span>`;\n  } else if (sentiment === \"neutral\") {\n    badge = `<span class=\"badge badge-ghost\">Neutral</span>`;\n  } else {\n    badge = `<span class=\"badge badge-ghost\">Unsure</span>`;\n  }\n  var cardElement = document.getElementById(\"card-\" + cardIndex);\n  cardElement.innerHTML = `\n    <div class=\"card bg-base-100 shadow-xl w-full\">\n        <div class=\"m-4 flex flex-col gap-2\">\n            <div>${sentence}</div>\n            <div class=\"flex flex-row justify-end\">\n                ${badge}\n            </div>\n        </div>\n    </div>\n    `;\n  runningInference = false;\n}\n\nfunction setAlert(msg) {\n  var alertElement = document.getElementById(\"alert\");\n  alertElement.innerHTML = `\n    <div class=\"alert alert-error\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"stroke-current shrink-0 h-6 w-6\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z\" /></svg>\n        <span class=\"text-error-content\">${msg}</span>\n    </div>\n    `;\n  setTimeout(function () {\n    alertElement.innerHTML = \"\";\n  }, 3000);\n}","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#add-the-front-end"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Key Value Explorer","content":"For this, we install use a pre-made template by pointing to the templates GitHub repository:$ spin templates install --git https://github.com/spinframework/spin-kv-explorerThen, we again use spin add to add the new component. We will name the component  kv-explorer):$ spin add kv-explorer -t kv-explorerWe create an assets directory where we can store files to serve statically (see the spin.toml file for more configuration information):$ mkdir assets","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#key-value-explorer"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Application Manifest","content":"As shown below, the Spin framework has done all of the scaffolding for us:spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"A sentiment analysis API that demonstrates using LLM inference and KV stores together\"\nname = \"sentiment-analysis\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"sentiment-analysis\"\nsource = \"target/sentiment-analysis.wasm\"\nexclude_files = [\"**/node_modules\"]\nai_models = [\"llama2-chat\"]\nkey_value_stores = [\"default\"]\n[component.trigger]\nroute = \"/api/...\"\n[component.build]\ncommand = \"npm run build\"\n\n[[component]]\nsource = { url = \"https://github.com/spinframework/spin-fileserver/releases/download/v0.0.3/spin_static_fs.wasm\", digest = \"sha256:38bf971900228222f7f6b2ccee5051f399adca58d71692cdfdea98997965fd0d\" }\nid = \"ui\"\nfiles = [ { source = \"assets\", destination = \"/\" } ]\n[component.trigger]\nroute = \"/...\"\n\n[[component]]\nsource = { url = \"https://github.com/spinframework/spin-kv-explorer/releases/download/v0.9.0/spin-kv-explorer.wasm\", digest = \"sha256:07f5f0b8514c14ae5830af0f21674fd28befee33cd7ca58bc0a68103829f2f9c\" }\nid = \"kv-explorer\"\n# add or remove stores you want to explore here\nkey_value_stores = [\"default\"]\n[component.trigger]\nroute = \"/internal/kv-explorer/...\"","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#application-manifest"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Building and Deploying Your Spin Application","content":"undefined Running inferencing on localhost (your CPU) is not as optimal as deploying to Fermyon's Serverless AI (where inferencing is performed by high-powered GPUs). You can skip this spin build --up step and move straight to spin cloud deploy if you:undefinedundefinedNow, let's build and run our Spin Application locally. (undefined If you are following along with the TypeScript/JavaScript example, you will first need to run npm install. Otherwise, please continue to the following spin command.)$ spin build --up","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#building-and-deploying-your-spin-application"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Test Locally","content":"# Create a new POST request to localhost\n$ curl -vXPOST 'localhost:3000/api/sentiment-analysis' -H'Content-Type: application/json' -d \"{\\\"sentence\\\": \\\"Well this is very nice indeed\\\" }\"\n\n{\"sentiment\":\"positive\"}","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#test-locally"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Deploy to Fermyon Cloud","content":"Deploying to the Fermyon Cloud is one simple command. If you have not logged into your Fermyon Cloud account already, the CLI will prompt you to login. Follow the instructions to complete the authorization process.$ spin cloud deploy","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#deploy-to-fermyon-cloud"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Testing in Fermyon Cloud","content":"# Create a new POST request to your apps URL in Fermyon Cloud\n$ curl -vXPOST 'https://abcxyz.fermyon.app/api/sentiment-analysis' -H'Content-Type: application/json' -d \"{\\\"sentence\\\": \\\"Well this is very nice indeed\\\" }\"\n\n{\"sentiment\":\"positive\"}","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#testing-in-fermyon-cloud"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Visit Fermyon Cloud UI","content":"Visiting your apps URL will produce a User Interface (UI) similar to the following.undefinedYou can type in a sentence, and the UI will respond with the sentiment analysis.undefined","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#visit-fermyon-cloud-ui"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Integrating Custom Domain and Storage","content":"The groundbreaking Fermyon Serverless AI introduces a revolutionary addition to the full-stack developer's arsenal. You can now seamlessly integrate the Fermyon undefined, undefined, and even your undefined with the launch of your very own advanced AI-enabled serverless applications.","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#integrating-custom-domain-and-storage"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Conclusion","content":"We want to get feedback on the Serverless AI API. We are curious about what models you would like to use and what applications you are building using Serverless AI. Let us know what you need, and how Fermyon's Serverless AI could potentially help solve a problem for you. We would love to help you write your new Serverless AI application.","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#conclusion"},{"project":"v1","title":"Sentiment Analysis With Serverless AI","subheading":"Next Steps","content":"undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/ai-sentiment-analysis-api-tutorial#next-steps"},{"project":"v1","title":"API Support Overview","subheading":"","content":"The following table shows the status of the interfaces Spin provides to applications.| Host Capabilities/Interfaces           | Stability  |\n|----------------------------------------|----------|\n| undefined                          | Stable   |\n| undefined                         | Stable   |\n| undefined                          | Stable   |\n| undefined                         | Stable  |\n| undefined                      | Stable |\n| undefined                             | Experimental |\n| undefined                                  | Experimental |\n| undefined                      | Stabilizing |\n| undefined                      | Experimental |\n| undefined                      | Experimental |For more information about what is possible in the programming language of your choice, please see our undefined.","subsectionKeywords":"","url":"/v1/api-guides-overview"},{"project":"v1","title":"Building Spin Application Code","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedA Spin application is made up of one or more components. Components are binary Wasm modules; undefined refers to the process of converting your source code into those modules.undefinedBecause most compilers don't target Wasm by default, building Wasm modules often requires special command options, which you may not have at your fingertips.\nWhat's more, when developing a multi-component application, you may need to issue such commands for several components on each iteration.\nDoing this manually can be tedious and error-prone.To make the build process easier, the spin build command allows you to build all the components in one command.undefined","subsectionKeywords":"","url":"/v1/build"},{"project":"v1","title":"Building Spin Application Code","subheading":"Setting Up for  spin build","content":"To use spin build, each component that you want to build must specify the command used to build it in spin.toml, as part of its component.build table:[[component]]\nid = \"hello\"\n[component.trigger]\nroute = \"/...\"\n# This is the section you need for `spin build`\n[component.build]\ncommand = \"npm run build\"If you generated the component from a supplied template, the component.build section should be set up correctly for you. You don't need to change or add anything.undefined{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}For Rust applications, you must have the wasm32-wasi target installed:$ rustup target add wasm32-wasiThe build command typically runs cargo build with the wasm32-wasi target and the --release option:[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"{{ blockEnd }}{{ startTab \"TypeScript\" }}For JavaScript and TypeScript applications, you must have the js2wasm Spin plugin installed:$ spin plugins update\n$ spin plugins install js2wasm --yesIt's normally convenient to put the detailed build instructions in package.json:{\n  \"scripts\": {\n    \"build\": \"npx webpack --mode=production && mkdir -p target && spin js2wasm -o target/spin-http-js.wasm dist/spin.js\"\n  }\n}The build command can then call the NPM script:[component.build]\ncommand = \"npm run build\"{{ blockEnd }}{{ startTab \"Python\" }}For Python applications, you must have the py2wasm Spin plugin installed:$ spin plugins update\n$ spin plugins install py2wasm --yesThe build command then calls spin py2wasm on your application file:[component.build]\ncommand = \"spin py2wasm app -o app.wasm\"{{ blockEnd }}{{ startTab \"TinyGo\" }}For Go applications, you must use the TinyGo compiler, as the standard Go compiler does not yet support the WASI standard.  See the undefined.The build command calls TinyGo with the WASI backend and appropriate options:[component.build]\ncommand = \"tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"{{ blockEnd }}{{ blockEnd }}undefined","keywords":"","subsectionKeywords":"","url":"/v1/build#setting-up-for-spin-build"},{"project":"v1","title":"Building Spin Application Code","subheading":"Running  spin build","content":"Once the build commands are set up, running spin build will execute, sequentially, each build command:$ spin build\nBuilding component hello with `cargo build --target wasm32-wasi --release`\n    Updating crates.io index\n    Updating git repository `https://github.com/spinframework/spin`\n\n    //--snip--\n\n    Compiling hello v0.1.0 (hello)\n    Finished release [optimized] target(s) in 39.05s\nFinished building all Spin componentsundefined","keywords":"","subsectionKeywords":"","url":"/v1/build#running-spin-build"},{"project":"v1","title":"Building Spin Application Code","subheading":"Running the Application After Build","content":"You can pass the --up option to spin build to start the application as soon as the build process completes successfully.This is equivalent to running spin up immediately after spin build.  It accepts all the same flags and options that up does.  See undefined for details.","keywords":"","subsectionKeywords":"","url":"/v1/build#running-the-application-after-build"},{"project":"v1","title":"Building Spin Application Code","subheading":"Overriding the Working Directory","content":"By default, the command to build a component is executed in the directory containing the spin.toml file. If a component's entire build source is under a subdirectory, it is often more convenient to build in that subdirectory rather than try to pass the path to the build command. You can do this by setting the workdir option in the component.build table.For example, consider this Rust component located in subdirectory deep:.\n├── deep\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.tomlTo have the Rust build command run in directory deep, we can set the component's workdir:[component.build]\n# `command` is the normal build command for this language\ncommand = \"cargo build --target wasm32-wasi --release\"\n# This tells Spin to run it in the directory of the build file (in this case Cargo.toml)\nworkdir = \"deep\"undefined","keywords":"","subsectionKeywords":"","url":"/v1/build#overriding-the-working-directory"},{"project":"v1","title":"Building Spin Application Code","subheading":"Next Steps","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v1/build#next-steps"},{"project":"v1","title":"Spin Internal Data Layout","subheading":"","content":"undefinedundefinedundefinedundefinedThis page describes how Spin lays out its internal data on disk.undefinedundefined","subsectionKeywords":"","url":"/v1/cache"},{"project":"v1","title":"Spin Internal Data Layout","subheading":"Base Directories","content":"Spin uses similar layouts across Linux, MacOS and Windows platforms, but the paths to various areas of the user's home directory differ across the platforms. On this page, the following terms have the following meanings:| Name          | Linux                                    | MacOS                                | Windows |\n|---------------------|------------------------------------------|--------------------------------------|-------------------|\n| DATA_DIR    | $XDG_DATA_HOME or $HOME/.local/share | $HOME/Library/Application Support, or $HOMEBREW_PREFIX/etc/fermyon-spin if installed using Homebrew  | %LOCALAPPDATA% or %USERPROFILE%\\AppData\\Local |\n| CACHE_DIR   | $XDG_CACHE_HOME or $HOME/.cache      | $HOME/Library/Caches               | %LOCALAPPDATA% or %USERPROFILE%\\AppData\\Local |These directories are based on the undefined, and specifically on the cross-platform implementation in the undefined.undefined","keywords":"","subsectionKeywords":"","url":"/v1/cache#base-directories"},{"project":"v1","title":"Spin Internal Data Layout","subheading":"Plugins","content":"Installed plugins are stored in (DATA_DIR)/spin/plugins.  A snapshot of the plugins registry is also stored under that directory at (DATA_DIR)/spin/plugins/.spin-plugins; this is structured as a Git repository.undefinedIf you delete the plugins directory, you will no longer be able to run your plugins (until you reinstall them), but other Spin operations will be unaffected.","keywords":"","subsectionKeywords":"","url":"/v1/cache#plugins"},{"project":"v1","title":"Spin Internal Data Layout","subheading":"Templates","content":"Installed templates are stored in (DATA_DIR)/spin/templates.undefinedIf you delete the templates directory, you will lose access to your installed templates (until you reinstall them), but other Spin operations will be unaffected.","keywords":"","subsectionKeywords":"","url":"/v1/cache#templates"},{"project":"v1","title":"Spin Internal Data Layout","subheading":"Application Cache","content":"Downloaded application data, such as applications downloaded from registries or Wasm modules downloaded from URLs, are stored in (CACHE_DIR)/spin/registry.If you delete the application cache directory, Spin will automatically re-download the files as needed.  Spin operations will be otherwise unaffected.","keywords":"","subsectionKeywords":"","url":"/v1/cache#application-cache"},{"project":"v1","title":"Spin Internal Data Layout","subheading":"Inside the Application Cache","content":"undefinedThe application cache is divided into three subdirectories, data, manifests, and wasm.The data directory contains all static assets referenced from applications distributed with remote registries. The wasm directory contains all component sources referenced either in applications distributed with remote registries, or component sources from HTTP endpoints, directly referenced in spin.toml.undefinedThe manifests directory contains the registry manifests for entire apps distributed with remote registries. They are placed in subdirectories that identify the application based on the registry, repository, and digest (or tag).The following tree command shows a typical (abbreviated) cache directory:$ tree ~/Library/Caches/spin/registry/\n\n├── data\n│   ├── sha256:41a4649a8a8c176133792119cb45a7686767d3fa376ffd656e2ff76a6071fb07\n│   └── sha256:da3fda2db338a73483068072e22f7e7eef27afdbae3db824e130932adce703ba\n├── manifests\n│   └── ghcr.io\n│       └── radu-matei\n│           ├── hello-registries\n│           │   └── latest\n│           │       ├── config.json\n│           │       └── manifest.json\n│           └── spin-openai-demo\n│               └── v1\n│                   ├── config.json\n│                   └── manifest.json\n└── wasm\n    ├── sha256:0b985e7d43e719f34cbb54849759a2f8e7913c0f9b17bf7cb2b3d2458d33859e\n    └── sha256:d5f9e1f6b61b90f7404e3800285f7860fe2cfc7d0116023efc370adbb403fe87","keywords":"","subsectionKeywords":"","url":"/v1/cache#inside-the-application-cache"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedThis page documents the Spin Command Line Interface (CLI).undefinedFor information on command stability, see the undefined.","subsectionKeywords":"","url":"/v1/cli-reference"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin add","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin add --help\n\nspin-add \nScaffold a new component into an existing application\n\nUSAGE:\n    spin add [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n        --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -f, --file <APP_MANIFEST_FILE>     Path to spin.toml\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin add --help\n\nspin-add \nScaffold a new component into an existing application\n\nUSAGE:\n    spin add [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n        --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -f, --file <APP_MANIFEST_FILE>     Path to spin.toml\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin add --help\n\nspin-add \nScaffold a new component into an existing application\n\nUSAGE:\n    spin add [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -f, --file <APP_MANIFEST_FILE>     Path to spin.toml\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin add --help\n\nspin-add \nScaffold a new component into an existing application\n\nUSAGE:\n    spin add [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -f, --file <APP_MANIFEST_FILE>     Path to spin.toml\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin add --help\n\nspin-add \nScaffold a new component into an existing application\n\nUSAGE:\n    spin add [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -f, --file <APP_MANIFEST_FILE>     Path to spin.toml\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin add --help\n\nspin-add \nScaffold a new component into an existing application\n\n\nUSAGE:\n    spin add [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -f, --file <APP_MANIFEST_FILE>     Path to spin.toml\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-add"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin build","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin build --help\n\nspin-build \nBuild the Spin application\n\nUSAGE:\n    spin build [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    Path to application manifest. The default is \"spin.toml\"\n    -h, --help                        Print help information\n    -u, --up                          Run the application after building{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin build --help\n\nspin-build \nBuild the Spin application\n\nUSAGE:\n    spin build [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    Path to application manifest. The default is \"spin.toml\"\n    -h, --help                        Print help information\n    -u, --up                          Run the application after building{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin build --help\n\nspin-build \nBuild the Spin application\n\nUSAGE:\n    spin build [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to build. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n    -u, --up                          Run the application after building{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin build --help\n\nspin-build \nBuild the Spin application\n\nUSAGE:\n    spin build [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -c, --component-id <COMPONENT_ID>...\n            Component ID to build. This can be specified multiple times. The default is all\n            components\n    -f, --from <APP_MANIFEST_FILE>\n            The application to build. This may be a manifest (spin.toml) file, or a directory\n            containing a spin.toml file. If omitted, it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help\n            Print help information\n    -u, --up\n            Run the application after building{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin build --help\n\nspin-build \nBuild the Spin application\n\nUSAGE:\n    spin build [OPTIONS] [--] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -c, --component-id <COMPONENT_ID>...\n            Component ID to build. This can be specified multiple times. The default is all\n            components\n\n    -f, --from <APP_MANIFEST_FILE>\n            The application to build. This may be a manifest (spin.toml) file, or a directory\n            containing a spin.toml file. If omitted, it defaults to \"spin.toml\" [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n    -u, --up\n            Run the application after building{{ blockEnd }}{{ startTab \"v1.5\"}}\nUSAGE:\n    spin build [OPTIONS] [--] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -c, --component-id <COMPONENT_ID>...\n            Component ID to build. This can be specified multiple times. The default is all\n            components\n\n    -f, --from <APP_MANIFEST_FILE>\n            The application to build. This may be a manifest (spin.toml) file, or a directory\n            containing a spin.toml file. If omitted, it defaults to \"spin.toml\" [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n    -u, --up\n            Run the application after building{{ blockEnd }}\n{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-build"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin cloud","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin cloud --help\n\nspin-cloud \nCommands for publishing applications to the Fermyon Platform\n\nUSAGE:\n    spin cloud <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    deploy    Package and upload an application to the Fermyon Platform\n    help      Print this message or the help of the given subcommand(s)\n    login     Log into the Fermyon Platform{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin cloud --help\n\nspin-cloud \nCommands for publishing applications to the Fermyon Platform\n\nUSAGE:\n    spin cloud <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    deploy    Package and upload an application to the Fermyon Platform\n    help      Print this message or the help of the given subcommand(s)\n    login     Log into the Fermyon Platform{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin cloud --help\n\nspin-cloud \nCommands for publishing applications to the Fermyon Platform\n\nUSAGE:\n    spin cloud <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    deploy    Package and upload an application to the Fermyon Platform\n    help      Print this message or the help of the given subcommand(s)\n    login     Log into the Fermyon Platform{{ blockEnd }}{{ startTab \"v1.3\"}}The spin cloud command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v1.4\"}}The spin cloud command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v1.5\"}}The spin cloud command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-cloud"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin cloud deploy","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin cloud deploy --help\n\nspin-cloud-deploy \nPackage and upload an application to the Fermyon Platform\n\nUSAGE:\n    spin cloud deploy [OPTIONS]\n\nOPTIONS:\n        --buildinfo <BUILDINFO>\n            Build metadata to append to the bindle version\n\n    -d, --staging-dir <STAGING_DIR>\n            Path to assemble the bindle before pushing (defaults to a temporary directory)\n\n    -e, --deploy-existing-bindle\n            Deploy existing bindle if it already exists on bindle server\n\n        --environment-name <environment-name>\n            Deploy to the Fermyon instance saved under the specified name. If omitted, Spin deploys\n            to the default unnamed instance [env: FERMYON_DEPLOYMENT_ENVIRONMENT=]\n\n    -f, --file <APP_MANIFEST_FILE>\n            Path to spin.toml [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n        --key-value <KEY_VALUES>\n            Pass a key/value (key=value) to all components of the application. Can be used multiple\n            times\n\n        --no-buildinfo\n            Disable attaching buildinfo [env: SPIN_DEPLOY_NO_BUILDINFO=]\n\n        --readiness-timeout <READINESS_TIMEOUT_SECS>\n            How long in seconds to wait for a deployed HTTP application to become ready. The default\n            is 60 seconds. Set it to 0 to skip waiting for readiness [default: 60]{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin cloud deploy --help\n\nspin-cloud-deploy \nPackage and upload an application to the Fermyon Platform\n\nUSAGE:\n    spin cloud deploy [OPTIONS]\n\nOPTIONS:\n        --buildinfo <BUILDINFO>\n            Build metadata to append to the bindle version\n\n    -d, --staging-dir <STAGING_DIR>\n            Path to assemble the bindle before pushing (defaults to a temporary directory)\n\n    -e, --deploy-existing-bindle\n            Deploy existing bindle if it already exists on bindle server\n\n        --environment-name <environment-name>\n            Deploy to the Fermyon instance saved under the specified name. If omitted, Spin deploys\n            to the default unnamed instance [env: FERMYON_DEPLOYMENT_ENVIRONMENT=]\n\n    -f, --file <APP_MANIFEST_FILE>\n            Path to spin.toml [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n        --key-value <KEY_VALUES>\n            Pass a key/value (key=value) to all components of the application. Can be used multiple\n            times\n\n        --no-buildinfo\n            Disable attaching buildinfo [env: SPIN_DEPLOY_NO_BUILDINFO=]\n\n        --readiness-timeout <READINESS_TIMEOUT_SECS>\n            How long in seconds to wait for a deployed HTTP application to become ready. The default\n            is 60 seconds. Set it to 0 to skip waiting for readiness [default: 60]{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin cloud deploy --help\n\nspin-cloud-deploy \nPackage and upload an application to the Fermyon Platform\n\nUSAGE:\n    spin cloud deploy [OPTIONS]\n\nOPTIONS:\n        --buildinfo <BUILDINFO>\n            Build metadata to append to the bindle version\n\n    -d, --staging-dir <STAGING_DIR>\n            Path to assemble the bindle before pushing (defaults to a temporary directory)\n\n    -e, --deploy-existing-bindle\n            Deploy existing bindle if it already exists on bindle server\n\n        --environment-name <environment-name>\n            Deploy to the Fermyon instance saved under the specified name. If omitted, Spin deploys\n            to the default unnamed instance [env: FERMYON_DEPLOYMENT_ENVIRONMENT=]\n\n    -f, --from <APP_MANIFEST_FILE>\n            The application to deploy. This may be a manifest (spin.toml) file, or a directory\n            containing a spin.toml file. If omitted, it defaults to \"spin.toml\" [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n        --key-value <KEY_VALUES>\n            Set a key/value pair (key=value) in the deployed application's default store. Any\n            existing value will be overwritten. Can be used multiple times\n\n        --no-buildinfo\n            Disable attaching buildinfo [env: SPIN_DEPLOY_NO_BUILDINFO=]\n\n        --readiness-timeout <READINESS_TIMEOUT_SECS>\n            How long in seconds to wait for a deployed HTTP application to become ready. The default\n            is 60 seconds. Set it to 0 to skip waiting for readiness [default: 60]{{ blockEnd }}{{ startTab \"v1.3\"}}The spin cloud deploy command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v1.4\"}}The spin cloud deploy command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v1.5\"}}The spin cloud deploy command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-cloud-deploy"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin cloud login","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin cloud login --help\n\nspin-cloud-login \nLog into the Fermyon Platform\n\nUSAGE:\n    spin cloud login [OPTIONS]\n\nOPTIONS:\n        --auth-method <auth-method>\n            [env: AUTH_METHOD=] [possible values: github, username, token]\n\n        --bindle-password <BINDLE_PASSWORD>\n            Basic http auth password for the bindle server [env: BINDLE_PASSWORD=]\n\n        --bindle-server <BINDLE_SERVER_URL>\n            URL of bindle server [env: BINDLE_URL=]\n\n        --bindle-username <BINDLE_USERNAME>\n            Basic http auth username for the bindle server [env: BINDLE_USERNAME=]\n\n        --environment-name <environment-name>\n            Save the login details under the specified name instead of making them the default. Use\n            named environments with `spin deploy --environment-name <name>` [env:\n            FERMYON_DEPLOYMENT_ENVIRONMENT=]\n\n    -h, --help\n            Print help information\n\n    -k, --insecure\n            Ignore server certificate errors from bindle and hippo\n\n        --list\n            List saved logins\n\n        --password <HIPPO_PASSWORD>\n            Hippo password [env: HIPPO_PASSWORD=]\n\n        --status\n            Display login status\n\n        --token <TOKEN>\n            Auth Token [env: SPIN_AUTH_TOKEN=]\n\n        --url <HIPPO_SERVER_URL>\n            URL of hippo server [env: HIPPO_URL=] [default: https://cloud.fermyon.com/]\n\n        --username <HIPPO_USERNAME>\n            Hippo username [env: HIPPO_USERNAME=]{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin cloud login --help\n\nspin-cloud-login \nLog into the Fermyon Platform\n\nUSAGE:\n    spin cloud login [OPTIONS]\n\nOPTIONS:\n        --auth-method <auth-method>\n            [env: AUTH_METHOD=] [possible values: github, username, token]\n\n        --bindle-password <BINDLE_PASSWORD>\n            Basic http auth password for the bindle server [env: BINDLE_PASSWORD=]\n\n        --bindle-server <BINDLE_SERVER_URL>\n            URL of bindle server [env: BINDLE_URL=]\n\n        --bindle-username <BINDLE_USERNAME>\n            Basic http auth username for the bindle server [env: BINDLE_USERNAME=]\n\n        --environment-name <environment-name>\n            Save the login details under the specified name instead of making them the default. Use\n            named environments with `spin deploy --environment-name <name>` [env:\n            FERMYON_DEPLOYMENT_ENVIRONMENT=]\n\n    -h, --help\n            Print help information\n\n    -k, --insecure\n            Ignore server certificate errors from bindle and hippo\n\n        --list\n            List saved logins\n\n        --password <HIPPO_PASSWORD>\n            Hippo password [env: HIPPO_PASSWORD=]\n\n        --status\n            Display login status\n\n        --token <TOKEN>\n            Auth Token [env: SPIN_AUTH_TOKEN=]\n\n        --url <HIPPO_SERVER_URL>\n            URL of hippo server [env: HIPPO_URL=] [default: https://cloud.fermyon.com/]\n\n        --username <HIPPO_USERNAME>\n            Hippo username [env: HIPPO_USERNAME=]{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin cloud login --help\n\nspin-cloud-login \nLog into the Fermyon Platform\n\nUSAGE:\n    spin cloud login [OPTIONS]\n\nOPTIONS:\n        --auth-method <auth-method>\n            [env: AUTH_METHOD=] [possible values: github, username, token]\n\n        --bindle-password <BINDLE_PASSWORD>\n            Basic http auth password for the bindle server [env: BINDLE_PASSWORD=]\n\n        --bindle-server <BINDLE_SERVER_URL>\n            URL of bindle server [env: BINDLE_URL=]\n\n        --bindle-username <BINDLE_USERNAME>\n            Basic http auth username for the bindle server [env: BINDLE_USERNAME=]\n\n        --environment-name <environment-name>\n            Save the login details under the specified name instead of making them the default. Use\n            named environments with `spin deploy --environment-name <name>` [env:\n            FERMYON_DEPLOYMENT_ENVIRONMENT=]\n\n    -h, --help\n            Print help information\n\n    -k, --insecure\n            Ignore server certificate errors from bindle and hippo\n\n        --list\n            List saved logins\n\n        --password <HIPPO_PASSWORD>\n            Hippo password [env: HIPPO_PASSWORD=]\n\n        --status\n            Display login status\n\n        --token <TOKEN>\n            Auth Token [env: SPIN_AUTH_TOKEN=]\n\n        --url <HIPPO_SERVER_URL>\n            URL of hippo server [env: HIPPO_URL=] [default: https://cloud.fermyon.com/]\n\n        --username <HIPPO_USERNAME>\n            Hippo username [env: HIPPO_USERNAME=]{{ blockEnd }}{{ startTab \"v1.3\"}}The spin cloud login command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v1.4\"}}The spin cloud login command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v1.5\"}}The spin cloud login command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-cloud-login"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin cloud variables","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.3\"}}The spin cloud variables command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v1.4\"}}The spin cloud variables command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v1.5\"}}The spin cloud variables command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-cloud-variables"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin deploy","content":"spin deploy is a shortcut to undefined.","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-deploy"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin doctor","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.4\"}}$ spin doctor --help\n\nspin-doctor \nDetect and fix problems with Spin applications\n\nUSAGE:\n    spin doctor [OPTIONS]\n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to check. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin doctor --help\n\nspin-doctor \nDetect and fix problems with Spin applications\n\nUSAGE:\n    spin doctor [OPTIONS]\n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to check. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information                       Print help information{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-doctor"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin help","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin help      \n\nspin 1.0.0 \nThe Spin CLI\n\nOPTIONS:\n    -h, --help       Print help information\n    -V, --version    Print version information\n\nSUBCOMMANDS:\n    add          Scaffold a new component into an existing application\n    build        Build the Spin application\n    cloud        Commands for publishing applications to the Fermyon Platform\n    deploy       Package and upload an application to the Fermyon Platform\n    help         Print this message or the help of the given subcommand(s)\n    login        Log into the Fermyon Platform\n    new          Scaffold a new application based on a template\n    plugins      Install/uninstall Spin plugins\n    registry     Commands for working with OCI registries to distribute applications\n    templates    Commands for working with WebAssembly component templates\n    up           Start the Spin application{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin help      \n\nspin 1.1.0 \nThe Spin CLI\n\nUSAGE:\n    spin <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help       Print help information\n    -V, --version    Print version information\n\nSUBCOMMANDS:\n    add          Scaffold a new component into an existing application\n    build        Build the Spin application\n    cloud        Commands for publishing applications to the Fermyon Platform\n    deploy       Package and upload an application to the Fermyon Platform\n    help         Print this message or the help of the given subcommand(s)\n    login        Log into the Fermyon Platform\n    new          Scaffold a new application based on a template\n    plugins      Install/uninstall Spin plugins\n    registry     Commands for working with OCI registries to distribute applications\n    templates    Commands for working with WebAssembly component templates\n    up           Start the Spin application\n    watch        Rebuild and restart the Spin application when files changes{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin help      \n\nspin 1.2.0\nThe Spin CLI\n\nUSAGE:\n    spin <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help       Print help information\n    -V, --version    Print version information\n\nSUBCOMMANDS:\n    add          Scaffold a new component into an existing application\n    build        Build the Spin application\n    cloud        Commands for publishing applications to the Fermyon Platform\n    deploy       Package and upload an application to the Fermyon Platform\n    help         Print this message or the help of the given subcommand(s)\n    login        Log into the Fermyon Platform\n    new          Scaffold a new application based on a template\n    plugins      Install/uninstall Spin plugins\n    registry     Commands for working with OCI registries to distribute applications\n    templates    Commands for working with WebAssembly component templates\n    up           Start the Spin application\n    watch        Build and run the Spin application, rebuilding and restarting it when files\n                     change{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin help\n\nspin 1.3.0 (9fb8256 2023-06-12)\nThe Spin CLI\n\nUSAGE:\n    spin <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help       Print help information\n    -V, --version    Print version information\n\nSUBCOMMANDS:\n    add          Scaffold a new component into an existing application\n    build        Build the Spin application\n    cloud        Commands for publishing applications to the Fermyon Cloud.\n    deploy       Package and upload an application to the Fermyon Cloud.\n    help         Print this message or the help of the given subcommand(s)\n    login        Log into the Fermyon Cloud.\n    new          Scaffold a new application based on a template\n    plugins      Install/uninstall Spin plugins\n    registry     Commands for working with OCI registries to distribute applications\n    templates    Commands for working with WebAssembly component templates\n    up           Start the Spin application\n    watch        Build and run the Spin application, rebuilding and restarting it when files\n                     change\n{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin help\n\nThe Spin CLI\n\nUSAGE:\n    spin <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help       Print help information\n    -V, --version    Print version information\n\nSUBCOMMANDS:\n    add          Scaffold a new component into an existing application\n    build        Build the Spin application\n    cloud*       Commands for publishing applications to the Fermyon Cloud.\n    deploy       Package and upload an application to the Fermyon Cloud.\n    doctor       Detect and fix problems with Spin applications\n    help         Print this message or the help of the given subcommand(s)\n    login        Log into the Fermyon Cloud.\n    new          Scaffold a new application based on a template\n    plugins      Install/uninstall Spin plugins\n    registry     Commands for working with OCI registries to distribute applications\n    templates    Commands for working with WebAssembly component templates\n    up           Start the Spin application\n    watch        Build and run the Spin application, rebuilding and restarting it when files\n                     change\n\n* implemented via plugin{{ blockEnd }}{{ startTab \"v1.5\"}}{{ blockEnd }}{{ blockEnd }}undefined","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-help"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin login","content":"spin login is a shortcut to undefined.","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-login"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin new","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin new --help  \n\nspin-new \nScaffold a new application based on a template\n\nUSAGE:\n    spin new [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n        --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin new --help  \n\nspin-new \nScaffold a new application based on a template\n\nUSAGE:\n    spin new [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n        --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin new --help  \n\nspin-new \nScaffold a new application based on a template\n\nUSAGE:\n    spin new [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin new --help  \n\nspin-new \nScaffold a new application based on a template\n\nUSAGE:\n    spin new [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin new --help  \n\nspin-new \nScaffold a new application based on a template\n\nUSAGE:\n    spin new [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin new --help  \n\nspin-new \nScaffold a new application based on a template\n\nUSAGE:\n    spin new [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ blockEnd }}undefined.  These commands are similar except that:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-new"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin plugins","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin plugins --help\n\nspin-plugins \nInstall/uninstall Spin plugins\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin plugins --help\n\nspin-plugins \nInstall/uninstall Spin plugins\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin plugins --help\n\nspin-plugins \nInstall/uninstall Spin plugins\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin plugins --help\n\nspin-plugins \nInstall/uninstall Spin plugins\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin plugins --help\n\nspin-plugins \nInstall/uninstall Spin plugins\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin plugins --help\n\nspin-plugins \nInstall/uninstall Spin plugins\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-plugins"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin plugins install","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin plugins install --help\n\nspin-plugins-install \nInstall plugin from a manifest.\n\nThe binary file and manifest of the plugin is copied to the local Spin plugins directory.\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin plugins install --help\n\nspin-plugins-install \nInstall plugin from a manifest.\n\nThe binary file and manifest of the plugin is copied to the local Spin plugins directory.\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin plugins install --help\n\nspin-plugins-install \nInstall plugin from a manifest.\n\nThe binary file and manifest of the plugin is copied to the local Spin plugins directory.\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin plugins install --help\n\nspin-plugins-install \nInstall plugin from a manifest.\n\nThe binary file and manifest of the plugin is copied to the local Spin plugins directory.\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin plugins install --help\n\nspin-plugins-install \nInstall plugin from a manifest.\n\nThe binary file and manifest of the plugin is copied to the local Spin plugins directory.\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin plugins install --help\n\nspin-plugins-install \nInstall plugin from a manifest.\n\nThe binary file and manifest of the plugin is copied to the local Spin plugins directory.\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-plugins-install"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin plugins list","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin plugins list --help   \n\nspin-plugins-list \nList available or installed plugins\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n    -h, --help         Print help information\n        --installed    List only installed plugins{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin plugins list --help   \n\nspin-plugins-list \nList available or installed plugins\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n    -h, --help         Print help information\n        --installed    List only installed plugins{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin plugins list --help   \n\nspin-plugins-list \nList available or installed plugins\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n    -h, --help         Print help information\n        --installed    List only installed plugins{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin plugins list --help   \n\nspin-plugins-list \nList available or installed plugins\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n    -h, --help         Print help information\n        --installed    List only installed plugins{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin plugins list --help   \n\nspin-plugins-list \nList available or installed plugins\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n    -h, --help         Print help information\n        --installed    List only installed plugins{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin plugins list --help   \n\nspin-plugins-list \nList available or installed plugins\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n    -h, --help         Print help information\n        --installed    List only installed plugins{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-plugins-list"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin plugins uninstall","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin plugins uninstall --help\n\nspin-plugins-uninstall \nRemove a plugin from your installation\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin plugins uninstall --help\n\nspin-plugins-uninstall \nRemove a plugin from your installation\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin plugins uninstall --help\n\nspin-plugins-uninstall \nRemove a plugin from your installation\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin plugins uninstall --help\n\nspin-plugins-uninstall \nRemove a plugin from your installation\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin plugins uninstall --help\n\nspin-plugins-uninstall \nRemove a plugin from your installation\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin plugins uninstall --help\n\nspin-plugins-uninstall \nRemove a plugin from your installation\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-plugins-uninstall"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin plugins update","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin plugins update --help   \n\nspin-plugins-update \nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin plugins update --help   \n\nspin-plugins-update \nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin plugins update --help   \n\nspin-plugins-update \nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin plugins update --help   \n\nspin-plugins-update \nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin plugins update --help   \n\nspin-plugins-update \nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin plugins update --help   \n\nspin-plugins-update \nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-plugins-update"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin plugins upgrade","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin plugins upgrade --help\n\nspin-plugins-upgrade \nUpgrade one or all plugins\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin plugins upgrade --help\n\nspin-plugins-upgrade \nUpgrade one or all plugins\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin plugins upgrade --help\n\nspin-plugins-upgrade \nUpgrade one or all plugins\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin plugins upgrade --help\n\nspin-plugins-upgrade \nUpgrade one or all plugins\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin plugins upgrade --help\n\nspin-plugins-upgrade \nUpgrade one or all plugins\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]\n{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin plugins upgrade --help\n\nspin-plugins-upgrade \nUpgrade one or all plugins\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]\n{{ blockEnd }}{{ blockEnd }}undefined For additional information, please see the undefined and/or undefined sections of the documentation.","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-plugins-upgrade"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin registry","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin registry --help\n\nspin-registry \nCommands for working with OCI registries to distribute applications. Currently, the OCI commands are reusing the\ncredentials from ~/.docker/config.json to authenticate to registries\n\nUSAGE:\n    spin registry <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help     Print this message or the help of the given subcommand(s)\n    login    Log in to a registry\n    pull     Pull a Spin application from a registry\n    push     Push a Spin application to a registry{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin registry --help\n\nspin-registry \nCommands for working with OCI registries to distribute applications. Currently, the OCI commands are reusing the\ncredentials from ~/.docker/config.json to authenticate to registries\n\nUSAGE:\n    spin registry <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help     Print this message or the help of the given subcommand(s)\n    login    Log in to a registry\n    pull     Pull a Spin application from a registry\n    push     Push a Spin application to a registry{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin registry --help\n\nspin-registry \nCommands for working with OCI registries to distribute applications\n\nUSAGE:\n    spin registry <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help     Print this message or the help of the given subcommand(s)\n    login    Log in to a registry\n    pull     Pull a Spin application from a registry\n    push     Push a Spin application to a registry{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin registry --help\n\nspin-registry \nCommands for working with OCI registries to distribute applications\n\nUSAGE:\n    spin registry <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help     Print this message or the help of the given subcommand(s)\n    login    Log in to a registry\n    pull     Pull a Spin application from a registry\n    push     Push a Spin application to a registry{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin registry --help\n\nspin-registry \nCommands for working with OCI registries to distribute applications\n\nUSAGE:\n    spin registry <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help     Print this message or the help of the given subcommand(s)\n    login    Log in to a registry\n    pull     Pull a Spin application from a registry\n    push     Push a Spin application to a registry{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin registry --help\n\nspin-registry \nCommands for working with OCI registries to distribute applications\n\nUSAGE:\n    spin registry <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help     Print this message or the help of the given subcommand(s)\n    login    Log in to a registry\n    pull     Pull a Spin application from a registry\n    push     Push a Spin application to a registry{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-registry"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin registry login","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin registry login --help\n\nspin-registry-login \nLog in to a registry\n\nUSAGE:\n    spin registry login [OPTIONS] <SERVER>\n\nARGS:\n    <SERVER>    \n\nOPTIONS:\n    -h, --help                   Print help information\n    -p, --password <PASSWORD>    Password for the registry\n        --password-stdin         Take the password from stdin\n    -u, --username <USERNAME>    Username for the registry{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin registry login --help\n\nspin-registry-login \nLog in to a registry\n\nUSAGE:\n    spin registry login [OPTIONS] <SERVER>\n\nARGS:\n    <SERVER>    \n\nOPTIONS:\n    -h, --help                   Print help information\n    -p, --password <PASSWORD>    Password for the registry\n        --password-stdin         Take the password from stdin\n    -u, --username <USERNAME>    Username for the registry{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin registry login --help\n\nspin-registry-login \nLog in to a registry\n\nUSAGE:\n    spin registry login [OPTIONS] <SERVER>\n\nARGS:\n    <SERVER>    \n\nOPTIONS:\n    -h, --help                   Print help information\n    -p, --password <PASSWORD>    Password for the registry\n        --password-stdin         Take the password from stdin\n    -u, --username <USERNAME>    Username for the registry{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin registry login --help\n\nspin-registry-login \nLog in to a registry\n\nUSAGE:\n    spin registry login [OPTIONS] <SERVER>\n\nARGS:\n    <SERVER>    \n\nOPTIONS:\n    -h, --help                   Print help information\n    -p, --password <PASSWORD>    Password for the registry\n        --password-stdin         Take the password from stdin\n    -u, --username <USERNAME>    Username for the registry{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin registry login --help\n\nspin-registry-login \nLog in to a registry\n\nUSAGE:\n    spin registry login [OPTIONS] <SERVER>\n\nARGS:\n    <SERVER>    \n\nOPTIONS:\n    -h, --help                   Print help information\n    -p, --password <PASSWORD>    Password for the registry\n        --password-stdin         Take the password from stdin\n    -u, --username <USERNAME>    Username for the registry{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin registry login --help\n\nspin-registry-login \nLog in to a registry\n\nUSAGE:\n    spin registry login [OPTIONS] <SERVER>\n\nARGS:\n    <SERVER>    \n\nOPTIONS:\n    -h, --help                   Print help information\n    -p, --password <PASSWORD>    Password for the registry\n        --password-stdin         Take the password from stdin\n    -u, --username <USERNAME>    Username for the registry{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-registry-login"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin registry pull","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin registry pull --help\n\nspin-registry-pull \nPull a Spin application from a registry\n\nUSAGE:\n    spin registry pull [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n    -h, --help        Print help information\n    -k, --insecure    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin registry pull --help\n\nspin-registry-pull \nPull a Spin application from a registry\n\nUSAGE:\n    spin registry pull [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n    -h, --help        Print help information\n    -k, --insecure    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin registry pull --help\n\nspin-registry-pull \nPull a Spin application from a registry\n\nUSAGE:\n    spin registry pull [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n    -h, --help        Print help information\n    -k, --insecure    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin registry pull --help\n\nspin-registry-pull \nPull a Spin application from a registry\n\nUSAGE:\n    spin registry pull [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n    -h, --help        Print help information\n    -k, --insecure    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin registry pull --help\n\nspin-registry-pull \nPull a Spin application from a registry\n\nUSAGE:\n    spin registry pull [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n    -h, --help        Print help information\n    -k, --insecure    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin registry pull --help\n\nspin-registry-pull \nPull a Spin application from a registry\n\nUSAGE:\n    spin registry pull [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n    -h, --help        Print help information\n    -k, --insecure    Ignore server certificate error{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-registry-pull"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin registry push","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin registry push --help \n\nspin-registry-push \nPush a Spin application to a registry\n\nUSAGE:\n    spin registry push [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n    -f, --file <APP_MANIFEST_FILE>    Path to spin.toml\n    -h, --help                        Print help information\n    -k, --insecure                    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin registry push --help \n\nspin-registry-push \nPush a Spin application to a registry\n\nUSAGE:\n    spin registry push [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n    -f, --file <APP_MANIFEST_FILE>    Path to spin.toml\n    -h, --help                        Print help information\n    -k, --insecure                    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin registry push --help \n\nspin-registry-push \nPush a Spin application to a registry\n\nUSAGE:\n    spin registry push [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to push. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n    -k, --insecure                    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v1.3\" }}$ spin registry push --help\n\nspin-registry-push\nPush a Spin application to a registry\n\nUSAGE:\n    spin registry push [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to push. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n    -k, --insecure                    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v1.4\" }}$ spin registry push --help\n\nspin-registry-push\nPush a Spin application to a registry\n\nUSAGE:\n    spin registry push [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to push. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n    -k, --insecure                    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v1.5\" }}$ spin registry push --help\n\nspin-registry-push\nPush a Spin application to a registry\n\nUSAGE:\n    spin registry push [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to push. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n    -k, --insecure                    Ignore server certificate errors\n{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-registry-push"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin templates","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-templates"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin templates install","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin templates install --help\n\nspin-templates-install \nInstall templates from a Git repository or local directory.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --upgrade\n            If present, updates existing templates instead of skipping{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin templates install --help\n\nspin-templates-install \nInstall templates from a Git repository or local directory.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --upgrade\n            If present, updates existing templates instead of skipping{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin templates install --help\n\nspin-templates-install \nInstall templates from a Git repository or local directory.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --upgrade\n            If present, updates existing templates instead of skipping{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin templates install --help\n\nspin-templates-install \nInstall templates from a Git repository or local directory.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --upgrade\n            If present, updates existing templates instead of skipping{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin templates install --help\n\nspin-templates-install \nInstall templates from a Git repository or local directory.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --upgrade\n            If present, updates existing templates instead of skipping{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin templates install --help\n\nspin-templates-install \nInstall templates from a Git repository or local directory.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --upgrade\n            If present, updates existing templates instead of skipping{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-templates-install"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin templates list","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin templates list --help   \n\nspin-templates-list \nList the installed templates\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin templates list --help   \n\nspin-templates-list \nList the installed templates\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin templates list --help   \n\nspin-templates-list \nList the installed templates\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin templates list --help   \n\nspin-templates-list \nList the installed templates\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin templates list --help   \n\nspin-templates-list \nList the installed templates\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin templates list --help   \n\nspin-templates-list \nList the installed templates\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-templates-list"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin templates uninstall","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin templates uninstall --help\n\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin templates uninstall --help\n\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin templates uninstall --help\n\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin templates uninstall --help\n\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin templates uninstall --help\n\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin templates uninstall --help\n\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list\ntpmccallum@192-168-1-16 developer % spin templates uninstall --help\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-templates-uninstall"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin templates upgrade","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin templates upgrade --help  \n\nspin-templates-upgrade \nUpgrade templates to match your current version of Spin.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates upgrade [OPTIONS]\n\nOPTIONS:\n        --all\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade all repositories without prompting\n\n        --branch <BRANCH>\n            The optional branch of the git repository, if a specific repository is given\n\n    -h, --help\n            Print help information\n\n        --repo <GIT_URL>\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade only the specified repository without\n            prompting{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin templates upgrade --help\n\nspin-templates-upgrade \nUpgrade templates to match your current version of Spin.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates upgrade [OPTIONS]\n\nOPTIONS:\n        --all\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade all repositories without prompting\n\n        --branch <BRANCH>\n            The optional branch of the git repository, if a specific repository is given\n\n    -h, --help\n            Print help information\n\n        --repo <GIT_URL>\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade only the specified repository without\n            prompting{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin templates upgrade --help  \n\nspin-templates-upgrade \nUpgrade templates to match your current version of Spin.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates upgrade [OPTIONS]\n\nOPTIONS:\n        --all\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade all repositories without prompting\n\n        --branch <BRANCH>\n            The optional branch of the git repository, if a specific repository is given\n\n    -h, --help\n            Print help information\n\n        --repo <GIT_URL>\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade only the specified repository without\n            prompting{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin templates upgrade --help  \n\nspin-templates-upgrade \nUpgrade templates to match your current version of Spin.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates upgrade [OPTIONS]\n\nOPTIONS:\n        --all\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade all repositories without prompting\n\n        --branch <BRANCH>\n            The optional branch of the git repository, if a specific repository is given\n\n    -h, --help\n            Print help information\n\n        --repo <GIT_URL>\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade only the specified repository without\n            prompting{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin templates upgrade --help  \n\nspin-templates-upgrade \nUpgrade templates to match your current version of Spin.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates upgrade [OPTIONS]\n\nOPTIONS:\n        --all\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade all repositories without prompting\n\n        --branch <BRANCH>\n            The optional branch of the git repository, if a specific repository is given\n\n    -h, --help\n            Print help information\n\n        --repo <GIT_URL>\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade only the specified repository without\n            prompting{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin templates upgrade --help  \n\nspin-templates-upgrade \nUpgrade templates to match your current version of Spin.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates upgrade [OPTIONS]\n\nOPTIONS:\n        --all\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade all repositories without prompting\n\n        --branch <BRANCH>\n            The optional branch of the git repository, if a specific repository is given\n\n    -h, --help\n            Print help information\n\n        --repo <GIT_URL>\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade only the specified repository without\n            prompting{{ blockEnd }}{{ blockEnd }}undefined For additional information, please see the undefined and/or undefined sections of the documentation.","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-templates-upgrade"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin up","content":"The following options are available in relation to running your Spin application.Note: There are three trigger options which only applies to the undefined (--listen, --tls-cert and --tls-key).{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}$ spin up --help\n\nspin-up \nStart the Spin application\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n        --direct-mounts         For local apps with directory mounts and no excluded files, mount\n                                them directly instead of using a temporary directory\n    -e, --env <ENV>             Pass an environment variable (key=value) to all components of the\n                                application\n    -f, --from <APPLICATION>    The application to run. This may be a manifest (spin.toml) file, a\n                                directory containing a spin.toml file, or a remote registry\n                                reference. If omitted, it defaults to \"spin.toml\"\n    -h, --help                  \n    -k, --insecure              Ignore server certificate errors from bindle server or registry\n        --temp <TMP>            Temporary directory for the static assets of the components\n\nTRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --follow <FOLLOW_ID>\n            Print output to stdout/stderr only for given component(s)\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components     \n\n    -q, --quiet\n            Silence all component output to stdout/stderr\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]{{ blockEnd }}{{ startTab \"v1.1\"}}$ spin up --help\n\nspin-up \nStart the Spin application\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n        --direct-mounts         For local apps with directory mounts and no excluded files, mount\n                                them directly instead of using a temporary directory\n    -e, --env <ENV>             Pass an environment variable (key=value) to all components of the\n                                application\n    -f, --from <APPLICATION>    The application to run. This may be a manifest (spin.toml) file, a\n                                directory containing a spin.toml file, or a remote registry\n                                reference. If omitted, it defaults to \"spin.toml\"\n    -h, --help                  \n    -k, --insecure              Ignore server certificate errors from bindle server or registry\n        --temp <TMP>            Temporary directory for the static assets of the components\n\nTRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --follow <FOLLOW_ID>\n            Print output to stdout/stderr only for given component(s)\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components\n\n    -q, --quiet\n            Silence all component output to stdout/stderr\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin up --help\n\nspin-up \nStart the Spin application\n\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n        --direct-mounts         For local apps with directory mounts and no excluded files, mount\n                                them directly instead of using a temporary directory\n    -e, --env <ENV>             Pass an environment variable (key=value) to all components of the\n                                application\n    -f, --from <APPLICATION>    The application to run. This may be a manifest (spin.toml) file, a\n                                directory containing a spin.toml file, or a remote registry\n                                reference. If omitted, it defaults to \"spin.toml\"\n    -h, --help                  \n    -k, --insecure              Ignore server certificate errors from bindle server or registry\n        --temp <TMP>            Temporary directory for the static assets of the components\n\nTRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --follow <FOLLOW_ID>\n            Print output to stdout/stderr only for given component(s)\n\n        --key-value <KEY_VALUES>\n            Set a key/value pair (key=value) in the application's default store. Any existing value\n            will be overwritten. Can be used multiple times\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components\n\n    -q, --quiet\n            Silence all component output to stdout/stderr\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]\n\n        --state-dir <STATE_DIR>\n            Set the application state directory path. This is used in the default locations for\n            logs, key value stores, etc.\n            \n            For local apps, this defaults to `.spin/` relative to the `spin.toml` file. For remote\n            apps, this has no default (unset). Passing an empty value forces the value to be unset.{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin up --help\n\nspin-up \nStart the Spin application\n\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n        --direct-mounts         For local apps with directory mounts and no excluded files, mount\n                                them directly instead of using a temporary directory\n    -e, --env <ENV>             Pass an environment variable (key=value) to all components of the\n                                application\n    -f, --from <APPLICATION>    The application to run. This may be a manifest (spin.toml) file, a\n                                directory containing a spin.toml file, or a remote registry\n                                reference. If omitted, it defaults to \"spin.toml\"\n    -h, --help                  \n    -k, --insecure              Ignore server certificate errors from bindle server or registry\n        --temp <TMP>            Temporary directory for the static assets of the components\n\nTRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --follow <FOLLOW_ID>\n            Print output to stdout/stderr only for given component(s)\n\n        --key-value <KEY_VALUES>\n            Set a key/value pair (key=value) in the application's default store. Any existing value\n            will be overwritten. Can be used multiple times\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components\n\n    -q, --quiet\n            Silence all component output to stdout/stderr\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]\n\n        --state-dir <STATE_DIR>\n            Set the application state directory path. This is used in the default locations for\n            logs, key value stores, etc.\n            \n            For local apps, this defaults to `.spin/` relative to the `spin.toml` file. For remote\n            apps, this has no default (unset). Passing an empty value forces the value to be unset.{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin up --help\n\nspin-up \nStart the Spin application\n\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n        --direct-mounts         For local apps with directory mounts and no excluded files, mount\n                                them directly instead of using a temporary directory\n    -e, --env <ENV>             Pass an environment variable (key=value) to all components of the\n                                application\n    -f, --from <APPLICATION>    The application to run. This may be a manifest (spin.toml) file, a\n                                directory containing a spin.toml file, or a remote registry\n                                reference. If omitted, it defaults to \"spin.toml\"\n    -h, --help                  \n    -k, --insecure              Ignore server certificate errors from bindle server or registry\n        --temp <TMP>            Temporary directory for the static assets of the components\n\nTRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --follow <FOLLOW_ID>\n            Print output to stdout/stderr only for given component(s)\n\n        --key-value <KEY_VALUES>\n            Set a key/value pair (key=value) in the application's default store. Any existing value\n            will be overwritten. Can be used multiple times\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components\n\n    -q, --quiet\n            Silence all component output to stdout/stderr\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]\n\n        --sqlite <SQLITE_STATEMENTS>\n            Run a SQLite statement such as a migration against the default database. To run from a\n            file, prefix the filename with @ e.g. spin up --sqlite @migration.sql\n\n        --state-dir <STATE_DIR>\n            Set the application state directory path. This is used in the default locations for\n            logs, key value stores, etc.\n            \n            For local apps, this defaults to `.spin/` relative to the `spin.toml` file. For remote\n            apps, this has no default (unset). Passing an empty value forces the value to be unset.{{ blockEnd }}{{ startTab \"v1.5\"}}undefined$ spin up --help\n\nspin-up \nStart the Spin application\n\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n        --direct-mounts         For local apps with directory mounts and no excluded files, mount\n                                them directly instead of using a temporary directory\n    -e, --env <ENV>             Pass an environment variable (key=value) to all components of the\n                                application\n    -f, --from <APPLICATION>    The application to run. This may be a manifest (spin.toml) file, a\n                                directory containing a spin.toml file, or a remote registry\n                                reference. If omitted, it defaults to \"spin.toml\"\n    -h, --help                  \n    -k, --insecure              Ignore server certificate errors from bindle server or registry\n        --temp <TMP>            Temporary directory for the static assets of the components\n\nTRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --disable-pooling\n            Enable Wasmtime's pooling instance allocator\n\n        --follow <FOLLOW_ID>\n            Print output to stdout/stderr only for given component(s)\n\n        --key-value <KEY_VALUES>\n            Set a key/value pair (key=value) in the application's default store. Any existing value\n            will be overwritten. Can be used multiple times\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components\n\n    -q, --quiet\n            Silence all component output to stdout/stderr\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]\n\n        --sqlite <SQLITE_STATEMENTS>\n            Run a SQLite statement such as a migration against the default database. To run from a\n            file, prefix the filename with @ e.g. spin up --sqlite @migration.sql\n\n        --state-dir <STATE_DIR>\n            Set the application state directory path. This is used in the default locations for\n            logs, key value stores, etc.\n            \n            For local apps, this defaults to `.spin/` relative to the `spin.toml` file. For remote\n            apps, this has no default (unset). Passing an empty value forces the value to be unset.{{ blockEnd }}{{ blockEnd }}undefined","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-up"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin up (HTTP Trigger)","content":"The following additional trigger options are available for the undefined command, when using the HTTP trigger. E.g. spin up --listen{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}    --listen <ADDRESS>\n        IP address and port to listen on\n\n        [default: 127.0.0.1:3000]\n\n    --tls-cert <TLS_CERT>\n        The path to the certificate to use for https, if this is not set, normal http will be\n        used. The cert should be in PEM format\n\n        [env: SPIN_TLS_CERT=]\n\n    --tls-key <TLS_KEY>\n        The path to the certificate key to use for https, if this is not set, normal http will\n        be used. The key should be in PKCS#8 format\n\n        [env: SPIN_TLS_KEY=]{{ blockEnd }}{{ startTab \"v1.1\"}}    --listen <ADDRESS>\n        IP address and port to listen on\n\n        [default: 127.0.0.1:3000]\n\n    --tls-cert <TLS_CERT>\n        The path to the certificate to use for https, if this is not set, normal http will be\n        used. The cert should be in PEM format\n\n        [env: SPIN_TLS_CERT=]\n\n    --tls-key <TLS_KEY>\n        The path to the certificate key to use for https, if this is not set, normal http will\n        be used. The key should be in PKCS#8 format\n\n        [env: SPIN_TLS_KEY=]{{ blockEnd }}{{ startTab \"v1.2\"}}    --listen <ADDRESS>\n        IP address and port to listen on\n\n        [default: 127.0.0.1:3000]\n\n    --tls-cert <TLS_CERT>\n        The path to the certificate to use for https, if this is not set, normal http will be\n        used. The cert should be in PEM format\n\n        [env: SPIN_TLS_CERT=]\n\n    --tls-key <TLS_KEY>\n        The path to the certificate key to use for https, if this is not set, normal http will\n        be used. The key should be in PKCS#8 format\n\n        [env: SPIN_TLS_KEY=]{{ blockEnd }}{{ startTab \"v1.3\"}}    --listen <ADDRESS>\n        IP address and port to listen on\n\n        [default: 127.0.0.1:3000]\n\n    --tls-cert <TLS_CERT>\n        The path to the certificate to use for https, if this is not set, normal http will be\n        used. The cert should be in PEM format\n\n        [env: SPIN_TLS_CERT=]\n\n    --tls-key <TLS_KEY>\n        The path to the certificate key to use for https, if this is not set, normal http will\n        be used. The key should be in PKCS#8 format\n\n        [env: SPIN_TLS_KEY=]{{ blockEnd }}{{ startTab \"v1.4\"}}    --listen <ADDRESS>\n        IP address and port to listen on\n\n        [default: 127.0.0.1:3000]\n\n    --tls-cert <TLS_CERT>\n        The path to the certificate to use for https, if this is not set, normal http will be\n        used. The cert should be in PEM format\n\n        [env: SPIN_TLS_CERT=]\n\n    --tls-key <TLS_KEY>\n        The path to the certificate key to use for https, if this is not set, normal http will\n        be used. The key should be in PKCS#8 format\n\n        [env: SPIN_TLS_KEY=]{{ blockEnd }}{{ startTab \"v1.5\"}}    --listen <ADDRESS>\n        IP address and port to listen on\n\n        [default: 127.0.0.1:3000]\n\n    --tls-cert <TLS_CERT>\n        The path to the certificate to use for https, if this is not set, normal http will be\n        used. The cert should be in PEM format\n\n        [env: SPIN_TLS_CERT=]\n\n    --tls-key <TLS_KEY>\n        The path to the certificate key to use for https, if this is not set, normal http will\n        be used. The key should be in PKCS#8 format\n\n        [env: SPIN_TLS_KEY=]{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-up-http-trigger"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin watch","content":"{{ tabs \"spin-version\" }}{{ startTab \"v1.1\"}}$ spin watch --help\n\nspin-watch\nBuild and run the Spin application, rebuilding and restarting it when files change\n\nUSAGE:\n    spin watch [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    Arguments to be passed through to spin up\n\nOPTIONS:\n    -c, --clear                       Clear the screen before each run\n    -d, --debounce <DEBOUNCE>         Set the timeout between detected change and re-execution, in\n                                      milliseconds [default: 100]\n    -f, --file <APP_MANIFEST_FILE>    Path to spin.toml [default: spin.toml]\n    -h, --help                        Print help information\n        --skip-build                  Only run the Spin application, restarting it when build\n                                      artifacts change{{ blockEnd }}{{ startTab \"v1.2\"}}$ spin watch --help\n\nspin-watch \nBuild and run the Spin application, rebuilding and restarting it when files change\n\nUSAGE:\n    spin watch [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    Arguments to be passed through to spin up\n\nOPTIONS:\n    -c, --clear                       Clear the screen before each run\n    -d, --debounce <DEBOUNCE>         Set the timeout between detected change and re-execution, in\n                                      milliseconds [default: 100]\n    -f, --from <APP_MANIFEST_FILE>    The application to watch. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n        --skip-build                  Only run the Spin application, restarting it when build\n                                      artifacts change{{ blockEnd }}{{ startTab \"v1.3\"}}$ spin watch --help\n\nspin-watch \nBuild and run the Spin application, rebuilding and restarting it when files change\n\nUSAGE:\n    spin watch [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    Arguments to be passed through to spin up\n\nOPTIONS:\n    -c, --clear                       Clear the screen before each run\n    -d, --debounce <DEBOUNCE>         Set the timeout between detected change and re-execution, in\n                                      milliseconds [default: 100]\n    -f, --from <APP_MANIFEST_FILE>    The application to watch. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n        --skip-build                  Only run the Spin application, restarting it when build\n                                      artifacts change{{ blockEnd }}{{ startTab \"v1.4\"}}$ spin watch --help\n\nspin-watch \nBuild and run the Spin application, rebuilding and restarting it when files change\n\nUSAGE:\n    spin watch [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    Arguments to be passed through to spin up\n\nOPTIONS:\n    -c, --clear                       Clear the screen before each run\n    -d, --debounce <DEBOUNCE>         Set the timeout between detected change and re-execution, in\n                                      milliseconds [default: 100]\n    -f, --from <APP_MANIFEST_FILE>    The application to watch. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n        --skip-build                  Only run the Spin application, restarting it when build\n                                      artifacts change{{ blockEnd }}{{ startTab \"v1.5\"}}$ spin watch --help\n\nspin-watch \nBuild and run the Spin application, rebuilding and restarting it when files change\n\nUSAGE:\n    spin watch [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    Arguments to be passed through to spin up\n\nOPTIONS:\n    -c, --clear                       Clear the screen before each run\n    -d, --debounce <DEBOUNCE>         Set the timeout between detected change and re-execution, in\n                                      milliseconds [default: 100]\n    -f, --from <APP_MANIFEST_FILE>    The application to watch. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n        --skip-build                  Only run the Spin application, restarting it when build\n                                      artifacts change{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#spin-watch"},{"project":"v1","title":"Spin Command Line Interface (CLI) Reference","subheading":"Stability Table","content":"CLI commands have four phases that indicate levels of stability:undefinedundefinedundefinedundefined{{ tabs \"spin-version\" }}{{ startTab \"v1.0\"}}| Command                                                    | Stability   |\n| ---------------------------------------------------------- | ----------- |\n| <code>spin add</code>                                      | Stable      |\n| <code>spin build</code>                                    | Stable      |\n| <code>spin new</code>                                      | Stable      |\n| <code>spin plugins</code>                                  | Stable      |\n| <code>spin templates </code>                               | Stable      |\n| <code>spin up</code>                                       | Stable      |\n| <code>spin cloud </code>                                   | Stabilizing |\n| <code>spin registry</code>                                 | Stabilizing |\n| <code>spin bindle</code>                                   | Deprecated  |{{ blockEnd }}{{ startTab \"v1.1\"}}| Command                                                                               | Stability    |\n| ------------------------------------------------------------------------------------- | ------------ |\n| <code>spin add</code>                                                                 | Stable       |\n| <code>spin build</code>                                                               | Stable       |\n| <code>spin new</code>                                                                 | Stable       |\n| <code>spin plugins</code>                                                             | Stable       |\n| <code>spin templates</code>                                                           | Stable       |\n| <code>spin up</code>                                                                  | Stable       |\n| <code>spin cloud</code>                                                               | Stabilizing  |\n| <code>spin registry</code>                                                            | Stabilizing  |\n| <code>spin watch</code>                                                               | Experimental |\n| <code>spin bindle</code>                                                              | Deprecated   |{{ blockEnd }}{{ startTab \"v1.2\"}}| Command                                                                               | Stability    |\n| ------------------------------------------------------------------------------------- | ------------ |\n| <code>spin add</code>                                                                 | Stable       |\n| <code>spin build</code>                                                               | Stable       |\n| <code>spin new</code>                                                                 | Stable       |\n| <code>spin plugins</code>                                                             | Stable       |\n| <code>spin templates</code>                                                           | Stable       |\n| <code>spin up</code>                                                                  | Stable       |\n| <code>spin cloud</code>                                                               | Stabilizing  |\n| <code>spin registry</code>                                                            | Stabilizing  |\n| <code>spin watch</code>                                                               | Experimental |\n| <code>spin bindle</code>                                                              | Deprecated   |{{ blockEnd }}{{ startTab \"v1.3\"}}| Command                                                                               | Stability    |\n| ------------------------------------------------------------------------------------- | ------------ |\n| <code>spin add</code>                                                                 | Stable       |\n| <code>spin build</code>                                                               | Stable       |\n| <code>spin new</code>                                                                 | Stable       |\n| <code>spin plugins</code>                                                             | Stable       |\n| <code>spin templates</code>                                                           | Stable       |\n| <code>spin up</code>                                                                  | Stable       |\n| <code>spin cloud</code>                                                               | Stabilizing  |\n| <code>spin registry</code>                                                            | Stabilizing  |\n| <code>spin watch</code>                                                               | Experimental |\n| <code>spin bindle</code>                                                              | Deprecated   |{{ blockEnd }}{{ startTab \"v1.4\"}}| Command                                                                               | Stability    |\n| ------------------------------------------------------------------------------------- | ------------ |\n| <code>spin add</code>                                                                 | Stable       |\n| <code>spin build</code>                                                               | Stable       |\n| <code>spin new</code>                                                                 | Stable       |\n| <code>spin plugins</code>                                                             | Stable       |\n| <code>spin templates</code>                                                           | Stable       |\n| <code>spin up</code>                                                                  | Stable       |\n| <code>spin cloud</code>                                                               | Stabilizing  |\n| <code>spin registry</code>                                                            | Stabilizing  |\n| <code>spin doctor</code>                                                              | Experimental |\n| <code>spin watch</code>                                                               | Experimental |\n| <code>spin bindle</code>                                                              | Deprecated   |{{ blockEnd }}{{ startTab \"v1.5\"}}| Command                                                                               | Stability    |\n| ------------------------------------------------------------------------------------- | ------------ |\n| <code>spin add</code>                                                                 | Stable       |\n| <code>spin build</code>                                                               | Stable       |\n| <code>spin new</code>                                                                 | Stable       |\n| <code>spin plugins</code>                                                             | Stable       |\n| <code>spin templates</code>                                                           | Stable       |\n| <code>spin up</code>                                                                  | Stable       |\n| <code>spin cloud</code>                                                               | Stabilizing  |\n| <code>spin registry</code>                                                            | Stabilizing  |\n| <code>spin doctor</code>                                                              | Experimental |\n| <code>spin watch</code>                                                               | Experimental |\n| <code>spin bindle</code>                                                              | Deprecated   |{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/cli-reference#stability-table"},{"project":"v1","title":"Contributing to Docs","subheading":"","content":"undefinedundefinedundefinedundefinedWe are delighted that you are interested in making our developer documentation better. Thank you! We welcome and appreciate contributions of all types — opening issues, fixing typos, adding examples, one-liner code fixes, tests, or complete features.Any contribution and interaction to the Spin project MUST follow our undefined. Thank you for being part of an inclusive and open community!Below are a few pointers designed to help you contribute.","keywords":"contribute contributing","subsectionKeywords":"","url":"/v1/contributing-docs"},{"project":"v1","title":"Contributing to Docs","subheading":"Technical Documentation Types","content":"The following points will help guide your contribution from a resource-type perspective; essentially we would really appreciate you creating and contributing any of the following 4 resource types.","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#technical-documentation-types"},{"project":"v1","title":"Contributing to Docs","subheading":"1. Tutorials","content":"Tutorials are oriented toward learning. Tutorials are designed to get a user started on something new (that they have not tried before). You can think of a tutorial as a lesson i.e. teaching a Spin user undefined. The tutorial may contain many logically ordered steps i.e. installing Spin, installing Redis, using Spin templates, configuring a Spin application and so forth. The desired outcome for a tutorial is for the user to have a working deployment or application. Think of it as a lesson in how to bake a cake.","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#1-tutorials"},{"project":"v1","title":"Contributing to Docs","subheading":"2. How-To Guides","content":"How-to guides are oriented towards showing a user how to solve a problem, which leads them to be able to achieve their own goal. The how-to guide will follow a series of logical steps. Think of it as providing a recipe for the user's creativity. For example, you can show a user how to _develop a Spin application](/writing) without telling them what the application must do; that is up to the user's imagination.","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#2-how-to-guides"},{"project":"v1","title":"Contributing to Docs","subheading":"3. Reference","content":"Reference resources are merely a dry description; describing the feature in its simplest form. A great example of a reference resource is the undefined. You will notice that the CLI Reference page simply lists all of the commands and available options.","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#3-reference"},{"project":"v1","title":"Contributing to Docs","subheading":"4. Explanation","content":"An explanation resource is written using a deep-dive approach i.e. providing a deep explanation with the view to impart a deep understanding of a particular concept, feature or product. You may find your contribution is so in-depth that it becomes a long form article like a blog post.","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#4-explanation"},{"project":"v1","title":"Contributing to Docs","subheading":"Technical Documentation Procedure (Text)","content":"","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#technical-documentation-procedure-text"},{"project":"v1","title":"Contributing to Docs","subheading":"1. Fork the Repository","content":"The first step is to fork the undefined, from Spin's GitHub, to your own GitHub account. Ensure that you are forking the developer repository undefined GitHub account; where you have full editing privileges.","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#1-fork-the-repository"},{"project":"v1","title":"Contributing to Docs","subheading":"2. Clone the Fork","content":"Copy the URL from the UI in readiness for running the git clone command. Go ahead and clone the new fork that you just created (the one which resides in your own GitHub account):$ cd ~\n$ git clone git@github.com:yourusername/spin-docs.git\n$ cd spin-docs","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#2-clone-the-fork"},{"project":"v1","title":"Contributing to Docs","subheading":"3. Create New Branch","content":"Create a new branch that will house all of your changes for this specific contribution:$ git checkout -b my_new_branch","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#3-create-new-branch"},{"project":"v1","title":"Contributing to Docs","subheading":"4. Add Upstream","content":"Create a new remote for the upstream (a pointer to the original repository to which you are contributing):$ git remote add upstream https://github.com/spinframework/spin-docs","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#4-add-upstream"},{"project":"v1","title":"Contributing to Docs","subheading":"5. Code Blocks, Annotations and Table of Contents (ToC)","content":"It is highly recommended that you use either the <!-- @selectiveCpy --> or the <!-- @nocpy --> annotation before each of your code blocks, and that each code block defines the appropriate undefined. The annotation can be skipped for code blocks with example code snippets i.e. non-terminal or generic output examples.undefinedThe selective copy annotation (<!-- @selectiveCpy -->) is intended for use when communicating code and/or CLI commands for the reader to copy and paste. The selective copy annotation allows the reader to see the entire code block (both commands and results) but only copies the lines that start with $ into the reader's clipboard (minus the $) when the user clicks the copy button. For example, copying the following code block will only copy echo \"hello\" into your clipboard, for pasting.$ echo \"hello\"\nhelloundefinedundefinedThe no copy annotation (<!-- @nocpy -->) precedes a code block where no copy and pasting of code is intended. If using the no copy attribute please still be sure to add the appropriate syntax highlighting to your code block (for display purposes). For example:<!-- @nocpy -->Some generic code not intended for copying/pastingundefined - just a straight copy without any additional features.If you want the code in a code block to be copyable with no \"smarts\" to remove the $ then you can just simply leave out the annotation altogether. A code block in markdown will be copyable without smarts just as is.undefinedMulti-tab code blocks have recently been implemented. Examples can be seen in the undefined installer documentation and undefined. The above examples demonstrate how tabs can either represent platforms i.e. Windows, Linux and macOS or represent specific programming languages i.e. Rust, JavaScript and Golang etc. Here is a brief example of how to implement multi-tab code blocks when writing technical documentation for this site, using markdown.The first step to implementing multi-tab code blocks is placing the enable_shortcodes = true configuration at the start of the .md file. Specifically, in the .md file's frontmatter.The markup to create tabs in markdown is as follows{{ tabs \"os\" }}\n\n{{ startTab \"Windows\"}}\n\nTo list files on windows use `dir`\n\n<!-- @selectiveCpy -->\n\n\\`\\`\\`bash\n$ dir hello_world\n\\`\\`\\`\nand script in windows have the extension `.bat`\n\n<!-- @nocpy -->\n\n\\`\\`\\`bash\nhello.bat\ntest.bat\n\\`\\`\\`\n\n{{ blockEnd }}\n\n{{ startTab \"Linux\"}}\n\nTo list files on linux use `ls`\n\n<!-- @selectiveCpy -->\n\n\\`\\`\\`bash\n$ ls\n\\`\\`\\`\n\nand script in linux have the extension `.sh`\n\n<!-- @nocpy -->\n\n\\`\\`\\`bash\nhello.sh\ntest.sh\n\\`\\`\\`\n\n{{ blockEnd }}\n{{ blockEnd }}undefined: Existing documentation will already be using class names for code block tabs and startTab i.e. {{ tabs \"os\" }} and {{ startTab \"Windows\"}} respectively. Please consult the following tabs and startTab class names that are already in use (before creating your own). If you need to create a new class name (because one does not already exist) please add it to the list below as part of the pull request that contains your code block contribution.undefined:undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedThe next section covers the highly recommended use of ToCs.undefinedIf you create content with many headings it is highly recommended to place a ToC in your markdown file. There are excellent extensions (such as this Visual Studio Code Extension called undefined which will automatically generate your ToC).","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#5-code-blocks-annotations-and-table-of-contents-toc"},{"project":"v1","title":"Contributing to Docs","subheading":"6.1 Checking Your Content - Using NPM","content":"Once you are satisfied with your contribution, you can programmatically check your content.If you have not done so already, please go ahead and perform the npm install command; to enable Node dependencies such as markdownlint-cli2. Simply run the following command, from the root of the developer repository:$ npm installWith all Node dependencies installed, you can now check for broken links (which takes several minutes) and also lint your markdown files. Simply run the following command, from the root of the developer repository:$ npm run testundefined Optionally you can run only the linter with the following command:# Example of how to lint all Markdown files in a local folder (in this case the spin folder) \nnpx markdownlint-cli2 content/spin/*.md \\\"#node_modules\\\"\n# Example of how to lint a local Markdown file\nnpx markdownlint-cli2 content/spin/install.md \\\"#node_modules\\\"undefined Whilst the npm run test command (which lints and also programmatically checks all URLs) does take extra time to complete it undefined be utilized before you undefined; preventing the potential pushing of broken URLs to the developer documentation site.","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#61-checking-your-content---using-npm"},{"project":"v1","title":"Contributing to Docs","subheading":"6.2 Indexing Your Content","content":"The developer documentation site implements in-house search. A new index is automatically generated for you when your contribution is merged into the developer documentation repository. This is done via a GitHub action. The following section explains how to alter content to increase search visibility for your content.","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#62-indexing-your-content"},{"project":"v1","title":"Contributing to Docs","subheading":"6.3 Increasing Search Visibility For Your Content","content":"The built-in search functionality is based on the indexing of individual words in each markdown file, which works well most of the time. However, there are a couple of scenarios where you undefined want to deliberately increase search visibility for your content.undefinedWords in a documentation markdown file may not be words that are searched for by a user. For example, you may write about \"different HTTP listening options\" whereas a user may only ever try to find that specific content using a search phrase like \"alternate port\". If you are aware of typical user search phrases it is always recommended to craft your content to include any predictable user search phrases. However, in the rare case of a mismatch between words in your content and the words a user searches for, you can utilize use the keywords string in the [extra] section of your document's frontmatter to increase visibility. For example, the following code block shows frontmatter that helps a user find your documentation page (when the user searches for port):[extra]\nkeywords = \"port ports\"Adding a word to the keywords string of a page overrides the built-in search functionality by at least one order of magnitude. Adding a word to the keywords string may displace other content, so please use it only if necessary.undefinedThe keywords string takes users to the start of a page. In some cases, this is not ideal. You may want to home in on specific content to resolve a search query.If a search term relates to a specific part of a page, you may use the following syntax anywhere in the body of your markdown file, and the user's search action will direct them straight to the previous heading (nearest heading above the @searchTerm syntax).<!-- @searchTerm \"homing\" -->When using the above @searchTerm feature, please note the following:undefinedundefinedExample: If you search for the word \"homing\", the results will point you to the previous heading in this specific section of the developer documentation.undefined","keywords":"","subsectionKeywords":"  homing ","url":"/v1/contributing-docs#63-increasing-search-visibility-for-your-content"},{"project":"v1","title":"Contributing to Docs","subheading":"6.4 The Edit On GitHub Button","content":"Each markdown file in the developer documentation requires a link to its GitHub page for the site to correctly render the \"Edit on GitHub\" button for that page.undefinedIf you create a new markdown file and/or you notice a file without the explicit GitHub URL, please add a URL entry to the [extra] section. For example, the following url is required for this page that you are reading (you can check the raw markdown contents of this page to see this example):[extra]\nurl = \"https://github.com/spinframework/spin-docs/blob/main/content/spin/v1/contributing-docs.md\"","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#64-the-edit-on-github-button"},{"project":"v1","title":"Contributing to Docs","subheading":"6.5 How To Properly Edit CSS Styles","content":"undefinedDirectly editing .css files is not recommended, because .css files are overwritten. Instead, if you would like to make and test a new/different style please go ahead and update the appropriate .scss file. The following command will automatically update the .css file that is relevant to the .scss file that you are editing:$ npm run stylesThe above command is designed to be run in the background; enabling you to view your design changes (that are reflected in the .css) while you are editing the .scss in real-time. If you are not running this command in the background (i.e. just deliberately regenerating the .css files once), then the above command can be stopped by pressing Ctrl + C.","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#65-how-to-properly-edit-css-styles"},{"project":"v1","title":"Contributing to Docs","subheading":"6.6 Checking Your Content - Using Bartholomew's CLI","content":"The Bartholomew Command Line Interface (CLI) Tool is called bart. The bart CLI is a tool that simplifies working with undefined websites. undefined is a WebAssembly (Wasm) content management system (CMS). The bart CLI is handy to ensure quality assurance of new and existing content. Installing the CLI is a cinch, so please go ahead and use it when contributing.To build the Bartholomew CLI from source perform the following commands:$ cd ~\n$ git clone https://github.com/fermyon/bartholomew.git\n$ cd ~/bartholomew\n$ make bartOnce built, you will find the bart CLI executable in the ~/bartholomew/target/release directory. However, for convenience it would be a great idea to go ahead and add the bart executable to your system path, for example:$ sudo mv ~/bartholomew/target/release/bart /usr/local/bin/Once installed, you can use the CLI's --help flag to learn more. For example:$ bart --help\nbart 0.6.0\nThe Bartholomew CLI\n\nUSAGE:\n    bart <SUBCOMMAND>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nSUBCOMMANDS:\n    calendar    Print the content calendar for a Bartholomew website\n    check       Check content and identify errors or warnings\n    help        Prints this message or the help of the given subcommand(s)\n    new         Create a new page or website from a templateLet's take a quick look at how you can use the bart CLI to check any content that you are wanting to contribute.","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#66-checking-your-content---using-bartholomews-cli"},{"project":"v1","title":"Contributing to Docs","subheading":"6.7 Checking Your Content - Preview a Documentation Page on Localhost","content":"You can host your changes to the developer documentation on your own machine (localhost) by using the following spin commands:$ npm install\n$ cd spin-up-hub\n$ npm install\n$ cd ..\n$ spin build\n$ spin up -e \"PREVIEW_MODE=1\"undefined","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#67-checking-your-content---preview-a-documentation-page-on-localhost"},{"project":"v1","title":"Contributing to Docs","subheading":"7. Checking Web Pages","content":"The bart check command can be used to check the content. Simply pass in the content as a parameter. The developer documentation undefined, so always pass --shortcodes ./shortcodes as shown below:$ bart check --shortcodes ./shortcodes content/spin/variables.md\nshortcodes: registering alert\nshortcodes: registering details\nshortcodes: registering tabs\nshortcodes: registering startTab\nshortcodes: registering blockEnd\n✅ content/spin/variables.mdundefined","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#7-checking-web-pages"},{"project":"v1","title":"Contributing to Docs","subheading":"8. Add Changes","content":"Once your changes have been checked, go ahead and add your changes by moving to a top-level directory, under which your changes exist i.e. cd ~/spin-docs.Add your changes by running the following command, from the root of the developer repository:$ git add","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#8-add-changes"},{"project":"v1","title":"Contributing to Docs","subheading":"9. Commit Changes","content":"Before committing, please ensure that your GitHub installation is configured sufficiently so that you can --signoff as part of the git commit command. For example, please ensure that the user.name and user.email are configured in your terminal. You can check if these are set by typing git config --list.If you need to set these values please use the following commands:$ git config user.name \"yourusername\"$ git config user.email \"youremail@somemail.com\"More information can be found at this GitHub documentation page called undefined.Type the following commit command to ensure that you sign off (--signoff), sign the data (-S) - recommended, and also leave a short message (-m):$ git commit -S --signoff -m \"Updating documentation\"undefined","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#9-commit-changes"},{"project":"v1","title":"Contributing to Docs","subheading":"10. Push Changes","content":"At this stage, it is a good idea to just quickly check what GitHub thinks the origin is. For example, if we type git remote -v we can see that the origin is our repo; which we a) forked the original repo into and b) which we then cloned to our local disk so that we could edit:$ git remote -vThe above command will return output similar to the following:origin\tgit@github.com:yourusername/developer.git (fetch)\norigin\tgit@github.com:yourusername/developer.git (push)\nupstream\thttps://github.com/spinframework/spin-docs (fetch)\nupstream\thttps://github.com/spinframework/spin-docs (push)Once you are satisfied go ahead and push your changes:$ git push -u origin my_new_branch","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#10-push-changes"},{"project":"v1","title":"Contributing to Docs","subheading":"11. Create a Pull Request","content":"If you return to your GitHub repository in your browser, you will notice that a PR has automatically been generated for you.Clicking on the green “Compare and pull request” button will allow you to add a title and description as part of the PR.undefinedYou can also add any information in the textbox provided below the title. For example, screen captures and/or code/console/terminal snippets of your contribution working correctly and/or tests passing etc.Once you have finished creating your PR, please keep an eye on the PR; answering any questions as part of the collaboration process.undefinedThanks for contributing.","keywords":"","subsectionKeywords":"","url":"/v1/contributing-docs#11-create-a-pull-request"},{"project":"v1","title":"Contributing to Spin","subheading":"","content":"undefinedundefinedundefinedWe are delighted that you are interested in making Spin better! Thank you! This\ndocument will guide you through making your first contribution to the project.\nWe welcome and appreciate contributions of all types — opening issues, fixing\ntypos, adding examples, one-liner code fixes, tests, or complete features.First, any contribution and interaction on the Spin project MUST follow our\nundefined. Thank you for being\npart of an inclusive and open community!If you plan on contributing anything complex, please go through the issue and PR\nqueues first to make sure someone else has not started working on it. If it\ndoesn't exist already, please open an issue so you have a chance to get feedback\nfrom the community and the maintainers before you start working on your feature.","subsectionKeywords":"","url":"/v1/contributing-spin"},{"project":"v1","title":"Contributing to Spin","subheading":"Making Code Contributions to Spin","content":"The following guide is intended to make sure your contribution can get merged as\nsoon as possible. First, make sure you have the following prerequisites\nconfigured:undefinedundefinedundefinedundefinedundefinedOnce you have set up the prerequisites and identified the contribution you want\nto make to Spin, make sure you can correctly build the project:# clone the repository\n$ git clone https://github.com/spinframework/spin && cd spin\n# add a new remote pointing to your fork of the project\n$ git remote add fork https://github.com/<your-username>/spin\n# create a new branch for your work\n$ git checkout -b <your-branch>\n\n# build the Spin CLI\n$ cargo build\n\n# make sure compilation is successful\n$ ./target/debug/spin --help\n\n# run the tests and make sure they pass\n$ make testNow you should be ready to start making your contribution. To familiarize\nyourself with the Spin project, please read the\nundefined. Since most of Spin is implemented in\nRust, we try to follow the common Rust coding conventions (keep an eye on the\nrecommendations from Clippy!). If applicable, add unit or integration tests to\nensure your contribution is correct.","keywords":"","subsectionKeywords":"","url":"/v1/contributing-spin#making-code-contributions-to-spin"},{"project":"v1","title":"Contributing to Spin","subheading":"Before You Commit","content":"undefinedundefinedundefinedundefinedSpin enforces lints and tests as part of continuous integration - running them locally will save you a round-trip to your pull request!If everything works locally, you're ready to commit your changes.","keywords":"","subsectionKeywords":"","url":"/v1/contributing-spin#before-you-commit"},{"project":"v1","title":"Contributing to Spin","subheading":"Committing and Pushing Your Changes","content":"We require commits to be signed both with an email address and with a GPG signature.undefined$ git commit -S -s -m \"<your commit message>\"undefinedWe try to only keep useful changes as separate commits — if you prefer to commit\noften, please\nundefined\nbefore opening a pull request.Once you are happy with your changes you can push the branch to your fork:# \"fork\" is the name of the git remote pointing to your fork\n$ git push forkNow you are ready to create a pull request. Thank you for your contribution!","keywords":"","subsectionKeywords":"","url":"/v1/contributing-spin#committing-and-pushing-your-changes"},{"project":"v1","title":"Publishing and Distribution","subheading":"","content":"undefinedundefinedundefinedundefinedIf you would like to publish a Spin application, so that other users can run it, you can do so using a undefined.{{ details \"What's all this about containers?\" \"The registry protocol was originally created to publish and distribute Docker containers. Over time, registries have evolved to host other kinds of artifact - see undefined for more information. However, the term remains, in services such as GitHub Container Registry or AWS Elastic Container Registry, and in the generic description undefined. When you use a 'container' registry to publish and distribute Spin applications, there are no actual containers involved at all!\" }}Many cloud services offer public registries.  Examples include GitHub Container Registry, Docker Hub, or Amazon Elastic Container Registry.  These support both public and private distribution.  You can also run your own registry using open source software.","subsectionKeywords":"","url":"/v1/distributing-apps"},{"project":"v1","title":"Publishing and Distribution","subheading":"Logging Into a Registry","content":"Before you can publish to a registry, or run applications whose registry artifacts are private, you must log in to the registry.  This example shows logging into the GitHub Container Registry, ghcr.io:$ spin registry login ghcr.ioIf you don't provide any options to spin registry login, it prompts you for a username and password.","keywords":"","subsectionKeywords":"","url":"/v1/distributing-apps#logging-into-a-registry"},{"project":"v1","title":"Publishing and Distribution","subheading":"Logging In Using a Token","content":"In a non-interactive environment such as GitHub Actions, you will typically log in using a token configured in the environment settings, rather than a password.  To do this, use the --password-stdin flag, and echo the token value to the login command's standard input.  This example shows logging into GHCR from a GitHub action:$ echo \"$\\{{ secrets.GITHUB_TOKEN }}\" | spin registry login ghcr.io --username $\\{{ github.actor }} --password-stdinOther environments will have different ways of referring to the token and user but the pattern remains the same.","keywords":"","subsectionKeywords":"","url":"/v1/distributing-apps#logging-in-using-a-token"},{"project":"v1","title":"Publishing and Distribution","subheading":"Fallback Credentials","content":"If you have logged into a registry using docker login, but not using spin registry login, Spin will fall back to your Docker credentials.","keywords":"","subsectionKeywords":"","url":"/v1/distributing-apps#fallback-credentials"},{"project":"v1","title":"Publishing and Distribution","subheading":"Publishing a Spin Application to a Registry","content":"To publish an application to a registry, use the spin registry push command.  You must provide a undefined for the published application.  This is a string whose format is defined by the registry standard, and generally consists of <registry>/<username>/<application-name>:<version>.  (In specific circumstances you may be able to omit the username and/or the version.  If you want more detail on references, see the OCI documentation.)undefinedHere is an example of pushing an application to GHCR:$ spin registry push ghcr.io/alyssa-p-hacker/hello-world:v1\nPushed with digest sha256:06b19Notice that the username is part of the reference; the registry does not infer it from the login.  Also notice that the version is specified explicitly; Spin does not infer it from the spin.toml file.undefined","keywords":"","subsectionKeywords":"","url":"/v1/distributing-apps#publishing-a-spin-application-to-a-registry"},{"project":"v1","title":"Publishing and Distribution","subheading":"Running Published Applications","content":"To run a published application from a registry, use spin up -f and pass the registry reference:$ spin up -f ghcr.io/alyssa-p-hacker/hello-world:v1undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/distributing-apps#running-published-applications"},{"project":"v1","title":"Publishing and Distribution","subheading":"Running Published Applications by Digest","content":"Registry versions are mutable; that is, the owner of an application can change which build the :v1 label points to at any time.  If you want to run a specific build of the package, you can refer to it by undefined.  This is similar to a Git commit hash: it is immutable, meaning the same digest always gets the exact same data, no matter what the package owner does.  To do this, use the @sha256:... syntax instead of the :v... syntax:$ spin up -f ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19","keywords":"","subsectionKeywords":"","url":"/v1/distributing-apps#running-published-applications-by-digest"},{"project":"v1","title":"Publishing and Distribution","subheading":"Pulling a Published Application","content":"spin up automatically downloads the application from the registry. If you want to manually download the application, without running it, use the spin registry pull command:$ spin registry pull ghcr.io/alyssa-p-hacker/hello-world:v1\n$ spin registry pull ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19undefined","keywords":"","subsectionKeywords":"","url":"/v1/distributing-apps#pulling-a-published-application"},{"project":"v1","title":"Publishing and Distribution","subheading":"Signing Spin Applications and Verifying Signatures","content":"Because Spin uses the container registry standards to distribute applications, it can also take advantage of tooling built around those standards.  Here is an example of using undefined to sign and verify a Spin application:# Push your Spin application to any registry that supports the OCI registry artifacts,\n# such as the GitHub Container Registry, Docker Hub, Azure ACR, or AWS ECR.\n$ spin registry push ghcr.io/alyssa-p-hacker/hello-world:v1\n\n# You can now sign your Spin app using Cosign (or any other tool that can sign\n# OCI registry objects).\n$ cosign sign ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19\nGenerating ephemeral keys...\nRetrieving signed certificate...\ntlog entry created with index: 12519542\nPushing signature to: ghcr.io/alyssa-p-hacker/hello-world\n\n# Someone interested in your application can now use Cosign to verify the signature\n# before running the application.\n$ cosign verify ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19\nVerification for ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19 --\nThe following checks were performed on each of these signatures:\n  - The cosign claims were validated\n  - Existence of the claims in the transparency log was verified offline\n  - Any certificates were verified against the Fulcio roots.\n\n# The consumer of your app can now run it from the registry.\n$ spin up -f ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19undefined","keywords":"","subsectionKeywords":"","url":"/v1/distributing-apps#signing-spin-applications-and-verifying-signatures"},{"project":"v1","title":"Dynamic and Runtime Application Configuration","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedConfiguration for Spin application features such as undefined,\nundefined, undefined\nand undefined can be supplied dynamically, i.e. during the application runtime,\nrequiring no changes to the application code itself.This runtime configuration data is stored in the runtime-config.toml file and passed in via the --runtime-config-file flag\nwhen invoking the spin up command.The list of Spin features supporting runtime configuration includes:undefinedundefinedundefinedundefinedLet's look at each configuration category in-depth below.","subsectionKeywords":"","url":"/v1/dynamic-configuration"},{"project":"v1","title":"Dynamic and Runtime Application Configuration","subheading":"Application Variables Runtime Configuration","content":"undefined values may be set at runtime by providers. Currently,\nthere are two application variable providers: the undefined and\nthe undefined.  The provider examples below show how to use or configure each\nprovider. For examples on how to access these variables values within your application, see\nundefined.","keywords":"","subsectionKeywords":"","url":"/v1/dynamic-configuration#application-variables-runtime-configuration"},{"project":"v1","title":"Dynamic and Runtime Application Configuration","subheading":"Environment Variable Provider","content":"The environment variable provider gets variable values from the spin process's\nenvironment (undefined the component environment). Variable keys are translated\nto environment variables by upper-casing and prepending with SPIN_CONFIG_:$ export SPIN_CONFIG_API_KEY = \"1234\"  # Sets the `api_key` value.\n$ spin up","keywords":"","subsectionKeywords":"","url":"/v1/dynamic-configuration#environment-variable-provider"},{"project":"v1","title":"Dynamic and Runtime Application Configuration","subheading":"Vault Application Variable Provider","content":"The Vault application variable provider gets secret values from undefined.\nCurrently, only the undefined is supported.\nYou can set up the v2 kv secret engine at any mount point and provide Vault information in\nthe undefined file:[[config_provider]]\ntype = \"vault\"\nurl = \"http://127.0.0.1:8200\"\ntoken = \"root\"\nmount = \"secret\"","keywords":"","subsectionKeywords":"","url":"/v1/dynamic-configuration#vault-application-variable-provider"},{"project":"v1","title":"Dynamic and Runtime Application Configuration","subheading":"Vault Application Variable Provider Example","content":"undefinedundefined$ vault server -dev -dev-root-token-id rootundefined$ export VAULT_TOKEN=root\n$ export VAULT_ADDR=http://127.0.0.1:8200\n$ vault kv put secret/password value=\"test_password\"\n$ vault kv get secret/passwordundefinedundefined$ spin build\n$ spin up --runtime-config-file runtime_config.tomlundefined$ curl -i http://127.0.0.1:3000\nHTTP/1.1 200 OK\ncontent-length: 26\ndate: Tue, 18 Oct 2022 12:34:40 GMT\n\nGot password test_password","keywords":"","subsectionKeywords":"","url":"/v1/dynamic-configuration#vault-application-variable-provider-example"},{"project":"v1","title":"Dynamic and Runtime Application Configuration","subheading":"Key Value Store Runtime Configuration","content":"Spin provides built-in key-value storage. This storage is backed by an SQLite database embedded in Spin by default. However, the Spin runtime configuration file (runtime-config.toml) can be updated to not only modify the SQLite configuration but also choose to use a different backing store. The available store options are the embedded SQLite database, an external Redis database or Azure CosmosDB.","keywords":"","subsectionKeywords":"","url":"/v1/dynamic-configuration#key-value-store-runtime-configuration"},{"project":"v1","title":"Dynamic and Runtime Application Configuration","subheading":"Redis Key Value Store Provider","content":"The following is an example of how an application's runtime-config.toml file can be configured to use Redis instead. Note the type and url values, which are set to redis and the URL of the Redis host, respectively:[key_value_store.default]\ntype = \"redis\"\nurl = \"redis://localhost\"","keywords":"","subsectionKeywords":"","url":"/v1/dynamic-configuration#redis-key-value-store-provider"},{"project":"v1","title":"Dynamic and Runtime Application Configuration","subheading":"Azure CosmosDB Key Value Store Provider","content":"Similarly, to implement Azure CosmosDB as a backend for Spin's key/value store, change the type to azure_cosmos and specify your database account details:[key_value_store.default]\ntype = \"azure_cosmos\"\nkey = \"<key>\"\naccount = \"<cosmos-account>\"\ndatabase = \"<cosmos-database>\"\ncontainer = \"<cosmos-container>\"undefinedWhilst a single default store may be sufficient for certain application use cases, each Spin application can be configured to support multiple stores of any type, as shown in the runtime-config.toml file below:# This defines a new store named user_data\n[key_value_store.user_data]\ntype = \"spin\" \npath = \".spin/user_data.db\"\n\n# This defines a new store named other_data backed by a Redis database\n[key_value_store.other_data]\ntype = \"redis\"\nurl = \"redis://localhost\"You must individually grant each component access to the stores that it needs to use. To do this, use the component.key_value_stores entry in the component manifest within spin.toml. See undefined for more details.","keywords":"","subsectionKeywords":"","url":"/v1/dynamic-configuration#azure-cosmosdb-key-value-store-provider"},{"project":"v1","title":"Dynamic and Runtime Application Configuration","subheading":"SQLite Storage Runtime Configuration","content":"Spin provides built-in SQLite storage. By default, this is backed by a database that Spin creates for you underneath your application directory (in the .spin subdirectory). However, you can use the Spin runtime configuration file (runtime-config.toml) to add and customize SQLite databases.The following example runtime-config.toml tells Spin to map the default database to an SQLite database elsewhere in the file system:[sqlite_database.default]\npath = \"/planning/todo.db\"If you need more than one database, you can configure multiple databases, each with its own name:# This defines a new store named todo\n[sqlite_database.todo]\npath = \"/planning/todo.db\"\n\n# This defines a new store named finance\n[sqlite_database.finance]\npath = \"/super/secret/monies.db\"Spin creates any database files that don't exist.  However, it is up to you to delete them when you no longer need them.","keywords":"","subsectionKeywords":"","url":"/v1/dynamic-configuration#sqlite-storage-runtime-configuration"},{"project":"v1","title":"Dynamic and Runtime Application Configuration","subheading":"LibSQL Storage Provider","content":"Spin can also use undefined databases accessed over HTTPS.  libSQL is fully compatible with SQLite but provides additional features including remote, distributed databases.undefinedTo use libSQL, set type = \"libsql\" in your runtime-config.toml entry.  You must then provide a url and authentication token instead of a file path.  For example, this entry tells Spin to map the default database to a libSQL service running on libsql.example.com:# This tells Spin to use the remote host as its default database\n[sqlite_database.default]\ntype = \"libsql\"\nurl = \"https://sensational-penguin-ahacker.libsql.example.com\"\ntoken = \"a secret\"Spin does undefined create libSQL databases.  Use your hosting service's tools to create them (or sqld if you are self-hosting) .  You can still set up tables and data in a libSQL database via spin up --sqlite.undefinedThe default database will still be defined, even if you add other databases.By default, components will not have access to any of these databases (even the default one). You must grant each component access to the databases that it needs to use. To do this, use the component.sqlite_databases entry in the component manifest within spin.toml. See undefined for more details.","keywords":"","subsectionKeywords":"","url":"/v1/dynamic-configuration#libsql-storage-provider"},{"project":"v1","title":"Dynamic and Runtime Application Configuration","subheading":"LLM Runtime Configuration","content":"Spin provides a Large Language Model interface for interacting with LLMs for inferencing and embedding. The default host implementation is to use local CPU/GPU compute. However, the Spin runtime configuration file (runtime-config.toml) can be updated to enable Spin to use remote compute using HTTP requests.","keywords":"","subsectionKeywords":"","url":"/v1/dynamic-configuration#llm-runtime-configuration"},{"project":"v1","title":"Dynamic and Runtime Application Configuration","subheading":"Remote Compute Provider","content":"The following is an example of how an application's runtime-config.toml file can be configured to use the remote compute option. Note the type, url and auth_token are set to remote_http, URL of the server and the auth token for the server.[llm_compute]\ntype = \"remote_http\"\nurl = \"http://example.com\"\nauth_token = \"<auth_token>\"Currently, the remote compute option requires a user to deploy their own LLM proxy service. On Fermyon Cloud, users can do this using the undefined.  If you prefer to create and deploy your own proxy service, you can find a reference implementation of the proxy protocol in the undefined.By default, components will not have access to the LLM models unless granted explicit access through the component.ai_models entry in the component manifest within spin.toml. See undefined for more details.","keywords":"","subsectionKeywords":"","url":"/v1/dynamic-configuration#remote-compute-provider"},{"project":"v1","title":"Extending and Embedding Spin","subheading":"","content":"undefinedundefinedSpin currently implements triggers and application models for:undefinedundefinedThe Spin internals and execution context (the part of Spin executing\ncomponents) are agnostic of the event source and application model.\nIn this document, we will explore how to extend Spin with custom event sources\n(triggers) and application models built on top of the WebAssembly component\nmodel, as well as how to embed Spin in your application.In this article, we will build a Spin trigger to run the applications based on a\ntimer, executing Spin components at a configured time interval.The current application types that can be implemented with Spin have entry points\ndefined using\nundefined:// The entry point for an HTTP handler.\nhandle-http-request: function(req: request) -> response\n\n// The entry point for a Redis handler.\nhandle-redis-message: function(msg: payload) -> expected<_, error>The entry point we want to execute for our timer trigger takes a string as its\nonly argument (the trigger will populate that with the current date and time),\nand it expects a string as the only return value. This is purposefully chosen\nto be a simple function signature:// examples/spin-timer/spin-timer.wit\nhandle-timer-request: function(msg: string) -> stringThis is the function that all components executed by the timer trigger must\nimplement, and which is used by the timer executor when instantiating and\ninvoking the component.Let's have a look at building the timer trigger:// examples/spin-timer/src/main.rs\nwit_bindgen_wasmtime::import!({paths: [\"spin-timer.wit\"], async: *});\ntype ExecutionContext = spin_engine::ExecutionContext<spin_timer::SpinTimerData>;\n\n/// A custom timer trigger that executes a component on every interval.\n#[derive(Clone)]\npub struct TimerTrigger {\n    /// The interval at which the component is executed.\n    pub interval: Duration,\n    /// The Spin execution context.\n    engine: Arc<ExecutionContext>,\n}A few important things to note from the start:undefinedundefinedundefinedFinally, whenever there is a new event (in the case of our timer-based trigger\nevery n seconds), we execute the entry point of a selected component:/// Execute the first component in the application manifest.\nasync fn handle(&self, msg: String) -> Result<()> {\n    // create a new Wasmtime store and instance based on the first component's WebAssembly module.\n    let (mut store, instance) =\n        self.engine\n            .prepare_component(&self.app.components[0].id, None, None, None, None)?;\n\n    // spawn a new thread and call the entry point function from the WebAssembly module \n    let res = spawn_blocking(move || -> Result<String> {\n            // use the auto-generated WIT bindings to get the Wasm exports and call the `handle-timer-request` function.\n        let t = spin_timer::SpinTimer::new(&mut store, &instance, |host| {\n            host.data.as_mut().unwrap()\n        })?;\n        Ok(t.handle_timer_request(&mut store, &msg)?)\n    })\n    .await??;\n    // do something with the result.\n    log::info!(\"{}\\n\", res);\n    Ok(())\n}A few notes:undefinedundefinedundefinedThis is very similar to how the undefined and undefined\ntriggers are implemented, and it is the recommended way to extend Spin with your\nown trigger and application model.Writing components for the new trigger can be done by using the\nundefined from\nRust and other supported languages (see undefined):// automatically generate Rust bindings that help us implement the \n// `handle-timer-request` function that the trigger will execute.\nwit_bindgen_rust::export!(\"../spin-timer.wit\");\n...\nfn handle_timer_request(msg: String) -> String {\n    format!(\"ECHO: {}\", msg)\n}Components can be compiled to WebAssembly, then used from a spin.toml\napplication manifest.Embedding the new trigger in a Rust application is done by creating a new trigger\ninstance, then calling its run function:// app() is a utility function that generates a complete application configuration.\nlet trigger = TimerTrigger::new(Duration::from_secs(1), app()).await?;\n// run the trigger indefinitely\ntrigger.run().awaitundefinedIn this example, we built a simple timer trigger — building more complex triggers\nwould also involve updating the Spin application manifest, and extending\nthe application-level trigger configuration, as well as component-level\ntrigger configuration (an example of component-level trigger configuration\nfor this scenario would be each component being able to define its own\nindependent time interval for scheduling the execution).","subsectionKeywords":"","url":"/v1/extending-and-embedding"},{"project":"v1","title":"Extending and Embedding Spin","subheading":"Other Ways to Extend and Use Spin","content":"Besides building custom triggers, the internals of Spin could also be used independently:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/extending-and-embedding#other-ways-to-extend-and-use-spin"},{"project":"v1","title":"Building Spin components in Go","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v1/go-components"},{"project":"v1","title":"Building Spin components in Go","subheading":"Versions","content":"TinyGo 0.29.0 is recommended, which requires Go v1.18+ or newer.undefined","keywords":"","subsectionKeywords":"","url":"/v1/go-components#versions"},{"project":"v1","title":"Building Spin components in Go","subheading":"HTTP Components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, and Go has improved support for\nwriting applications, through its SDK.Building a Spin HTTP component using the Go SDK means writing a single function,\ninit — below is a complete implementation for such a component:// A Spin component written in Go that returns \"Hello, Spin!\"\npackage main\n\nimport (\n \"fmt\"\n \"net/http\"\n\n spinhttp \"github.com/fermyon/spin/sdk/go/http\"\n)\n\nfunc init() {\n spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n  w.Header().Set(\"Content-Type\", \"text/plain\")\n  fmt.Fprintln(w, \"Hello Spin!\")\n })\n}\n\nfunc main() {}The important things to note in the implementation above:undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/go-components#http-components"},{"project":"v1","title":"Building Spin components in Go","subheading":"Sending Outbound HTTP Requests","content":"If allowed, Spin components can send outbound requests to HTTP endpoints. Let's\nsee an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:// A Spin component written in Go that sends a request to an API\n// with random animal facts.\n\npackage main\n\nimport (\n \"fmt\"\n \"net/http\"\n \"os\"\n\n spinhttp \"github.com/fermyon/spin/sdk/go/http\"\n)\n\nfunc init() {\n spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n    resp, _ := spinhttp.Get(\"https://random-data-api.fermyon.app/animals/json\")\n\n  fmt.Fprintln(w, resp.Body)\n  fmt.Fprintln(w, resp.Header.Get(\"content-type\"))\n\n  // `spin.toml` is not configured to allow outbound HTTP requests to this host,\n  // so this request will fail.\n  if _, err := spinhttp.Get(\"https://fermyon.com\"); err != nil {\n   fmt.Fprintf(os.Stderr, \"Cannot send HTTP request: %v\", err)\n  }\n })\n}\n\nfunc main() {}The component can be built using the tingygo toolchain:$ tinygo build -wasm-abi=generic -target=wasi -no-debug -o main.wasm main.goBefore we can execute this component, we need to add the\nrandom-data-api.fermyon.app domain to the application manifest allowed_http_hosts\nlist containing the list of domains the component is allowed to make HTTP\nrequests to:# spin.toml\nspin_manifest_version = \"1\"\nname = \"spin-hello-tinygo\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"tinygo-hello\"\nsource = \"main.wasm\"\nallowed_http_hosts = [ \"random-data-api.fermyon.app\" ]\n[component.trigger]\nroute = \"/hello\"undefinedRunning the application using spin up --file spin.toml will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /hello:$ curl -i localhost:3000/hello\nHTTP/1.1 200 OK\ncontent-type: text/plain; charset=utf-8\nserver: spin/0.1.0\ncontent-length: 85\ndate: Fri, 18 Mar 2022 23:27:33 GMT\n\n{\"timestamp\":1684299253331,\"fact\":\"Reindeer grow new antlers every year\"}undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/go-components#sending-outbound-http-requests"},{"project":"v1","title":"Building Spin components in Go","subheading":"Redis Components","content":"Besides the HTTP trigger, Spin has built-in support for a Redis trigger, which\nwill connect to a Redis instance and will execute components for new messages\non the configured channels.undefinedWriting a Redis component in Go also takes advantage of the SDK:package main\n\nimport (\n \"fmt\"\n\n \"github.com/fermyon/spin/sdk/go/redis\"\n)\n\nfunc init() {\n // redis.Handle() must be called in the init() function.\n redis.Handle(func(payload []byte) error {\n  fmt.Println(\"Payload::::\")\n  fmt.Println(string(payload))\n  return nil\n })\n}\n\n// main function must be included for the compiler but is not executed.\nfunc main() {}The manifest for a Redis application must contain the address of the Redis instance:spin_manifest_version = \"1\"\nname = \"spin-redis\"\ntrigger = { type = \"redis\", address = \"redis://localhost:6379\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"echo-message\"\nsource = \"main.wasm\"\n[component.trigger]\nchannel = \"messages\"\n[component.build]\ncommand = \"tinygo build -wasm-abi=generic -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"The application will connect to redis://localhost:6379, and for every new message\non the messages channel, the echo-message component will be executed:# first, start redis-server on the default port 6379\n$ redis-server --port 6379\n# then, start the Spin application\n$ spin build --up\nINFO spin_redis_engine: Connecting to Redis server at redis://localhost:6379\nINFO spin_redis_engine: Subscribed component 0 (echo-message) to channel: messagesFor every new message on the messages channel:$ redis-cli\n127.0.0.1:6379> publish messages \"Hello, there!\"Spin will instantiate and execute the component:INFO spin_redis_engine: Received message on channel \"messages\"\nPayload::::\nHello, there!","keywords":"","subsectionKeywords":"","url":"/v1/go-components#redis-components"},{"project":"v1","title":"Building Spin components in Go","subheading":"Storing Data in Redis From Go Components","content":"Using the Spin's Go SDK, you can use the Redis key/value store to publish\nmessages to Redis channels. This can be used from both HTTP and Redis triggered\ncomponents.Let's see how we can use the Go SDK to connect to Redis:package main\n\nimport (\n \"net/http\"\n \"os\"\n\n spin_http \"github.com/fermyon/spin/sdk/go/http\"\n \"github.com/fermyon/spin/sdk/go/redis\"\n)\n\nfunc init() {\n // handler for the http trigger\n spin_http.Handle(func(w http.ResponseWriter, r *http.Request) {\n\n  // addr is the environment variable set in `spin.toml` that points to the\n  // address of the Redis server.\n  addr := os.Getenv(\"REDIS_ADDRESS\")\n\n  // channel is the environment variable set in `spin.toml` that specifies\n  // the Redis channel that the component will publish to.\n  channel := os.Getenv(\"REDIS_CHANNEL\")\n\n  // payload is the data publish to the redis channel.\n  payload := []byte(`Hello redis from tinygo!`)\n\n  if err := redis.Publish(addr, channel, payload); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n   return\n  }\n\n  // set redis `mykey` = `myvalue`\n  if err := redis.Set(addr, \"mykey\", []byte(\"myvalue\")); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n   return\n  }\n\n  // get redis payload for `mykey`\n  if payload, err := redis.Get(addr, \"mykey\"); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n  } else {\n   w.Write([]byte(\"mykey value was: \"))\n   w.Write(payload)\n  }\n })\n}\n\nfunc main() {}This HTTP component demonstrates fetching a value from Redis by key, setting a\nkey with a value, and publishing a message to a Redis channel. The component is\ntriggered by an HTTP request served on the route configured in the spin.toml:[[component]]\nenvironment = { REDIS_ADDRESS = \"redis://127.0.0.1:6379\", REDIS_CHANNEL = \"messages\" }\n[component.trigger]\nroute = \"/publish\"This HTTP component can be paired with a Redis component, triggered on new\nmessages on the messages Redis channel.undefined","keywords":"","subsectionKeywords":"","url":"/v1/go-components#storing-data-in-redis-from-go-components"},{"project":"v1","title":"Building Spin components in Go","subheading":"Using Go Packages in Spin Components","content":"Any\nundefined that can be imported in TinyGo and that compiles to\nWASI can be used when implementing a Spin component.undefined","keywords":"","subsectionKeywords":"","url":"/v1/go-components#using-go-packages-in-spin-components"},{"project":"v1","title":"Building Spin components in Go","subheading":"Storing Data in the Spin Key-Value Store","content":"Spin has a key-value store built in. For information about using it from TinyGo, see undefined.","keywords":"","subsectionKeywords":"","url":"/v1/go-components#storing-data-in-the-spin-key-value-store"},{"project":"v1","title":"Building Spin components in Go","subheading":"Storing Data in SQLite","content":"For more information about using SQLite from TinyGo, see undefined.","keywords":"","subsectionKeywords":"","url":"/v1/go-components#storing-data-in-sqlite"},{"project":"v1","title":"Making HTTP Requests","subheading":"","content":"undefinedundefinedSpin provides an interface for you to make outgoing HTTP requests.{{ details \"Why do I need a Spin interface? Why can't I just use my language's HTTP library?\" \"The current version of the WebAssembly System Interface (WASI) doesn't provide a sockets interface, so HTTP libraries can't be built to Wasm. The Spin interface means Wasm modules can bypass this limitation by asking Spin to perform the HTTP request on their behalf.\" }}","subsectionKeywords":"","url":"/v1/http-outbound"},{"project":"v1","title":"Making HTTP Requests","subheading":"Using HTTP From Applications","content":"The Spin SDK surfaces the Spin HTTP interface to your language. The interface contains only one operation:| Operation  | Parameters | Returns | Behavior |\n|------------|------------|---------|----------|\n| request  | request record | response record   | Sends the given HTTP request, and returns the response. |The request record specifies:| Field      | Type     | Meaning          |\n|------------|----------|------------------|\n| method   | enum     | The HTTP method for the request, e.g. GET, POST, DELETE, etc. |\n| uri      | string   | The URI to which to make the request |\n| headers  | list of key-value string pairs | The request headers |\n| body     | bytes    | Optional request body |undefinedThe response record contains:| Field      | Type     | Meaning          |\n|------------|----------|------------------|\n| status   | integer  | The HTTP status code of the response, e.g. 200, 404, etc. |\n| headers  | list of key-value string pairs | The response headers, if any |\n| body     | bytes    | The response body, if any |The exact detail of calling the request operation from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}HTTP functions are available in the spin_sdk::outbound_http module. The function is named send_request. It takes a spin_sdk::http::Request and returns a spin_sdk::http::Response. Both of these types are specializations of the Request and Response types from the http crate, and have all their behaviour and methods; the Spin SDK maps them to the underlying Wasm interface. For example:use spin_sdk::http::{Request, Response};\n\nlet request = http::Request::builder()\n    .method(\"POST\")\n    .uri(\"https://example.com/users\")\n    .body(Some(json_text.into()))?;\n\nlet response = spin_sdk::outbound_http::send_request(request)?;\nprintln!(\"Status: {}\", response.status().as_str());undefinedundefinedundefinedYou can find a complete example for using outbound HTTP in the undefined.{{ blockEnd }}{{ startTab \"TypeScript\"}}HTTP operations are available via the standard JavaScript fetch function. The Spin runtime maps this to the underlying Wasm interface. For example:const response = await fetch(\"https://example.com/users\");undefinedundefinedYou can find a complete example of using outbound HTTP in the JavaScript SDK repository on GitHub (undefined, undefined).{{ blockEnd }}{{ startTab \"Python\"}}HTTP functions and classes are available in the spin_http module. The function name is http_send. The request type is Request, and the response type is Response. For example:from spin_http import Request, Response, http_send\n\nresponse = http_send(\n    Request(\"GET\", \"https://random-data-api.fermyon.app/animals/json\", {}, None))undefinedundefinedundefinedundefinedundefinedYou can find a complete example for using outbound HTTP in the undefined.{{ blockEnd }}{{ startTab \"TinyGo\"}}HTTP functions are available in the github.com/fermyon/spin/sdk/go/http package. undefined. The general function is named Send, but the Go SDK also surfaces individual functions, with request-specific parameters, for the Get and Post operations. For example:import (\n\tspinhttp \"github.com/fermyon/spin/sdk/go/http\"\n)\n\nres1, err1 := spinhttp.Get(\"https://random-data-api.fermyon.app/animals/json\")\nres2, err2 := spinhttp.Post(\"https://example.com/users\", \"application/json\", json)\n\nrequest, err := http.NewRequest(\"PUT\", \"https://example.com/users/1\", bytes.NewBufferString(user1))\nrequest.Header.Add(\"content-type\", \"application/json\")\nres3, err3 := spinhttp.Send(req)\nundefinedundefinedundefinedundefinedYou can find a complete example for using outbound HTTP in the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/http-outbound#using-http-from-applications"},{"project":"v1","title":"Making HTTP Requests","subheading":"Granting HTTP Permissions to Components","content":"By default, Spin components are not allowed to make outgoing HTTP requests. This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing. To grant a component permission to make HTTP requests to a particular host, use the allowed_http_hosts field in the component manifest:[component]\nallowed_http_hosts = [ \"random-data-api.fermyon.app\", \"api.example.com:8080\" ]The Wasm module can make HTTP requests undefined to the specified hosts. If a port is specified, the module can make requests only to that port; otherwise, the module can make requests only on the default HTTP and HTTPS ports. Requests to other hosts (or ports) will fail with an error.For development-time convenience, you can also pass the string \"insecure:allow-all\" in the allowed_http_hosts collection. This allows the Wasm module to make HTTP requests to undefined host and on any port. However, once you've determined which hosts your code needs, you should remove this string and list the hosts instead.  Other Spin implementations may restrict host access and disallow components that ask to connect to anything and everything!","keywords":"","subsectionKeywords":"","url":"/v1/http-outbound#granting-http-permissions-to-components"},{"project":"v1","title":"Making HTTP Requests","subheading":"Making HTTP Requests Within an Application","content":"In an HTTP component, you can use the special host self to make HTTP requests undefined. For example, if you make an outbound HTTP request to http://self/api/customers/, Spin replaces self with whatever host the application is running on. It also replaces the URL scheme (http or https) with the scheme of the current HTTP request. For example, if the application is running in the cloud, Spin changes http://self/api to https://.../api.Using self means that the application doesn't need to know the URL where it's deployed, or whether it's running locally versus in the cloud.undefinedYou must still grant permission by including self in allowed_http_hosts:allowed_http_hosts = [\"self\"]\n``","keywords":"","subsectionKeywords":"","url":"/v1/http-outbound#making-http-requests-within-an-application"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedHTTP applications are an important workload in event-driven environments,\nand Spin has built-in support for creating and running HTTP\ncomponents. This page covers Spin options that are specific to HTTP applications.The HTTP trigger in Spin is a web server. It listens for incoming requests and\nbased on the undefined, it routes them to a\ncomponent, which returns an HTTP response.","subsectionKeywords":"","url":"/v1/http-trigger"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"Specifying an Application as HTTP","content":"Every Spin application has a trigger specified in the manifest, which declares the type of events it responds to.\nFor HTTP applications, the application trigger has type = \"http\":# spin.toml\ntrigger = { type = \"http\", base = \"/\" }The HTTP trigger also requires a base field.  Spin interprets each component route as relative to this route.  In most cases, you can set this to \"/\", the base of the Web server, meaning Spin applies no prefix to component routes.undefinedIn addition, each component must have HTTP-specific configuration in its [component.trigger] table.","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#specifying-an-application-as-http"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"Mapping a Route to a Component","content":"Each component handles one route, specified in the route field of the component trigger table.The route may be undefined or undefined.An undefined route matches only the given route.  This is the default behavior.  For example, /cart matches only /cart, and not /cart/checkout:# Run the `cart.wasm` module when the application receives a request to `/cart`...\n[[component]]\nid = \"cart\"\nsource = \"cart.wasm\"\n[component.trigger]\nroute = \"/cart\"\n\n# ...and the `checkout.wasm` module for `/cart/checkout`\n[[component]]\nid = \"checkout\"\nsource = \"checkout.wasm\"\n[component.trigger]\nroute = \"/cart/checkout\"A undefined route matches the given route and any route under it.  A route is a wildcard if it ends in /....  For example, /users/... matches /users, /users/1, /users/1/edit, and so on.  Any of these routes will run the mapped component.undefined[[component]]\nid = \"user-manager\"\nsource = \"users.wasm\"\n# Run the `users.wasm` module when the application receives a request to `/users`\n# or any path beginning with `/users/`\n[component.trigger]\nroute = \"/users/...\"","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#mapping-a-route-to-a-component"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"Routing with an Application  base","content":"If the application base is \"/\" then all component routes are matched exactly as given.If base contains a non-root path, this is prefixed to all component routes,\nexact or wildcard.For example, suppose the application base path is base = \"/shop\".  Then a component with route = \"/cart\" will be executed for requests to /shop/cart.  Similarly, a component with route = \"/users/...\" will be executed for requests to /shop/users, /shop/users/1, /shop/users/1/edit and so on.","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#routing-with-an-application-base"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"Resolving Overlapping Routes","content":"If multiple components could potentially handle the same request based on their\ndefined routes, the component whose route has the longest matching prefix\ntakes precedence.  This also means that exact matches take precedence over wildcard matches.In the following example, requests starting with the  /users/ prefix (e.g. /users/1)\nwill be handled by user-manager, even though it is also matched by the shop route, because the /users prefix is longer than /.\nBut requests to /users/admin will be handled by the admin component, not user-manager, because that is a more exact match still:# spin.toml\n\ntrigger = { type = \"http\", base = \"/\"}\n\n[[component]]\nid = \"user-manager\"\n[component.trigger]\nroute = \"/users/...\"\n\n[[component]]\nid = \"admin\"\n[component.trigger]\nroute = \"/users/admin\"\n\n[[component]]\nid = \"shop\"\n[component.trigger]\nroute = \"/...\"","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#resolving-overlapping-routes"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"Health Check Route","content":"Every HTTP application automatically has a special route always configured at /.well-known/spin/health, which\nreturns OK 200 when the Spin instance is healthy.","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#health-check-route"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"HTTP Components","content":"undefinedBy default, Spin runs components using the undefined.  In this model, the Wasm module exports a well-known function that Spin calls to handle the HTTP request.","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#http-components"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"The Request Handler","content":"The exact signature of the HTTP handler, and how a function is identified to be exported as the handler, will depend on your language.{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}In Rust, the handler is identified by the #[spin_sdk::http_component] attribute.  It takes a spin_sdk::http::Request, and returns a spin_sdk::http::Response (or error).  These types are instantiations of the standard http::Request and http::Response types and behave exactly like them:use anyhow::Result;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n};\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn handle_hello_rust(req: Request) -> Result<Response> {\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(\"Hello, Spin\".into()))?)\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}In JavaScript or TypeScript, the handler is identified by name.  It must be called handleRequest.  The way you declare it is slightly different between the two languages.In undefined, handleRequest is declared as export async function.  It takes a JsvaScript object representing the request, and returns a response object.  The fields of these objects are exactly the same as in TypeScript:export async function handleRequest(request) {\n    return {\n        status: 200,\n        headers: { \"foo\": \"bar\" },\n        body: \"Hello from JS-SDK\"\n    }\n}In undefined, handleRequest is declared as an export const of the HandleRequest function type - that is, a function literal rather than a function declaration.  It takes a HttpRequest object, and returns a HttpResponse object, both defined in the @spinframework/spin-sdk package:import { HandleRequest, HttpRequest, HttpResponse} from \"@spinframework/spin-sdk\"\n\nexport const handleRequest: HandleRequest = async function(request: HttpRequest): Promise<HttpResponse> {\n    return {\n      status: 200,\n      headers: { \"foo\": \"bar\" },\n      body: \"Hello from TS-SDK\"\n    }\n}{{ blockEnd }}{{ startTab \"Python\"}}In Python, the handler is identified by name.  It must be called handle_request.  It takes a request object and must return an instance of Response, defined in the spin_http package:from spin_http import Response\n\ndef handle_request(request):\n    return Response(200,\n                    [(\"content-type\", \"text/plain\")],\n                    bytes(f\"Hello from the Python SDK\", \"utf-8\")){{ blockEnd }}{{ startTab \"TinyGo\"}}In Go, you register the handler as a callback in your program's init function.  Call spinhttp.Handle, passing your handler as the sole argument.  Your handler takes a http.Request record, from the standard net/http package, and a ResponseWriter to construct the response.undefinedpackage main\n\nimport (\n        \"fmt\"\n        \"net/http\"\n\n        spinhttp \"github.com/fermyon/spin/sdk/go/http\"\n)\n\nfunc init() {\n        spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n                w.Header().Set(\"Content-Type\", \"text/plain\")\n                fmt.Fprintln(w, \"Hello Spin!\")\n        })\n}\n\nfunc main() {}undefined{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#the-request-handler"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"The Request and Response Records","content":"Exactly how the Spin SDK surfaces the request and response types varies from language to language; this section calls out general features.undefined","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#the-request-and-response-records"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"Additional Request Information","content":"As well as any headers passed by the client, Spin sets several headers on the request passed to your component, which you can use to access additional information about the HTTP request.undefinedundefined| Header Name                  | Value                | Example |\n|------------------------------|----------------------|---------|\n| spin-full-url              | The full URL of the request. This includes full host and scheme information. | https://example.com:8080/shop/users/1/edit?theme=pink |\n| spin-path-info             | The request path relative to the component route (including any base) | /1/edit |\n| spin-matched-route         | The part of the request path that was matched by the route (including the base and wildcard indicator if present) | /shop/users/... |\n| spin-raw-component-route   | The component route pattern matched, as written in the component manifest (that is, undefined the base, but including the wildcard indicator if present) | /users/... |\n| spin-component-route       | The component route pattern matched, undefined any wildcard indicator | /users |\n| spin-base-path             | The application base path | /shop |\n| spin-client-addr           | The IP address and port of the client | 127.0.0.1:53152 |","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#additional-request-information"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"Inside HTTP Components","content":"For the most part, you'll build HTTP component modules using a language SDK (see the Language Guides section), such as a JavaScript module or a Rust crate.  If you're interested in what happens inside the SDK, or want to implement HTTP components in another language, read on!undefinedThe HTTP component interface is defined using a WebAssembly Interface (WIT) file.  (undefined).  You can find the latest WITs for Spin HTTP components at undefined.The core HTTP types are defined in undefined:// wit/ephemeral/http-types.wit\n\n// The HTTP status code.\ntype http-status = u16\n// The HTTP body.\ntype body = list<u8>\n// The HTTP headers represented as a list of (name, value) pairs.\ntype headers = list<tuple<string, string>>\n// The HTTP parameter queries, represented as a list of (name, value) pairs.\ntype params = list<tuple<string, string>>\n// The HTTP URI of the current request.\ntype uri = string\n// The HTTP method.\nenum method { get, post, put,... }\n\n// An HTTP request.\nrecord request {\n    method: method,\n    uri: uri,\n    headers: headers,\n    params: params, // Retained for binary compatibility but no longer used\n    body: option<body>,\n}\n\n// An HTTP response.\nrecord response {\n    status: http-status,\n    headers: option<headers>,\n    body: option<body>,\n}\n\n// error types omittedundefinedThe entry point for Spin HTTP components is then defined in undefined:// wit/ephemeral/spin-http.wit\n\nuse * from http-types\n\n// The entry point for an HTTP handler.\nhandle-http-request: function(req: request) -> responseThis is the function signature that all HTTP components must implement, and\nwhich is used by the Spin HTTP executor when instantiating and invoking the\ncomponent.This interface (spin-http.wit) can be directly used together with the\nundefined\nto build a component that the Spin HTTP executor can invoke.This is exactly how Spin SDKs, such as the undefined, undefined, undefined and undefined SDKs, are built.\nAs more languages add support for the component model, we plan to add support for them in the same way.undefined","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#inside-http-components"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"HTTP With Wagi (WebAssembly Gateway Interface)","content":"The WebAssembly component model proposal is currently in its early stages, which\nmeans only a few programming languages fully implement it. While the language\ncommunities implement toolchain support for the component model (for emitting\ncomponents and for automatically generating bindings for importing other\ncomponents), we want to allow developers to use any language that compiles to\nWASI to build Spin HTTP applications. This is why Spin currently implements an\nHTTP executor based on undefined, or the\nWebAssembly Gateway Interface, a project that implements the\nundefined\nspecification for WebAssembly.undefinedWagi allows a module built in any programming language that compiles to undefined\nto handle an HTTP request by passing the HTTP request information to the module's\nstandard input, environment variables, and arguments, and expecting the HTTP\nresponses through the module's standard output.\nThis means that if a language has support for the WebAssembly System Interface,\nit can be used to build Spin HTTP components.\nThe Wagi model is only used to parse the HTTP request and response. Everything\nelse — defining the application, running it, or undefined\nis done the same way as a component that uses the Spin executor.","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#http-with-wagi-webassembly-gateway-interface"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"Wagi Component Requirements","content":"Spin uses the component model by default, and cannot detect from the Wasm module alone whether it was built with component model support.  For Wagi components, therefore, you must tell Spin in the component manifest to run them using Wagi instead of 'default' Spin.  To do this, use the executor field in the [component.trigger] table:[[component]]\nid = \"wagi-test\"\nsource = \"wagitest.wasm\"\n[component.trigger]\nroute = \"/\"\nexecutor = { type = \"wagi\" }undefinedWagi supports non-default entry points, and allows you to pass an arguments string that a program can receive as if it had been passed on the command line. If you need these you can specify them in the executor table. For details, see the undefined.","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#wagi-component-requirements"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"Request Handling in Wagi","content":"Building a Wagi component in a particular programming language that can compile\nto wasm32-wasi does not require any special libraries — instead,\nundefined can\nbe done by reading the HTTP request from the standard input and environment\nvariables, and sending the HTTP response to the module's standard output.In pseudo-code, this is the minimum required in a Wagi component:undefinedundefinedundefinedprint(\"content-type: text/html; charset=UTF-8\\n\\n\");\nprint(\"hello world\\n\");Here is a working example, written in undefined,\na programming language that natively targets WebAssembly and WASI but\ndoes not yet support the component model:import Process from \"sys/process\";\nimport Array from \"array\";\n\nprint(\"content-type: text/plain\\n\");\n\n// This will print all the Wagi env variables\nprint(\"==== Environment: ====\");\nArray.forEach(print, Process.env());\n\n// This will print the route path followed by each query\n// param. So /foo?bar=baz will be [\"/foo\", \"bar=baz\"].\nprint(\"==== Args: ====\");\nArray.forEach(print, Process.argv());undefined","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#request-handling-in-wagi"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"Wagi HTTP Environment Variables","content":"Wagi passes request metadata to the program through well-known environment variables. The key path-related request variables are:undefinedundefinedundefinedundefinedundefinedundefinedFor details, and for a full list of all Wagi environment variables, see\nundefined.","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#wagi-http-environment-variables"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"Exposing HTTP Triggers Using HTTPS","content":"When exposing HTTP triggers using HTTPS you must provide spin up with a TLS certificate and a private key. This can be achieved by either using trigger options (--tls-cert and --tls-key) when running the spin up command, or by setting environment variables (SPIN_TLS_CERT and SPIN_TLS_KEY) before running the spin up command.","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#exposing-http-triggers-using-https"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"Trigger Options","content":"The spin up command's --tls-cert and --tls-key trigger options provide a way for you to specify both a TLS certificate and a private key (whilst running the spin up command).The --tls-cert option specifies the path to the TLS certificate to use for HTTPS, if this is not set, normal HTTP will be used. The certificate should be in PEM format.The --tls-key option specifies the path to the private key to use for HTTPS, if this is not set, normal HTTP will be used. The key should be in PKCS#8 format. For more information, please see the undefined.","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#trigger-options"},{"project":"v1","title":"The Spin HTTP Trigger","subheading":"Environment Variables","content":"The spin up command can also automatically use the SPIN_TLS_CERT and SPIN_TLS_KEY environment variables instead of the respective flags (--tls-cert and --tls-key):SPIN_TLS_CERT=<path/to/cert>\nSPIN_TLS_KEY=<path/to/key>Once set, spin up will automatically use these explicitly set environment variables. For example, if using a Linux-based system, you can go ahead and use the export command to set the variables in your session (before you run the spin up command):export SPIN_TLS_CERT=<path/to/cert>\nexport SPIN_TLS_KEY=<path/to/key>","keywords":"","subsectionKeywords":"","url":"/v1/http-trigger#environment-variables"},{"project":"v1","title":"Introducing Spin","subheading":"","content":"Spin is a framework and CLI for building and running event-driven microservice applications with WebAssembly (Wasm) components. Spin uses Wasm because it is undefined.  Millisecond cold start times mean no need to keep applications \"warm\".Many languages have Wasm implementations, so undefined. Spin is undefined and undefined, meaning you can take your Spin applications anywhere.  There are Spin implementations for local development, for self-hosted servers, for Kubernetes, and for cloud-hosted services.","subsectionKeywords":"","url":"/v1/index"},{"project":"v1","title":"Introducing Spin","subheading":"Starter Examples","content":"{{suh_cards}}\n{{card_element \"sample\" \"Checklist Sample App\" \"A checklist app that persists data in a key value store\" \"/hub/preview/sample_checklist\" \"Typescript,Http,Kv\" true }}\n{{card_element \"template\" \"Zola SSG Template\" \"A template for using Zola framework to create a static webpage\" \"/hub/preview/template_zola_ssg\" \"rust\" true }}\n{{card_element \"sample\" \"AI-assisted News Summarizer\" \"Read an RSS newsfeed and have AI summarize it for you\" \"/hub/preview/sample_newsreader_ai\" \"Typescript,Javascript,Ai\" true }}\n{{blockEnd}}Or dive into the documentation and get started:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/index#starter-examples"},{"project":"v1","title":"Install Spin","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefined","keywords":"install","subsectionKeywords":"","url":"/v1/install"},{"project":"v1","title":"Install Spin","subheading":"Installing Spin","content":"Spin runs on Linux (amd64 and arm64), macOS (Intel and Apple Silicon), and Windows (amd64):{{ tabs \"os\" }}{{ startTab \"Linux\"}}undefinedYou can manage your Spin installation via undefined. Homebrew automatically installs Spin templates and Spin plugins, and on uninstall, will prompt you to delete the directory where the templates and plugins were downloaded:Install the Fermyon tap, which Homebrew tracks, updates, and installs Spin from:$ brew tap fermyon/tapInstall Spin:$ brew install fermyon/tap/spinundefinedundefinedAnother option (other than brew) is to use our installer script. The installer script installs Spin along with a starter set of language templates and plugins:$ curl -fsSL https://spinframework.com/downloads/install.sh | bashOnce you have run the installer script, it is highly recommended to add Spin to a folder, which is on your path, e.g.:$ sudo mv spin /usr/local/bin/undefinedTo install a specific version, you can pass arguments to the install script this way:$ curl -fsSL https://spinframework.com/downloads/install.sh | bash -s -- -v v1.5.0To install the canary version of spin, you should pass the argument -v canary. The canary version is always the latest commit to the main branch of Spin:$ curl -fsSL https://spinframework.com/downloads/install.sh | bash -s -- -v canary{{ blockEnd }}{{ startTab \"macOS\"}}undefinedYou can manage your Spin installation via undefined. Homebrew automatically installs Spin templates and Spin plugins, and on uninstall, will prompt you to delete the directory where the templates and plugins were downloaded:Install the Fermyon tap, which Homebrew tracks, updates, and installs Spin from:$ brew tap fermyon/tapInstall Spin:$ brew install fermyon/tap/spinundefinedundefinedAnother option (other than brew) is to use our installer script. The installer script installs Spin along with a starter set of language templates and plugins:The installer script also installs Spin along with a starter set of language templates and plugins:$ curl -fsSL https://spinframework.com/downloads/install.sh | bashOnce you have run the installer script, it is highly recommended to add Spin to a folder, which is on your path, e.g.:$ sudo mv spin /usr/local/bin/undefinedTo install a specific version, you can pass arguments to the install script this way:$ curl -fsSL https://spinframework.com/downloads/install.sh | bash -s -- -v v0.10.0To install the canary version of spin, you should pass the argument -v canary. The canary version is always the latest commit to the main branch of Spin:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v canary{{ blockEnd }}{{ startTab \"Windows\"}}If using Windows (PowerShell / cmd.exe), you can download <a href=\"https://github.com/spinframework/spin/releases/latest\" class=\"spin-install\" id=\"spin-install-windows\">the Windows binary release of Spin</a>.Simply unzip the binary release and place the spin.exe in your system path.This does not install any Spin templates or plugins. For a starter list, see the undefined.If you want to use WSL2 (Windows Subsystem for Linux 2), please follow the instructions for using Linux.{{ blockEnd }}\n{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/install#installing-spin"},{"project":"v1","title":"Install Spin","subheading":"Verifying the Release Signature","content":"The Spin project undefined using undefined, a project that helps with signing software and undefined. Consumers of Spin releases can validate the integrity of the package they downloaded by performing a validation of the artifact against the signature present in the public log. Specifically, users get two main guarantees by verifying the signature: 1) that the author of the artifact is indeed the one expected (i.e. the build infrastructure associated with the Spin project, at a given revision that can be inspected), and 2) that the content generated by the build infrastructure has not been tampered with.To verify the release signature, first undefined. This is the CLI tool that we will use validate the signature.\nThe same directory where the installation script was run should also contain a signature of the Spin binary and the certificate used to perform the signature. The following command will perform the signature verification using the cosign CLI:$ cosign verify-blob \\\n    --signature spin.sig \\\n    --certificate crt.pem \\\n    --certificate-identity https://github.com/spinframework/spin/.github/workflows/release.yml@refs/tags/<version> \\\n    --certificate-oidc-issuer https://token.actions.githubusercontent.com \\\n    # --certificate-github-workflow-sha <optionally, pass the commit SHA associated with the tag> \\\n    ./spin\nVerified OKYou can now move the Spin binary to the path knowing that it was indeed built by the infrastructure associated with the Spin project, and that it has not been tampered with since the build.","keywords":"","subsectionKeywords":"","url":"/v1/install#verifying-the-release-signature"},{"project":"v1","title":"Install Spin","subheading":"Building Spin From Source","content":"undefined for a detailed guide on building Spin from source:$ git clone https://github.com/spinframework/spin\n$ cd spin && make build\n$ ./target/release/spin --helpundefined$ sudo apt-get install build-essential libssl-dev pkg-configThis does not install any Spin templates or plugins. For a starter list, see the undefined.","keywords":"","subsectionKeywords":"","url":"/v1/install#building-spin-from-source"},{"project":"v1","title":"Install Spin","subheading":"Using Cargo to Install Spin","content":"If you have undefined, you can clone the repo and install it to your path:$ git clone https://github.com/spinframework/spin -b v1.4.1\n$ cd spin\n$ rustup target add wasm32-wasi\n$ rustup target add wasm32-unknown-unknown\n$ cargo install --locked --path .\n$ spin --helpundefined$ rustup updateThis does not install any Spin templates or plugins. For a starter list, see the undefined.","keywords":"","subsectionKeywords":"","url":"/v1/install#using-cargo-to-install-spin"},{"project":"v1","title":"Install Spin","subheading":"Installing Templates and Plugins","content":"Spin has a variety of templates and plugins to make it easier to create Spin applications in your favorite programming language. undefined automatically installs a starter set of templates and plugins, namely templates from the Spin repository and JavaScript and Python toolchain plugins and deployment plugins.If you used a different installation method, we recommend you install these templates and plugins manually, as follows.","keywords":"","subsectionKeywords":"","url":"/v1/install#installing-templates-and-plugins"},{"project":"v1","title":"Install Spin","subheading":"Templates","content":"Spin:$ spin templates install --git https://github.com/spinframework/spin --upgradeSpin Python SDK$ spin templates install --git https://github.com/spinframework/spin-python-sdk --upgradeSpin JS SDK:$ spin templates install --git https://github.com/spinframework/spin-js-sdk --upgradeTo list installed templates, run:$ spin templates listFor more information please read the undefined section of the documentation.","keywords":"","subsectionKeywords":"","url":"/v1/install#templates"},{"project":"v1","title":"Install Spin","subheading":"Plugins","content":"First update the local cache by running the spin plugins update command:$ spin plugins updateThen install plugins by name.Python:$ spin plugins install py2wasm --yesJavascript:$ spin plugins install js2wasm --yesTo list installed and available plugins, run:$ spin plugins listFor more information, please visit the undefined section of the documentation.","keywords":"","subsectionKeywords":"","url":"/v1/install#plugins"},{"project":"v1","title":"Install Spin","subheading":"Next Steps","content":"{{suh_cards}}\n{{card_element \"sample\" \"Checklist Sample App\" \"A checklist app that persists data in a key value store\" \"/hub/preview/sample_checklist\" \"Typescript,Http,Kv\" true }}\n{{card_element \"sample\" \"AI-assisted News Summarizer\" \"Read an RSS newsfeed and have AI summarize it for you\" \"/hub/preview/sample_newsreader_ai\" \"Typescript,Javascript,Ai\" true }}\n{{blockEnd}","keywords":"","subsectionKeywords":"","url":"/v1/install#next-steps"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedWith JavaScript being a very popular language, Spin provides support for building components with it using the experimental SDK. The development of the JavaScript SDK is continually being worked on to improve user experience and add features.undefinedundefinedundefinedIn order to compile JavaScript programs to Spin components, you also need to install a Spin plugin js2wasm using the following command:$ spin plugin update\n$ spin plugin install js2wasm","subsectionKeywords":"","url":"/v1/javascript-components"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"Installing Templates","content":"The JavaScript/TypeScript templates can be installed from undefined using the following command:$ spin templates install --git https://github.com/spinframework/spin-js-sdk --updatewhich will install the http-js and http-ts templates:Copying remote template source\nInstalling template http-ts...\nInstalling template http-js...\nInstalled 2 template(s)\n\n+-------------------------------------------------+\n| Name      Description                           |\n+=================================================+\n| http-js   HTTP request handler using Javascript |\n| http-ts   HTTP request handler using Typescript |\n+-------------------------------------------------+","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#installing-templates"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"Structure of a JS/TS Component","content":"A new JS/TS component can be created using the following command:$ spin new http-ts hello-world --accept-defaultsThis creates a directory of the following structure:hello-world/\n├── package.json\n├── package-lock.json\n├── README.md\n├── spin.toml\n├── src\n│   └── index.ts\n├── tsconfig.json\n└── webpack.config.jsThe source for the component is present in src/index.ts. undefined is used to bundle the component into a single .js file which will then be compiled to a .wasm module using the js2wasm plugin.","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#structure-of-a-jsts-component"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"Building and Running the Template","content":"First, the dependencies for the template need to be installed and then bundled into a single JavaScript file using the following commands:$ cd hello-world\n$ npm install\n$ npm run buildOnce a Spin compatible module is created, it can be run using:$ spin up","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#building-and-running-the-template"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"A Quick Note About NPM Scripts","content":"Please note that using pre-built NPM scripts can have different effects on different Operating Systems (OSs). Let's take the npm run build command (like undefined) as an example:\"scripts\": {\n    \"build\": \"npx webpack --mode=production && mkdir -p target && spin js2wasm -o target/spin-http-js.wasm dist/spin.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  }The npm run build command will work on Linux and macOS. However, on Windows it will create both a -p directory and a target directory.On Linux/Unix systems, the -p option in the mkdir command is designed to prevent an error from occuring in the event that the target directory already exists. However, on Windows systems, npm (by default) uses cmd.exe which does not recognize the -p option, regarding its mkdir command.If you run npm run build on Windows (more than once) the following error will be encountered:A subdirectory or file -p already exists\nA Subdirectory or file target already existsIf any errors, as described above, occur please consider one of the two following options:a) Configure your instance of npm to use bash (by using the script-shell configuration setting):$ npm config set script-shell \"C:\\\\Program Files\\\\git\\\\bin\\\\bash.exe\"b) Run the separate parts of the build manually, to suite your needs (OS syntax requirements):$ npx webpack --mode=production\n$ spin js2wasm -o target/spin-http-js.wasm dist/spin.js","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#a-quick-note-about-npm-scripts"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"HTTP Components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, and Javascript/TypeScript has improved support\nfor writing Spin components with the Spin JS/TS SDK.undefinedBuilding a Spin HTTP component using the JS/TS SDK means writing a single function\nthat takes an HTTP request as a parameter, and returns an HTTP response — below\nis a complete implementation for such a component in TypeScript:import { HandleRequest, HttpRequest, HttpResponse } from \"@fermyon/spin-sdk\"\n\nconst encoder = new TextEncoder()\n\nexport const handleRequest: HandleRequest = async function (request: HttpRequest): Promise<HttpResponse> {\n\n    return {\n        status: 200,\n        headers: {\"foo\": \"bar\"},\n        body: encoder.encode(\"Hello from JS-SDK\").buffer\n    }\n}The important things to note in the implementation above:undefinedundefinedPlease note: If you need to decode a request body (which is either an ArrayBuffer or ArrayBufferView) into plain text or JSON please consider using the following:// Create new TextDecoder instance\nlet decoder = new TextDecoder()\n\n// Then decode request body to text\nlet text = decoder.decode(request.body)\n\n// Or decode request body to JSON\nlet text = JSON.parse(decoder.decode(request.body))","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#http-components"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"Sending Outbound HTTP Requests","content":"If allowed, Spin components can send outbound HTTP requests.\nLet's see an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:const encoder = new TextEncoder(\"utf-8\")\nconst decoder = new TextDecoder(\"utf-8\")\n\nexport async function handleRequest(request) {\n    const animalFact = await fetch(\"https://random-data-api.fermyon.app/animals/json\")\n\n    const animalFactBody = decoder.decode(await animalFact.arrayBuffer() || new Uint8Array())\n\n    const body = `Here's an animal fact: ${animalFactBody}\\n`\n\n    return {\n        status: 200,\n        headers: { \"foo\": \"bar\" },\n        body: encoder.encode(body).buffer\n    }\n}Before we can execute this component, we need to add the random-data-api.fermyon.app\ndomain to the application manifest allowed_http_hosts list containing the list of\ndomains the component is allowed to make HTTP requests to:# spin.toml\nspin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\nname = \"spin-http-js\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[variables]\nobject = { default = \"teapot\" }\n\n[[component]]\nid = \"hello\"\nsource = \"target/spin-http-js.wasm\"\nallowed_http_hosts = [\"random-data-api.fermyon.app\"]\n[component.trigger]\nroute = \"/hello\"\n[component.build]\ncommand = \"npm run build\"The component can be built using the spin build command. Running the application using spin up --file spin.toml will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /hello:$ curl -i localhost:3000/hello\nHTTP/1.1 200 OK\ndate: Fri, 18 Mar 2022 03:54:36 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 185\nserver: spin/0.1.0\n\nHere's an animal fact: {\"timestamp\":1684299253331,\"fact\":\"Reindeer grow new antlers every year\"}undefinedundefinedWe just built a WebAssembly component that sends an HTTP request to another\nservice, manipulates that result, then responds to the original request.\nThis can be the basis for building components that communicate with external\ndatabases or storage accounts, or even more specialized components like HTTP\nproxies or URL shorteners.","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#sending-outbound-http-requests"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"Storing Data in Redis From JS/TS Components","content":"undefinedUsing the Spin's JS SDK, you can use the Redis key/value store and to publish messages to Redis channels.Let's see how we can use the JS/TS SDK to connect to Redis:import { HandleRequest, HttpRequest, HttpResponse, Redis } from \"@fermyon/spin-sdk\"\n\nconst encoder = new TextEncoder()\nconst decoder = new TextDecoder()\n\nconst redisAddress = \"redis://localhost:6379/\"\n\nexport const handleRequest: HandleRequest = async function (request: HttpRequest): Promise<HttpResponse> {\n\n    Redis.incr(redisAddress, \"test\")\n    Redis.incr(redisAddress, \"test\")\n\n    console.log(decoder.decode(Redis.get(redisAddress, \"test\")))\n\n    Redis.set(redisAddress, \"test-set\", encoder.encode(\"This is a test\").buffer)\n\n    console.log(decoder.decode(Redis.get(redisAddress, \"test-set\")))\n\n    Redis.publish(redisAddress, \"test\", encoder.encode(\"This is a test\").buffer)\n\n    return {\n        status: 200,\n        headers: {\"foo\": \"bar\"},\n        body: encoder.encode(\"Hello from JS-SDK\").buffer\n    }\n}This HTTP component demonstrates fetching a value from Redis by key, setting a key with a value, and publishing a message to a Redis channel. The component is triggered by an HTTP request served on the route configured in the spin.toml:undefined","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#storing-data-in-redis-from-jsts-components"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"Routing in a Component","content":"The JavaScript/TypeScript SDK provides a router that makes it easier to handle routing within a component. The router is based on undefined. An additional function handleRequest has been implemented in the router to allow passing in the Spin HTTP request directly. For a more complete documentation on the route, checkout the documentationa at undefined. An example usage of the router is given below:import { HandleRequest, HttpRequest, HttpResponse, Router} from \"@fermyon/spin-sdk\"\n\nlet router = Router()\n\nfunction handleDefaultRoute() {\n  return {\n    status: 200,\n      headers: { \"content-type\": \"text/html\" },\n    body: \"Hello from Default Route\"\n  }\n}\n\nfunction handleHomeRoute(id: string) {\n  return {\n    status: 200,\n      headers: { \"content-type\": \"text/html\" },\n    body: \"Hello from Home Route with id:\" + id\n  }\n}\n\nrouter.get(\"/\", handleDefaultRoute)\nrouter.get(\"/home/:id\", ({params}) => handleHomeRoute(params.id))\n\nexport const handleRequest: HandleRequest = async function(request: HttpRequest): Promise<HttpResponse> {\n    return await router.handleRequest(request)\n}","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#routing-in-a-component"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"Storing Data in the Spin Key-Value Store","content":"Spin has a key-value store built in. For information about using it from TypeScript/JavaScript, see undefined.","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#storing-data-in-the-spin-key-value-store"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"Storing Data in SQLite","content":"For more information about using SQLite from TypeScript/Javascript, see undefined.","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#storing-data-in-sqlite"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"Storing Data in MySQL and PostgreSQL Relational Databases","content":"For more information about using relational databases from TypeScript/JavaScript, see undefined.","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#storing-data-in-mysql-and-postgresql-relational-databases"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"AI Inferencing From JS/TS Components","content":"For more information about using Serverless AI from JS/TS, see the undefined API guide.","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#ai-inferencing-from-jsts-components"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"Using External NPM Libraries","content":"undefinedSome NPM packages can be installed and used in the component. If a popular library does not work, please open an issue/feature request in the undefined.","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#using-external-npm-libraries"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"Suggested Libraries for Common Tasks","content":"These are some of the suggested libraries that have been tested and confired to work with the SDK for common tasks.{{ details \"HTML parsers\" \"- undefined\" }}{{ details \"Parsing formdata\" \"- undefined\" }}{{ details \"Runtime schema validation\" \"- undefined\" }}{{ details \"Unique ID generator\" \"- undefined\\n- undefined\\n- undefined\" }}","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#suggested-libraries-for-common-tasks"},{"project":"v1","title":"Building Spin Components in JavaScript","subheading":"Caveats","content":"undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/javascript-components#caveats"},{"project":"v1","title":"Spin Key-Value Store","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v1/key-value-store-tutorial"},{"project":"v1","title":"Spin Key-Value Store","subheading":"Key Value Store With Spin Applications","content":"Spin applications are best suited for event-driven, stateless workloads that have low-latency requirements. Keeping track of the application's state (storing information) is an integral part of any useful product or service. For example, users (and the business) will expect to store and load data/information at all times during an application’s execution. undefined has support for applications that need data in the form of key/value pairs and are satisfied by a Basically Available, Soft State, and Eventually Consistent (BASE) model. Workload examples include general value caching, session caching, counters, and serialized application state. In this tutorial, you will learn how to do the following:undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/key-value-store-tutorial#key-value-store-with-spin-applications"},{"project":"v1","title":"Spin Key-Value Store","subheading":"Tutorial Prerequisites","content":"First, follow undefined to install Spin. To ensure you have the correct version, you can check with this command:$ spin --versionundefined","keywords":"","subsectionKeywords":"","url":"/v1/key-value-store-tutorial#tutorial-prerequisites"},{"project":"v1","title":"Spin Key-Value Store","subheading":"Creating a New Spin Application","content":"Let's create a Spin application that will send and retreive data from a key value store. To make things easy, we'll start from a template using the following commands (undefined):{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}$ spin new http-rust spin-key-value\n\n# Reference: https://github.com/spinframework/spin-rust-sdk/tree/stable/examples/rust-key-value{{ blockEnd }}{{ startTab \"TypeScript\" }}$ spin new http-ts spin-key-value\n\n# Reference: https://github.com/spinframework/spin-js-sdk/tree/stable/examples/typescript/spin_kv{{ blockEnd }}{{ startTab \"TinyGo\" }}$ spin new http-go spin-key-value\n\n# Reference: https://github.com/spinframework/spin-go-sdk/tree/stable/examples/key-value{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/key-value-store-tutorial#creating-a-new-spin-application"},{"project":"v1","title":"Spin Key-Value Store","subheading":"Configuration","content":"Good news - Spin will take care of setting up your key value store. However, in order to make sure your Spin application has permission to access the key value store, you must add the key_value_stores = [\"default\"] line in the [[component]] area of the spin.toml file. This line is necessary to communicate to Spin that a given component has access to the default key value store. A newly scaffolded Spin application will not have this line; you will need to add it.undefinedEach Spin application's key_value_stores instances are implemented on a per-component basis across the entire Spin application. This means that within a multi-component Spin application (which has the same key_value_stores = [\"default\"] configuration line), each [[component]] will access that same data store. If one of your application's components creates a new key/value pair, another one of your application's components can update/overwrite that initial key/value after the fact.","keywords":"","subsectionKeywords":"","url":"/v1/key-value-store-tutorial#configuration"},{"project":"v1","title":"Spin Key-Value Store","subheading":"The Spin TOML File","content":"We will give our components access to the key value store by adding the key_value_stores = [\"default\"] in the [[component manifest]] as shown below:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"A simple application that exercises key-value storage.\"\nname = \"spin-key-value\"\ntrigger = { type = \"http\", base = \"/test\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"spin-key-value\"\nsource = \"target/wasm32-wasi/release/spin-key-value.wasm\"\nallowed_http_hosts = []\n# Gives this component access to the default key value store\nkey_value_stores = [\"default\"]\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"{{ blockEnd }}{{ startTab \"TypeScript\" }}spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"A simple application that exercises key-value storage.\"\nname = \"spin-key-value\"\ntrigger = { type = \"http\", base = \"/test\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"spin-key-value\"\nsource = \"target/spin-key-value.wasm\"\nexclude_files = [\"**/node_modules\"]\n# Gives this component access to the default key value store\nkey_value_stores = [\"default\"]\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"npm run build\"{{ blockEnd }}{{ startTab \"TinyGo\" }}spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"A simple application that exercises key-value storage.\"\nname = \"spin-key-value\"\ntrigger = { type = \"http\", base = \"/test\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"spin-key-value\"\nsource = \"main.wasm\"\n# Gives this component access to the default key value store\nkey_value_stores = [\"default\"]\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/key-value-store-tutorial#the-spin-toml-file"},{"project":"v1","title":"Spin Key-Value Store","subheading":"Write Code to Save and Load Data","content":"In this section, we use the Spin SDK to open and persist our application's data inside our default key/value store. This is a special store that every environment running Spin applications will make available for their application.undefined","keywords":"","subsectionKeywords":"","url":"/v1/key-value-store-tutorial#write-code-to-save-and-load-data"},{"project":"v1","title":"Spin Key-Value Store","subheading":"The Spin SDK Version","content":"If you have an existing application and would like to try out the key/value feature, please check the Spin SDK reference in your existing application's configuration. For example, if using Rust please check your application's Cargo.toml file. If it refers to version 0.8 or earlier then update the Spin SDK reference to match your upgraded version of Spin:# The Spin SDK.\nspin-sdk = { git = \"https://github.com/spinframework/spin\", tag = \"v0.10.0\" }Similarly an application created using the http-go template might need the reference to the Spin SDK in its go.mod file updated to look like the following:module github.com/http_go\n\ngo 1.17\n\nrequire github.com/fermyon/spin/sdk/go v0.10.0The same applies to other programming languages and their respective configuration. This information is provided to prevent you from experiencing an error such as the following:unresolved import spin_sdk::key_value\nkey_value::{Error, Store}\n^^^^^^^^^ could not find `key_value` in `spin_sdk`","keywords":"","subsectionKeywords":"","url":"/v1/key-value-store-tutorial#the-spin-sdk-version"},{"project":"v1","title":"Spin Key-Value Store","subheading":"Quick Overview - Video","content":"Before we get into the source code, let's watch a quick overview of the new key/value store feature.","keywords":"","subsectionKeywords":"","url":"/v1/key-value-store-tutorial#quick-overview---video"},{"project":"v1","title":"Spin Key-Value Store","subheading":"Source Code","content":"Now let's use the Spin SDK to:undefinedundefinedundefinedundefinedundefined{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}use anyhow::Result;\nuse http::{Method, StatusCode};\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n    key_value::{Error, Store},\n};\n\n#[http_component]\nfn handle_request(req: Request) -> Result<Response> {\n    // Open the default key-value store\n    let store = Store::open_default()?;\n\n    let (status, body) = match req.method() {\n        &Method::POST => {\n            // Add the request (URI, body) tuple to the store\n            store.set(req.uri().path(), req.body().as_deref().unwrap_or(&[]))?;\n            (StatusCode::OK, None)\n        }\n        &Method::GET => {\n            // Get the value associated with the request URI, or return a 404 if it's not present\n            match store.get(req.uri().path()) {\n                Ok(value) => (StatusCode::OK, Some(value.into())),\n                Err(Error::NoSuchKey) => (StatusCode::NOT_FOUND, None),\n                Err(error) => return Err(error.into()),\n            }\n        }\n        &Method::DELETE => {\n            // Delete the value associated with the request URI, if present\n            store.delete(req.uri().path())?;\n            (StatusCode::OK, None)\n        }\n        &Method::HEAD => {\n            // Like GET, except do not return the value\n            match store.exists(req.uri().path()) {\n                Ok(true) => (StatusCode::OK, None),\n                Ok(false) => (StatusCode::NOT_FOUND, None),\n                Err(error) => return Err(error.into()),\n            }\n        }\n        // No other methods are currently supported\n        _ => (StatusCode::METHOD_NOT_ALLOWED, None),\n    };\n\n    Ok(http::Response::builder().status(status).body(body)?)\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}import { HandleRequest, HttpRequest, HttpResponse, Kv } from \"@fermyon/spin-sdk\"\n\nconst encoder = new TextEncoder()\nconst decoder = new TextDecoder()\n\nexport const handleRequest: HandleRequest = async function (request: HttpRequest): Promise<HttpResponse> {\n\n  let store = Kv.openDefault()\n  let status = 200\n  let body\n\n  switch (request.method) {\n    case \"POST\":\n      store.set(request.uri, request.body || (new Uint8Array()).buffer)\n      break;\n    case \"GET\":\n      let val\n      try {\n        val = store.get(request.uri)\n        body = decoder.decode(val)\n      } catch (error) {\n        status = 404\n      }\n      break;\n    case \"DELETE\":\n      store.delete(request.uri)\n      break;\n    case \"HEAD\":\n      if (!store.exists(request.uri)) {\n        status = 404\n      }\n      break;\n    default:\n  }\n\n  return {\n    status: status,\n    body: body\n  }\n}{{ blockEnd }}{{ startTab \"TinyGo\" }}package main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\n\tspin_http \"github.com/fermyon/spin/sdk/go/http\"\n\t\"github.com/fermyon/spin/sdk/go/key_value\"\n)\n\nfunc init() {\n\t// handler for the http trigger\n\tspin_http.Handle(func(w http.ResponseWriter, r *http.Request) {\n\t\tstore, err := key_value.Open(\"default\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer key_value.Close(store)\n\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tswitch r.Method {\n\t\tcase http.MethodPost:\n\t\t\terr := key_value.Set(store, r.URL.Path, body)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\tcase http.MethodGet:\n\t\t\tvalue, err := key_value.Get(store, r.URL.Path)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tw.Write(value)\n\t\tcase http.MethodDelete:\n\t\t\terr := key_value.Delete(store, r.URL.Path)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\tcase http.MethodHead:\n\t\t\texists, err := key_value.Exists(store, r.URL.Path)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif exists {\n\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\tdefault:\n\t\t\thttp.Error(w, \"method not allowed\", http.StatusMethodNotAllowed)\n\t\t}\n\t})\n}\n\nfunc main() {}{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/key-value-store-tutorial#source-code"},{"project":"v1","title":"Spin Key-Value Store","subheading":"Building and Deploying Your Spin Application","content":"Now let's build and deploy our Spin Application locally. Run the following command to build your application:$ spin build","keywords":"","subsectionKeywords":"","url":"/v1/key-value-store-tutorial#building-and-deploying-your-spin-application"},{"project":"v1","title":"Spin Key-Value Store","subheading":"Storing and Retrieving Data From Your Default Key/Value Store","content":"Once you have completed this minimal configuration and deployed your application, data will be persisted across requests. Let's begin by creating a POST request that stores a JSON key/value object:# Create a new POST request and set the key/value pair of foo:bar\n$ curl -X POST localhost:3000/test -H 'Content-Type: application/json' -d '{\"foo\":\"bar\"}' -v\n\nTrying 127.0.0.1:3000...\nConnected to localhost (127.0.0.1) port 3000\nPOST /test HTTP/1.1\nHost: localhost:3000\nContent-Type: application/json\nHTTP/1.1 200 OKWe can now use a HEAD request to confirm that our component is holding data for us. Essentially, all we want to see here is a 200 OK response when calling our components endpoint (/test). Let's give it a try:$ curl -I HEAD localhost:3000/test -v                                                     \n\nTrying 127.0.0.1:3000...\n* Connected to localhost (127.0.0.1) port 3000\nHEAD /test HTTP/1.1\nHost: localhost:3000\nHTTP/1.1 200 OKPerfect, 200 OK. Now, let's create a GET request that fetches the data from our component:# Create a GET request and fetch the key/value that we stored in the previous request\n$ curl -X GET localhost:3000/test -v\n\nTrying 127.0.0.1:3000...\nConnected to localhost (127.0.0.1) port 3000\nGET /test HTTP/1.1\nHost: localhost:3000\nHTTP/1.1 200 OK\n{\n    \"foo\": \"bar\"\n}Great!, the above command successfully returned our data as intended:{\n    \"foo\": \"bar\"\n}Lastly, we show how to create a DELETE request that removes the data for this specific component altogether:$ curl -X DELETE localhost:3000/test -v\n\nTrying 127.0.0.1:3000...\nConnected to localhost (127.0.0.1) port 3000\nDELETE /test HTTP/1.1\nHost: localhost:3000\nHTTP/1.1 200 OKNote how all of the above commands returned 200 OK responses. In these examples, we were able to POST, HEAD (check to see if data exists), GET and also DELETE data from our component.Interestingly there is one more request we can re-run before wrapping up this tutorial. If no data exists in the component's endpoint of /test (which is technically the case now that we have sent the DELETE request) the HEAD request should correctly return 404 Not Found. You can consider this a type of litmus test; let's try it out:$ curl -I HEAD localhost:3000/test -v\n\nTrying 127.0.0.1:3000...\nConnected to localhost (127.0.0.1) port 3000\nHEAD /test HTTP/1.1\nHost: localhost:3000\nHTTP/1.1 404 Not FoundAs we can see above, there is currently no data found at the /test endpoint of our application.","keywords":"","subsectionKeywords":"","url":"/v1/key-value-store-tutorial#storing-and-retrieving-data-from-your-default-keyvalue-store"},{"project":"v1","title":"Spin Key-Value Store","subheading":"Conclusion","content":"We want to get feedback on the ergonomics of the key value API. We are curious about what new APIs you would suggest we implement and are also interested in learning about what backing stores you would like to see.","keywords":"","subsectionKeywords":"","url":"/v1/key-value-store-tutorial#conclusion"},{"project":"v1","title":"Spin Key-Value Store","subheading":"Next Steps","content":"You can read the undefined as well as the implementation for the undefined. Please feel free to ask questions and also share your thoughts in undefined.","keywords":"","subsectionKeywords":"","url":"/v1/key-value-store-tutorial#next-steps"},{"project":"v1","title":"Spin on Kubernetes","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v1/kubernetes"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Why Use Spin With Kubernetes?","content":"In addition to spin up Fermyon also offers Fermyon Cloud to deploy spin apps into production, so why use Spin with Kubernetes? For users that have made existing investments into Kubernetes or have requirements that their applications stay within certain clouds, not be on shared infrastructure, or run on-premise, Kubernetes provides a robust solution.undefined","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#why-use-spin-with-kubernetes"},{"project":"v1","title":"Spin on Kubernetes","subheading":"How Does It Work?","content":"For Kubernetes to run Spin workloads, it needs to be taught about a new runtime class. To do this, there is a shim for containerd. This compiles to a binary that must be placed on the Kubernetes nodes that host Shim pods. That binary then needs to be registered with Kubernetes as a new RuntimeClass. After that, wasm containers can be deployed to Kubernetes using the Spin k8s plugin.","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#how-does-it-work"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Next Steps","content":"undefinedundefined{{ tabs \"platforms\" }}{{ startTab \"Azure AKS\"}}","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#next-steps"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Setup Azure AKS for Spin","content":"","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#setup-azure-aks-for-spin"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Introduction","content":"Azure AKS provides a straightforward and officially undefined way to use Spin with AKS.","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#introduction"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Known Limitations","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#known-limitations"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Note for Rust","content":"In Cargo.toml, the spin-sdk dependency should be downgraded to v1.0.0-rc.1 in order to match the lower version running on the AKS shim.","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#note-for-rust"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Setup","content":"To get spin working on an AKS cluster, a few setup steps are required. First Add the aks-preview extension:$ az extension add --name aks-previewNext update to the latest version:$ az extension update --name aks-previewRegister the WasmNodePoolPreview feature:$ az feature register --namespace \"Microsoft.ContainerService\" --name \"WasmNodePoolPreview\"This will take a few minutes to complete. You can verify it’s done when this command returns undefined:$ az feature show --namespace \"Microsoft.ContainerService\" --name \"WasmNodePoolPreview\"Finally refresh the registration of the ContainerService:$ az provider register --namespace Microsoft.ContainerServiceOnce the service is registered, the next step is to add a Wasm/WASI nodepool to an existing AKS cluster. If a cluster doesn’t already exist, follow Azure’s undefined to create a new cluster:$ az aks nodepool add \\\n    --resource-group myResourceGroup \\\n    --cluster-name myAKSCluster \\\n    --name mywasipool \\\n    --node-count 1 \\\n    --node-vm-size Standard_B2s \\\n    --workload-runtime WasmWasiYou can verify the workloadRuntime using the following command:$ az aks nodepool show -g myResourceGroup --cluster-name myAKSCluster -n mywasipool --query workloadRuntimeThe next set of commands uses kubectl to create the necessary runtimeClass. If you don’t already have kubectl configured with the appropriate credentials, you can retrieve them with this command:$ az aks get-credentials -n myAKSCluster -g myResourceGroupFind the name of the nodepool:$ kubectl get nodes -o wideThen retrieve detailed information on the appropriate nodepool and verify among it’s labels is “kubernetes.azure.com/wasmtime-spin-v1=true”:kubectl describe node aks-mywasipool-12456878-vmss000000Find the wasmtime-spin-v1 RuntimeClass created by AKS:$ kubectl describe runtimeclass wasmtime-spin-v1{{ blockEnd }}{{ startTab \"Docker Desktop\"}}","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#setup"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Setup Docker Desktop for Spin","content":"","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#setup-docker-desktop-for-spin"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Introduction","content":"Docker Desktop provides both undefined directly and its own Kubernetes option.","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#introduction"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Known Limitations","content":"undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#known-limitations"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Setup","content":"Install approproiate Preview Version of Docker Desktop+Wasm Technical Preview 2 from undefined. Then undefined for Docker in Settings → Experimental → Use containerd for pulling and storing images.Next Enable Kubernetes under Settings → Experimental → Enable Kubernetes, then hit “Apply & Restart”.Create a file wasm-runtimeclass.yml and populate with the following information:apiVersion: node.k8s.io/v1\nkind: RuntimeClass\nmetadata:\n  name: \"wasmtime-spin-v1\"\nhandler: \"spin\"Then register the runtime class with the cluster:$ kubectl apply -f wasm-runtimeclass.yaml","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#setup"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Using Docker Desktop With Spin","content":"Docker Desktop can be used with spin as a Kubernetes target per the instructions in the below in this document. However Docker can also run the containers directly with the following command:$ docker run --runtime=io.containerd.spin.v1 --platform=wasi/wasm -p <port>:<port> <image>:<version>If there is not command specified in the Dockerfile, one will need to be passed at the command line. Since Spin doesn't need this, \"/\" can be passed.{{ blockEnd }}{{ startTab \"K3d\"}}","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#using-docker-desktop-with-spin"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Setup K8s for Spin","content":"","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#setup-k8s-for-spin"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Introduction","content":"undefined is a lightweight Kubernetes installation.","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#introduction"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Known Limitations","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#known-limitations"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Setup","content":"Ensure both Docker and k3d are installed. Then undefined for Docker in Settings → Experimental → Use containerd for pulling and storing images.Deis Labs provides a preconfigured K3d environment that can be run using this command:$ k3d cluster create wasm-cluster --image ghcr.io/deislabs/containerd-wasm-shims/examples/k3d:v0.8.0 -p \"8081:80@loadbalancer\" --agents 2 --registry-create mycluster-registry:12345Create a file wasm-runtimeclass.yml and populate with the following information:apiVersion: node.k8s.io/v1\nkind: RuntimeClass\nmetadata:\n  name: \"wasmtime-spin-v1\"\nhandler: \"spin\"Then register the runtime class with the cluster:$ kubectl apply -f wasm-runtimeclass.yaml{{ blockEnd }}{{ startTab \"Generic Kubernetes\"}}","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#setup"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Setup Generic Kubernetes for Spin","content":"","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#setup-generic-kubernetes-for-spin"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Introduction","content":"These instructions are provided for a self-managed or other Kubernetes service that isn't documented elsewhere.","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#introduction"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Known Limitations","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#known-limitations"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Setup","content":"We provide the undefined Helm chart that provides an automated method to install and configure the containerd shim for Fermyon Spin in Kubernetes. Please see the undefined in the installer repository for more information.The version of the container image and Helm chart directly correlates to the version of the containerd shim. We recommend selecting the shim version that correlates the version of Spin that you use for your application(s). For simplicity, here is a table depicting the version matrix between Spin and the containerd shim.| undefined              | undefined |\n| ------------------------------------------------------------- | ------------------------------------------------------------------------------------- |\n| undefined | undefined       |\n| undefined | undefined       |\n| undefined | undefined       |\n| undefined | undefined       |There are several values you may need to configure based on your Kubernetes environment. The installer needs to add a binary to the node's PATH and edit containerd's config.toml. The defaults we set are the same defaults for containerd and should work for most Kubernetes environments but you may need to adjust them if your distribution uses non-default paths.| Name                            | Default           | Description                                                              |\n| ------------------------------- | ----------------- | ------------------------------------------------------------------------ |\n| installer.hostEtcContainerdPath | /etc/containerd | Directory where containerd's config.toml is located                      |\n| installer.hostBinPath           | /usr/local/bin  | Directory where the shim binary should be installed to (must be on PATH) |undefined$ helm install fermyon-spin oci://ghcr.io/fermyon/charts/spin-containerd-shim-installer --version 0.8.0{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#setup"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Run a Spin Workload on Kubernetes","content":"","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#run-a-spin-workload-on-kubernetes"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Introduction","content":"This guide demonstrates the commands to run a Spin workload in Kubernetes. It should apply to all Kubernetes varients which have been properly configured using one of the Setup guides.","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#introduction"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Concepts","content":"Spin apps are bundled using the OCI format. These packages include the spin.toml file, and the wasm and static files which it references. While Kubernetes also uses OCI repositories, it expects the package to be in a container format.The containerd shim for Spin allows Kubernetes to appropriately schedule Spin applications as long as they have been wrapped in a lightweight “scratch” container.Once the Spin App Container has been created, it can be pushed to an OCI repository, and then deployed to an appropriately configured kubernetes cluster.","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#concepts"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Requirements","content":"The current Spin k8s plugin relies on Docker and Kubectl under the hood. It’s important that both of these tools be installed, the Docker service be running, and KUBECONFIG environment variable be configured to point to a kubeconfig file for the desired Kubernetes cluster.","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#requirements"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Install Plugin","content":"To install this plugin, simply run:spin plugin install -u https://raw.githubusercontent.com/chrismatteson/spin-plugin-k8s/main/k8s.json","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#install-plugin"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Workflow","content":"The workflow is very similar to the workflow for Fermyon Cloud.The k8s plugin handles all of the tasks necessary to build the docker container, push it to a repository and deploy it into production.Just like with Fermyon Cloud, when something changes with the application, the workflow is to iterate the version in the spin.toml file, and restart the sequence from spin build.","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#workflow"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Detailed Explanation of Steps","content":"","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#detailed-explanation-of-steps"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Spin New","content":"An optional command to use a template to create a new Spin App:$ spin new","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#spin-new"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Spin Build","content":"The following command builds a spin app:spin build","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#spin-build"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Spin K8s Scaffold","content":"The following command creates two files necessary for a Spin app to run on Kubernetes. A Dockerfile and deploy.yaml. Scaffold takes in a namespace as a mandatory argument. This can either be a username if using the Docker hub, or can be the entire address if using a separate repository such as ghcr:spin k8s scaffoldAn example Dockerfile is below. The only things which end up in the final image are wasm and other files mentioned as sources in the spin.toml.DockerfileFROM scratch\nCOPY ./spin.toml .\nCOPY ./target/wasm32-wasi/release/test.wasm ./target/wasm32-wasi/release/test.wasm\nCOPY ./spin_static_fs.wasm ./spin_static_fs.wasm\nCOPY ./static ./staticThe deploy.yaml file defines the deployment to the Kubernetes server. By default the replicas is configured as 3, however this can be edited after the scaffolding stage and before the deployment stage. Additionally, the runtimeClassName is defined as wasmtime-spin-v1. It’s critical that that is the exact name used when setting up the Kubernetes service to support Spin, or that the deployment be edited to the appropriate name.deploy.yamlapiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: test\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: test\n  template:\n    metadata:\n      labels:\n        app: test\n    spec:\n      runtimeClassName: wasmtime-spin-v1\n      containers:\n        - name: test\n          image: chrismatteson/test:0.1.5\n          command: [\"/\"]\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: test\n  spec:\n    type: LoadBalancer\n    ports:\n      - protocol: TCP\n        port: 80\n        targetPort: 80\n    selector:\n      app: test\n---\napiVersion: [networking.k8s.io/v1](http://networking.k8s.io/v1)\nkind: Ingress\nmetadata:\n  name: test\n  annotations:\n    [ingress.kubernetes.io/ssl-redirect:](http://ingress.kubernetes.io/ssl-redirect:) \"false\"\n    [kubernetes.io/ingress.class:](http://kubernetes.io/ingress.class:) traefik\nspec:\n  rules:\n    - http:\n        paths:\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: test\n                port:\n                  number: 80","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#spin-k8s-scaffold"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Spin K8s Build","content":"The following command uses the Dockerfile to locally build a Spin Docker Container. The container is tagged as latest and with the version from the spin.toml:$ spin k8s build","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#spin-k8s-build"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Spin K8s Push","content":"The following command pushes the Dockerfile to the appropriate repository:$ spin k8s push","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#spin-k8s-push"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Spin K8s Deploy","content":"The following command deploys the application to Kubernetes:$ spin k8s deploy","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#spin-k8s-deploy"},{"project":"v1","title":"Spin on Kubernetes","subheading":"Spin K8s Getsvc","content":"The following command retrieves information about the service that gets deployed (such as it’s external IP):$ spin k8s getsvc\n``","keywords":"","subsectionKeywords":"","url":"/v1/kubernetes#spin-k8s-getsvc"},{"project":"v1","title":"Key Value Store","subheading":"","content":"undefinedundefinedundefinedSpin provides an interface for you to persist data in a key value store managed by Spin. This key value store allows Spin developers to persist non-relational data across application invocations. To learn more about key value store use cases and how to enable your Spin application to use a key value store, check out our undefined.{{ details \"Why do I need a Spin interface? Why can't I just use my own external store?\" \"You can absolutely still use your own external store either with the Redis or Postgres APIs, or outbound HTTP. However, if you're interested in quick, non-relational local storage without any infrastructure set-up then Spin's key value store is a great option.\" }}","subsectionKeywords":"","url":"/v1/kv-store-api-guide"},{"project":"v1","title":"Key Value Store","subheading":"Using Key Value Store From Applications","content":"The Spin SDK surfaces the Spin key value store interface to your language. The following characteristics are true of keys and values:undefinedundefinedundefinedThe set of operations is common across all SDKs:| Operation  | Parameters | Returns | Behavior |\n|------------|------------|---------|----------|\n| open  | name | store  | Open the store with the specified name. If name is the string \"default\", the default store is opened, provided that the component that was granted access in the component manifest from spin.toml. Otherwise, name must refer to a store defined and configured in a undefined supplied with the application.|\n| get | store, key | value | Get the value associated with the specified key from the specified store. |\n| set | store, key, value | - | Set the value associated with the specified key in the specified store, overwriting any existing value. |\n| delete | store, key | - | Delete the tuple with the specified key from the specified store. error::invalid-store will be raised if store is not a valid handle to an open store.  No error is raised if a tuple did not previously exist for key.|\n| exists | store, key | boolean | Return whether a tuple exists for the specified key in the specified store.|\n| get-keys | store | list<keys> | Return a list of all the keys in the specified store. |\n| close | store | - | Close the specified store. |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}Key value functions are available in the spin_sdk::key_value module. The function names match the operations above. For example:use anyhow::Result;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n    key_value::{Store},\n};\n#[http_component]\nfn handle_request(_req: Request) -> Result<Response> {\n    let store = Store::open_default()?;\n    store.set(\"mykey\", \"myvalue\")?;\n    let value = store.get(\"mykey\")?;\n    Ok(http::Response::builder().status(200).body(Some(value.into()))?)\n}undefinedset undefinedundefinedget undefinedundefinedopen undefinedundefinedset_json and get_json undefinedundefined{{ blockEnd }}{{ startTab \"Typescript\"}}With Typescript, the key value functions can be accessed after opening a store using either the Kv.open or the Kv.openDefault methods which returns a handle to the store. For example:import { HandleRequest, HttpRequest, HttpResponse, Kv } from \"@fermyon/spin-sdk\"\n\nexport const handleRequest: HandleRequest = async function (request: HttpRequest): Promise<HttpResponse> {\n    let store = Kv.openDefault()\n    store.set(\"mykey\", \"myvalue\")\n    return {\n            status: 200,\n            headers: {\"content-type\":\"text/plain\"},\n            body: store.get(\"mykey\") ?? encoder.encode(\"Key not found\")\n    }\n}\nundefinedundefinedget undefinedundefinedundefinedset undefinedundefinedsetJson and getJson undefinedundefined{{ blockEnd }}{{ startTab \"Python\"}}The key value functions are provided through the spin_key_value module in the Python SDK. For example:from spin_http import Response\nfrom spin_key_value import kv_open_default\n\n\ndef handle_request(request):\n\n    store = kv_open_default()\n    store.set(\"mykey\", \"myvalue\")\n    value = store.get()\n    //\n    return Response(status, [(\"content-type\", \"text/plain\")], value)   \nundefinedget undefinedundefined{{ blockEnd }}{{ startTab \"TinyGo\"}}Key value functions are provided by the github.com/fermyon/spin/sdk/go/key_value module. undefined. For example:import \"github.com/fermyon/spin/sdk/go/key_value\"\n\nfunc example() error {\n    store, err := key_value.Open(\"default\")\n    if err != nil {\n        return err\n    }\n    defer key_value.Close(store)\n    return key_value.Set(store, \"mykey\", []byte(\"myvalue\"))\n}\n{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/kv-store-api-guide#using-key-value-store-from-applications"},{"project":"v1","title":"Key Value Store","subheading":"Custom Key Value Stores","content":"Spin defines a key-value store named \"default\" and provides automatic backing storage.  If you need to customize Spin with additional stores, or to change the backing storage for the default store, you can do so via the --runtime-config-file flag and the runtime-config.toml file.  See undefined for details.","keywords":"","subsectionKeywords":"","url":"/v1/kv-store-api-guide#custom-key-value-stores"},{"project":"v1","title":"Key Value Store","subheading":"Granting Key Value Store Permissions to Components","content":"By default, a given component of an app will not have access to any key value store. Access must be granted specifically to each component via the component manifest:[component]\n# Pass in 1 or more key value stores, based on how many you'd like your component to have access to\nkey_value_stores = [\"<store 1>\", \"<store 2>\"]For example, a component could be given access to the default store using key_value_stores = [\"default\"].","keywords":"","subsectionKeywords":"","url":"/v1/kv-store-api-guide#granting-key-value-store-permissions-to-components"},{"project":"v1","title":"Language Support Overview","subheading":"","content":"This page contains information about language support for Spin features:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}| Feature | SDK Supported? |\n|-----|-----|\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| undefined | Supported |{{ blockEnd }}{{ startTab \"TypeScript\"}}| Feature | SDK Supported? |\n|-----|-----|\n| undefined |\n| undefined | Supported |\n| Redis | Not Supported |\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| MySQL | Not Supported |\n| PostgreSQL| Not Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| Authoring Custom Triggers | Not Supported |{{ blockEnd }}{{ startTab \"Python\"}}| Feature | SDK Supported? |\n|-----|-----|\n| undefined |\n| undefined | Supported |\n| Redis | Not Supported |\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| MySQL | Not Supported |\n| PostgreSQL | Not Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| Authoring Custom Triggers | Not Supported |{{ blockEnd }}{{ startTab \"TinyGo\"}}| Feature | SDK Supported? |\n|-----|-----|\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| MySQL | Not Supported |\n| PostgreSQL | Not Supported |\n| undefined | Supported |\n| Serverless AI | Not Supported |\n| undefined |\n| Authoring Custom Triggers | Not Supported |{{ blockEnd }}{{ startTab \"C#\"}}| Feature | SDK Supported? |\n|-----|-----|\n| undefined |\n| undefined | Supported |\n| Redis | Not Supported |\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| Key Value Storage | Not Supported |\n| SQLite Storage | Not supported |\n| MySQL | Not Supported |\n| undefined | Supported |\n| undefined | Supported |\n| Serverless AI | Not Supported |\n| undefined |\n| Authoring Custom Triggers | Not Supported |{{ blockEnd }}{{ blockEnd }}","subsectionKeywords":"","url":"/v1/language-support-overview"},{"project":"v1","title":"Managing Plugins","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedPlugins are a way to extend the functionality of Spin. Spin provides commands for installing and removing them, so you don't need to use separate installation tools. When you have installed a plugin into Spin, you can call it as if it were a Spin subcommand. For example, the JavaScript SDK uses a tool called js2wasm to package JavaScript code into a Wasm module, and JavaScript applications run it via the spin js2wasm command.","subsectionKeywords":"","url":"/v1/managing-plugins"},{"project":"v1","title":"Managing Plugins","subheading":"Installing Plugins","content":"To install plugins, use the spin plugins install command. You can install plugins by name from a curated repository, or other plugins from a URL or file system.","keywords":"","subsectionKeywords":"","url":"/v1/managing-plugins#installing-plugins"},{"project":"v1","title":"Managing Plugins","subheading":"Installing Well Known Plugins","content":"The Spin maintainers curate a catalogue of \"known\" plugins. You can install plugins from this catalogue by name:$ spin plugins install js2wasmSpin checks that the plugin is available for your version of Spin and your operating system, and prompts you to confirm the installation. To skip the prompt, pass the --yes flag.undefined","keywords":"","subsectionKeywords":"","url":"/v1/managing-plugins#installing-well-known-plugins"},{"project":"v1","title":"Managing Plugins","subheading":"Installing a Specific Version of a Plugin","content":"To install a specific version of a plugin, pass the --version flag:$ spin plugins install js2wasm --version 0.4.0","keywords":"","subsectionKeywords":"","url":"/v1/managing-plugins#installing-a-specific-version-of-a-plugin"},{"project":"v1","title":"Managing Plugins","subheading":"Installing a Plugin From a URL","content":"If the plugin you want has been published on the Web but has not been added to the catalogue, you can install it from its manifest URL. The manifest is the JSON document that links to the binaries for different operating systems and processors. For example:$ spin plugins install --url https://github.com/spinframework/spin-befunge-sdk/releases/download/v1.4.0/befunge2wasm.json","keywords":"","subsectionKeywords":"","url":"/v1/managing-plugins#installing-a-plugin-from-a-url"},{"project":"v1","title":"Managing Plugins","subheading":"Installing a Plugin From a File","content":"If the plugin you want is in your local file system, you can install it from its manifest file path. The manifest is the JSON document that links to the binaries for different operating systems and processors. For example:$ spin plugins install --file ~/dev/spin-befunge-sdk/befunge2wasm.json","keywords":"","subsectionKeywords":"","url":"/v1/managing-plugins#installing-a-plugin-from-a-file"},{"project":"v1","title":"Managing Plugins","subheading":"Running a Plugin","content":"You run plugins in the same way as built-in Spin subcommands. For example:$ spin js2wasm --help","keywords":"","subsectionKeywords":"","url":"/v1/managing-plugins#running-a-plugin"},{"project":"v1","title":"Managing Plugins","subheading":"Viewing Available Plugins","content":"To see what plugins are available in the catalogue, run spin plugins list:$ spin plugins list\nbefunge2wasm 1.4.0 [incompatible]\njs2wasm 0.3.0 [installed]\njs2wasm 0.4.0\npy2wasm 0.1.0 [installed]\ntrigger-sqs 0.1.0undefinedThe annotations by the plugins show their status and compatibility:| Annotation                      | Meaning |\n|---------------------------------|---------|\n| [incompatible]                | The plugin does not run on your operating system or processor. |\n| [installed]                   | You have the plugin already installed and available to run. |\n| [requires other Spin version] | The plugin can run on your operating system and processor, but is not compatible with the version of Spin you are running. The annotation indicates which versions of Spin it is compatible with. |","keywords":"","subsectionKeywords":"","url":"/v1/managing-plugins#viewing-available-plugins"},{"project":"v1","title":"Managing Plugins","subheading":"Viewing Installed Plugins","content":"To see only the plugins you have installed, run spin plugins list --installed.","keywords":"","subsectionKeywords":"","url":"/v1/managing-plugins#viewing-installed-plugins"},{"project":"v1","title":"Managing Plugins","subheading":"Uninstalling Plugins","content":"You can uninstall plugins using spin plugins uninstall with the plugin name:$ spin plugins uninstall befunge2wasm","keywords":"","subsectionKeywords":"","url":"/v1/managing-plugins#uninstalling-plugins"},{"project":"v1","title":"Managing Plugins","subheading":"Upgrading Plugins","content":"To upgrade a plugin to the latest version, run spin plugins upgrade. This has the same options as spin plugins install, according to whether the plugin comes from the catalogue, a URL, or a file:$ spin plugins upgrade js2wasm\n$ spin plugins upgrade --url https://github.com/spinframework/spin-befunge-sdk/releases/download/v1.7.0/befunge2wasm.json\n$ spin plugins upgrade --file ~/dev/spin-befunge-sdk/befunge2wasm.jsonundefinedBy default, Spin will only undefined plugins. If you want to allow Spin to roll back to an earlier version, pass the --downgrade flag.","keywords":"","subsectionKeywords":"","url":"/v1/managing-plugins#upgrading-plugins"},{"project":"v1","title":"Managing Plugins","subheading":"Refreshing the Catalogue","content":"The first time you install a plugin from the catalogue, Spin creates a local cache of the catalogue. It continues to use this local cache for future install, list and upgrade commands; this is similar to OS package managers such as apt, and avoids rate limiting on the catalogue. However, this means that in order to see new catalogue entries - new plugins or new versions - you must first update the cache.To update your local cache of the catalogue, run spin plugins update.","keywords":"","subsectionKeywords":"","url":"/v1/managing-plugins#refreshing-the-catalogue"},{"project":"v1","title":"Managing Plugins","subheading":"Next Steps","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/managing-plugins#next-steps"},{"project":"v1","title":"Managing Templates","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedTemplates are a Spin tool for scaffolding new applications and components. You can use them via the spin new and spin add commands. For more information about creating applications with templates, see undefined.","subsectionKeywords":"","url":"/v1/managing-templates"},{"project":"v1","title":"Managing Templates","subheading":"Installing Templates","content":"undefinedTo install templates, use the spin templates install command. You can install templates from a Git repository, or while undefined you can install them from a local directory.","keywords":"","subsectionKeywords":"","url":"/v1/managing-templates#installing-templates"},{"project":"v1","title":"Managing Templates","subheading":"Installing From the Spin Git Repository","content":"To install templates from the Spin Git repository, run spin templates install --git.$ spin templates install --git https://github.com/spinframework/spinThe above command installs undefined templates in the repository.undefined","keywords":"","subsectionKeywords":"","url":"/v1/managing-templates#installing-from-the-spin-git-repository"},{"project":"v1","title":"Managing Templates","subheading":"Installing From a Specific Branch","content":"By default, if you install templates from a Git repository, Spin tries to find a repo tag that matches the version of Spin, and installs from that tag.  Failing this, it installs from HEAD.  If you would like to install from a specific tag or branch, pass the --branch option:$ spin templates install --git https://github.com/spinframework/spin --branch spin/templates/v0.8","keywords":"","subsectionKeywords":"","url":"/v1/managing-templates#installing-from-a-specific-branch"},{"project":"v1","title":"Managing Templates","subheading":"Installing From a Local Directory","content":"To install templates from your local file system, run spin templates install --dir.undefined# Expects to find a directory ~/dev/spin-befunge-sdk/templates\n$ spin templates install --dir ~/dev/spin-befunge-sdkSee undefined for more details on this layout.","keywords":"","subsectionKeywords":"","url":"/v1/managing-templates#installing-from-a-local-directory"},{"project":"v1","title":"Managing Templates","subheading":"Viewing Your Installed Templates","content":"To see what templates you have installed, run spin templates list.You can use the --verbose option to see additional information such as where they were installed from.","keywords":"","subsectionKeywords":"","url":"/v1/managing-templates#viewing-your-installed-templates"},{"project":"v1","title":"Managing Templates","subheading":"Uninstalling Templates","content":"You can uninstall templates using spin templates uninstall with the template name:$ spin templates uninstall redis-befungeundefined","keywords":"","subsectionKeywords":"","url":"/v1/managing-templates#uninstalling-templates"},{"project":"v1","title":"Managing Templates","subheading":"Upgrading Templates","content":"When you upgrade Spin, you will typically want to upgrade your templates to match.  This means new applications and components will get dependencies that match the Spin version you are using.  To do this, run spin templates upgrade:$ spin templates upgrade\nSelect repos to upgrade. Use Space to select/deselect and Enter to confirm selection.\n  [x] https://github.com/spinframework/spin-python-sdk\n  [ ] https://github.com/spinframework/spin (at spin/templates/v1.0)\n> [x] https://github.com/spinframework/spin-js-sdkUse the cursor keys and the space bar to select the repositories you want to upgrade, then hit Enter to upgrade the selected repositories.undefinedIf you want to upgrade undefined repositories without being prompted, run spin templates upgrade --all.As mentioned above, if you want to check which templates come from which repositories use --verbose i.e. spin templates list --verbose.","keywords":"","subsectionKeywords":"","url":"/v1/managing-templates#upgrading-templates"},{"project":"v1","title":"Managing Templates","subheading":"Upgrading Templates From a Local Directory","content":"spin templates upgrade only upgrades from Git repositories.  If you want to upgrade and your templates are in a local directory, run the spin templates install command with the --upgrade flag:$ spin templates install --dir ~/dev/spin-befunge-sdk --upgrade","keywords":"","subsectionKeywords":"","url":"/v1/managing-templates#upgrading-templates-from-a-local-directory"},{"project":"v1","title":"Managing Templates","subheading":"Next Steps","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/managing-templates#next-steps"},{"project":"v1","title":"Spin Application Manifest Reference","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedThis page describes the contents of the Spin manifest file, typically called spin.toml.","subsectionKeywords":"","url":"/v1/manifest-reference"},{"project":"v1","title":"Spin Application Manifest Reference","subheading":"Format","content":"The manifest is a TOML file, and follows standard TOML syntax.  See the undefined for information about the TOML syntax.","keywords":"","subsectionKeywords":"","url":"/v1/manifest-reference#format"},{"project":"v1","title":"Spin Application Manifest Reference","subheading":"Manifest Fields","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| spin_manifest_version | Required   | String      | The version of the file format that the rest of the manifest follows. Currently, this value must be \"1\". | \"1\" |\n| name                  | Required   | String      | The name of the application. This may be any string of alphanumeric characters, hyphens and underscores. | \"hello-world\" |\n| version               | Required   | String      | The version of the application. The must be a string of the form major.minor.patch, where each element is a number. | \"1.0.5\" |\n| description           | Optional   | String      | A human-readable description of the application. | \"The best app for all your world-greeting needs\" |\n| authors               | Optional   | Array of strings | The authors of the applications. If present, this must ba an array, even if it has only one entry. | [\"Jane Q Hacker (<dev@example.com>)\"] |\n| trigger               | Required   | Table       | The trigger for the application - that is, the kind of event that the application responds to. The table must contain the type field, and may contain others depending on the value of type. See undefined for details. | { type = \"http\", base = \"/\" } |\n| variables             | Optional   | Table       | Dynamic configuration variables which the user can set when they run the application. See undefined below. | [variables]<br />message = { default = \"hello\" } |\n| component             | Required   | Table array | A manifest must contain at least one component table. component is always an array, even if there is only one component, so always use double square brackets.  See undefined below. | [[component]]<br />id = \"hello\" |","keywords":"","subsectionKeywords":"","url":"/v1/manifest-reference#manifest-fields"},{"project":"v1","title":"Spin Application Manifest Reference","subheading":"The  trigger  Table","content":"The trigger table specifies the events that the application responds to.  The type field is always required, but the other fields depend on the type.  This section describes the built-in http and redis trigger types.undefinedtrigger = { type = \"http\", base = \"/\" }","keywords":"","subsectionKeywords":"","url":"/v1/manifest-reference#the-trigger-table"},{"project":"v1","title":"Spin Application Manifest Reference","subheading":"The  trigger  Table for HTTP Applications","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| type                  | Required   | String      | Always \"http\" for HTTP applications. | \"http\" |\n| base                  | Required   | String      | The base path of the application. All component routes are relative to this. It allows multiple applications to be mounted under the same host. | \"/\" |","keywords":"","subsectionKeywords":"","url":"/v1/manifest-reference#the-trigger-table-for-http-applications"},{"project":"v1","title":"Spin Application Manifest Reference","subheading":"The  trigger  Table for Redis Applications","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| type                  | Required   | String      | Always \"redis\" for Redis applications. | \"redis\" |\n| address               | Required   | String      | The address of the Redis instance the components are using the message subscriptions. Use the redis: URL scheme. | \"redis://localhost:6379\" |","keywords":"","subsectionKeywords":"","url":"/v1/manifest-reference#the-trigger-table-for-redis-applications"},{"project":"v1","title":"Spin Application Manifest Reference","subheading":"The  variables  Table","content":"The keys of variables table are user-defined.  The value of each key is another table with the fields shown in the following table.undefined[variables]\nvessel = { default = \"teapot\" }\ntoken = { required = true, secret = true }| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| default               | Optional   | String      | The value of the variable if no value is supplied at runtime. If specified, the value must be a string. If not specified, required must be true. | \"teapot\" |\n| required              | Optional   | Boolean     | Whether a value must be supplied at runtime. If not specified, required defaults to false, and default must be provided | false |\n| secret                | Optional   | Boolean     | If set, this variable should be treated as sensitive. | false |","keywords":"","subsectionKeywords":"","url":"/v1/manifest-reference#the-variables-table"},{"project":"v1","title":"Spin Application Manifest Reference","subheading":"The  component  Tables","content":"component is a table array, meaning each component is introduced with double-bracket syntax.  Subtables are written using single-bracket syntax or inline JSON syntax.  For example:[[component]]\nid = \"hello\"\nsource = \"hello.wasm\"\n[component.trigger]\nroute = \"/hello\"Each table in the component array contains the following fields:| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| id                    | Required   | String      | An identifier for this component, unique within the application. This may be any string of alphanumeric characters, hyphens and underscores. | \"cart-api\" |\n| description           | Optional   | String      | A human-readable description of the component. | \"The shopping cart API\" |\n| source                | Required   | String or table | The Wasm module which should handle the component. This must be built to work with the application trigger. It can be in one of the following formats: | |\n|                         |            | String      | * The path to a Wasm file (relative to the manifest file) | dist/cart.wasm |\n|                         |            | Table       | * The URL of a Wasm file downloadable over HTTP. This must be a table containing a url field for the Wasm file, and a digest field contains a SHA256 hex digest, used to check integrity. | { url = \"https://example.com/example.wasm\", digest = \"sha256:6503...2375\" } |\n| files                 | Optional   | Array of strings and/or tables | The files to be made available to the Wasm module at runtime. This is an array, and each element of the array is either: | [ \"images/*.jpg\", { source = \"assets/images\", destination = \"/pictures\" } ] |\n|                         |            | String      | * A file path or glob pattern, relative to the manifest file. The matching file or files will be available in the Wasm module at the same relative paths. | \"images/*.jpg\" |\n|                         |            | Table       | * A directory to be made available to the Wasm module at a specific path. This must be a table containing a source field for the directory relative to the manifest file, and a destination field containing the absolute path at which to make it available. | { source = \"assets/images\", destination = \"/pictures\" } |\n| exclude_files         | Optional   | Array of strings | Any files or glob patterns that should undefined be available to the Wasm module at runtime, even though they match a files entry. | [assets/images/test/**/*.*] |\n| allowed_http_hosts    | Optional   | Array of strings | The host names or addresses to which the Wasm module is allowed to send HTTP requests. If the name includes a port, the Wasm module can send requests only to that port; otherwise, the Wasm module can send requests only to the default port for the scheme it uses. The special string insecure:allow-all permits the module to send HTTP requests to undefined host, but is intended for development use only; some deployment environments may decline to honour it. | [\"example.com\", \"localhost:8081\"] |\n| key_value_stores      | Optional   | Array of strings | An array of key-value stores that the Wasm module is allowed to read or write. A store named default is provided by the Spin runtime, though modules must still be permitted to access it. In current versions of Spin, \"default\" is the only store allowed. | [\"default\"] |\n| environment           | Optional   | Table       | Environment variables to be set for the Wasm module. This is a table. The table keys are user-defined; the values must be strings. | { DB_URL = \"mysql://spin:spin@localhost/dev\" } |\n| trigger               | Required   | Table       | Specifies how this component is triggered. This is a table, whose contents of are trigger-specific; see below. | [component.trigger]<br />route = \"/...\" |\n| build                 | Optional   | Table       | The command that spin build uses to build this component. See undefined below. | [component.build]<br />command = \"npm run build\" |\n| config                | Optional   | Table       | Dynamic configuration values to be made available to this component. The table keys are user-defined; the values must be strings, and may use template notation as described under undefined. | [component.config]<br />api_base_url = \"https://{{ api_host }}/v1\" |","keywords":"","subsectionKeywords":"","url":"/v1/manifest-reference#the-component-tables"},{"project":"v1","title":"Spin Application Manifest Reference","subheading":"The  component.trigger  Table for HTTP Applications","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| route                 | Required   | String      | The route which this component handles. Requests to the route will cause the component to execute. This may be an exact route (/example), which matches on the given path, or a wildcard route indicated by the suffix /... (/example/...), which matches any route under this prefix. If two routes overlap, requests are directed to the matching route with the longest prefix - see undefined for details and examples. | \"/api/cart/...\" |\n| executor              | Optional   | Table       | How Spin should invoke the component. If present, this is a table.  The type key is required and may have the values \"spin\" or \"wagi\". If omitted. the default is { type = \"spin\"}. See undefined for details. | { type = \"wagi\" } |\n|                         |            |             | If type = \"spin\" there are no other keys defined. In this case, Spin calls the component using a standard Wasm component interface. Components built using Spin SDKs or Spin interface files use this convention. | { type = \"spin\" } |\n|                         |            |             | If type = \"wagi\", Spin calls the component's \"main\" (_start) function using undefined. Components built using languages or toolchains that do not support Wasm interfaces will need to be called in this way. In this case, the following additional keys may be set:<br/><br/>* argv (optional): The string representation of the argv list that should be passed into the handler. ${SCRIPT_NAME} will be replaced with the script name, and ${ARGS} will be replaced with the query parameters of the request, formatted as arguments. The default is to follow the CGI specification, and pass ${SCRIPT_NAME} ${ARGS}<br/><br/>* entrypoint (optional): The name of the function to call as the entry point to this handler. By default, it is _start (which in most languages translates to main in the source code).<br/><br/>See undefined for details. | { type = \"wagi\" } |","keywords":"","subsectionKeywords":"","url":"/v1/manifest-reference#the-componenttrigger-table-for-http-applications"},{"project":"v1","title":"Spin Application Manifest Reference","subheading":"The  component.trigger  Table for Redis Applications","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| channel               | Required   | String      | The Redis channel which this component handles. Messages on this channel will cause the component to execute. | \"purchases\" |","keywords":"","subsectionKeywords":"","url":"/v1/manifest-reference#the-componenttrigger-table-for-redis-applications"},{"project":"v1","title":"Spin Application Manifest Reference","subheading":"The  component.build  Table","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| command               | Required   | String      | The command to execute on spin build. | \"cargo build --target wasm32-wasi --release\" |\n| workdir               | Optional   | String      | The directory in which to execute command, relative to the manifest file. The default is the directory containing the manifest file. An example of where this is needed is a multi-component application where each component is its own source tree in its own directory. | \"my-project\" |\n| watch                 | Optional   | Array of strings | The files or glob patterns which spin watch should monitor to determine if the component Wasm file needs to be rebuilt. These are relative to workdir, or to the directory containing the manifest file if workdir is not present. | [\"src/**/*.rs\", \"Cargo.toml\"] |","keywords":"","subsectionKeywords":"","url":"/v1/manifest-reference#the-componentbuild-table"},{"project":"v1","title":"Spin Application Manifest Reference","subheading":"Next Steps","content":"undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/manifest-reference#next-steps"},{"project":"v1","title":"Building Spin components in other languages","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedWebAssembly is becoming undefined, and as language toolchains add support for the\nundefined,\nbuilding Spin components will also become supported.As a general rule:undefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v1/other-languages"},{"project":"v1","title":"Building Spin components in other languages","subheading":"AssemblyScript","content":"undefined is a TypeScript-based language that compiles directly to WebAssembly.\nAssemblyScript has WASI/Wagi support, and so can be used with Spin.undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/other-languages#assemblyscript"},{"project":"v1","title":"Building Spin components in other languages","subheading":"C/C++","content":"C and C++ are both broadly supported in the WebAssembly ecosystem. WASI/Wagi support means that both can be used to write Spin apps.undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/other-languages#cc"},{"project":"v1","title":"Building Spin components in other languages","subheading":"C# and .NET Languages","content":".NET has experimental support for WASI, so many (if not all) .NET languages, including C# and F#, can be used to write Spin applications.undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/other-languages#c-and-net-languages"},{"project":"v1","title":"Building Spin components in other languages","subheading":"Grain","content":"undefined, a new functional programming language, has WASI/Wagi support and can be used to write Spin apps.undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/other-languages#grain"},{"project":"v1","title":"Building Spin components in other languages","subheading":"Python","content":"Python's interpreter can be compiled to WebAssembly, and it has WASI support. It is known to work for Spin.undefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/other-languages#python"},{"project":"v1","title":"Building Spin components in other languages","subheading":"Ruby","content":"Upstream undefined officially supports WebAssembly and WASI, and we here at Fermyon have successfully run Ruby apps in Spin.undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/other-languages#ruby"},{"project":"v1","title":"Building Spin components in other languages","subheading":"Zig","content":"Zig is a low-level systems language that has support for Wasm and WASI, and can be used to write Spin apps.undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/other-languages#zig"},{"project":"v1","title":"Creating Spin Plugins","subheading":"","content":"undefinedundefinedundefinedSpin plugins add new functionality or subcommands to Spin without modifying the\nSpin codebase. They make Spin easily extensible while keeping it lightweight.\nSpin plugins can add new triggers to Spin (such as the undefined),\nenable new language SDKs (such as\nundefined),\nand more.This document will cover what Spin plugins are, how to use a plugin, and how to\ncreate a plugin.","subsectionKeywords":"","url":"/v1/plugin-authoring"},{"project":"v1","title":"Creating Spin Plugins","subheading":"What Are Spin Plugins?","content":"A Spin plugin is an executable that is added to Spin's plugins directory\n($XDG_DATA_HOME/spin/plugins) upon a spin plugins install <plugin-name>. The\nplugin is then ready to be used. If the plugin is an extension to the Spin CLI,\nit can now be executed directly as a subcommand: spin <plugin-name>. If the\nplugin is a trigger plugin, it will be executed during spin up when an app\nusing that trigger is run.While for now plugins are assumed to be executables, in the future, support for\nplugging in WebAssembly modules may be desirable.","keywords":"","subsectionKeywords":"","url":"/v1/plugin-authoring#what-are-spin-plugins"},{"project":"v1","title":"Creating Spin Plugins","subheading":"How to Find and Use a Spin Plugin","content":"Spin maintains a centralized catalogue of available Spin plugins in the undefined. During plugin\ninstallation, if it does not already exist, Spin fetches the remote catalogue\nand creates a local snapshot. To ensure that the local snapshot is up to date,\nit is best to run spin plugins update before installing any plugins.To list available plugins, run spin plugins list. Now, decide which plugin to\ninstall. For example, the js2wasm plugin, which is needed in order to build\nJavaScript Spin applications, can be installed by running:$ spin plugins install js2wasmWith the plugin installed, you can now call spin js2wasm to run it. In this\ncase, for example, you might call it from your JavaScript application's npm\nbuild script. Learn more about building Spin components in JavaScript\nundefined.To upgrade installed plugins to newer versions, run spin plugin update to\nfetch the latest plugins to the local catalogue and spin plugin upgrade to perform the\nupgrade on the installed plugins.","keywords":"","subsectionKeywords":"","url":"/v1/plugin-authoring#how-to-find-and-use-a-spin-plugin"},{"project":"v1","title":"Creating Spin Plugins","subheading":"Authoring a Spin Plugin","content":"Spin plugins are implemented as a manifest that points to one or more .tar.gz archives which contain the plugin executables. So, to create a plugin you must:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/plugin-authoring#authoring-a-spin-plugin"},{"project":"v1","title":"Creating Spin Plugins","subheading":"Environment Variables Available to the Plugin Executable","content":"Your plugin may need to know information about the instance of Spin it's running in. For example, suppose your plugin wants to call spin build. The trouble is that you don't know if it's on the user's system PATH. Suppose, further, that your plugin would prefer to call spin build -c (to build only a specific component) if it's available but can fall back to spin build (to build everything) if it's not. The -c option only exists in Spin 1.4 and above, so this optimization requires that you know which version of Spin you're running in.To help with this, when a user uses Spin to run your plugin, Spin sets a number of environment variables on the plugin process. Your code can use these environment variables to find out things like the path to the Spin binary and which version of Spin it is. When your plugin runs, the parent Spin process will set these to the right values for the undefined instance of Spin. In the example above, when your plugin wants to run spin build, it can consult the SPIN_BIN_PATH environment variable for the program path, and be confident that the SPIN_VERSION environment variable matches the Spin binary at that location.The variables Spin sets are:| Name               | Meaning                                                                                                               | Example |\n|--------------------|-----------------------------------------------------------------------------------------------------------------------|---------|\n| SPIN_BIN_PATH      | The path to the Spin executable that the user is running. Use this if your plugin issues commands using the Spin CLI. | /Users/alice/.cargo/bin/spin |\n| SPIN_BRANCH        | The Git branch from which the Spin executable was built.                                                              | main |\n| SPIN_BUILD_DATE    | The date on which the Spin executable was built, in yyyy-mm-dd format.                                                | 2023-05-15 |\n| SPIN_COMMIT_DATE   | The date of the Git commit from which the Spin executable was built, in yyyy-mm-dd format.                            | 2023-05-15 |\n| SPIN_COMMIT_SHA    | The SHA of the Git commit from which the Spin executable was built.                                                   | 49fb11b |\n| SPIN_DEBUG         | Whether the Spin executable is a debug build.                                                                         | false |\n| SPIN_TARGET_TRIPLE | The processor and operating system for which the Spin executable was built, in Rust target-triple format.             | aarch64-apple-darwin |\n| SPIN_VERSION       | The version of Spin. This can be used to detect features availability, or to determine pre-stable command syntax.     | 1.3.0 |\n| SPIN_VERSION_MAJOR | The major version of Spin.                                                                                            | 1 |\n| SPIN_VERSION_MINOR | The minor version of Spin.                                                                                            | 3 |\n| SPIN_VERSION_PRE   | The prerelease version string, or empty if this is a released version of Spin.                                        | pre0 |undefined","keywords":"","subsectionKeywords":"","url":"/v1/plugin-authoring#environment-variables-available-to-the-plugin-executable"},{"project":"v1","title":"Creating Spin Plugins","subheading":"Packaging a Plugin","content":"After creating your plugin executable, package it along with its license as a\ntar.gz archive. Note that the name field in the plugin manifest must match\nboth the binary and license name. See the undefined\nfor more details on naming conventions.Refer to the aptly named undefined for an\nexample of how to build a plugin.","keywords":"","subsectionKeywords":"","url":"/v1/plugin-authoring#packaging-a-plugin"},{"project":"v1","title":"Creating Spin Plugins","subheading":"Creating a Spin Plugin Manifest","content":"A Spin plugin manifest is a JSON file that conforms to the undefined.\nA manifest defines a plugin’s name, version, license, homepage (i.e. GitHub\nrepo), compatible Spin version, and gives a short description of the plugin. It\nalso lists the URLs of the tar archives of the plugin for various operating\nsystems and platforms. The URL can point to the local path to the file by using\nthe file scheme file://, for example, file:///tmp/my-plugin.tar.gz.To ensure your plugin manifest is valid, follow the steps in the undefined.","keywords":"","subsectionKeywords":"","url":"/v1/plugin-authoring#creating-a-spin-plugin-manifest"},{"project":"v1","title":"Creating Spin Plugins","subheading":"Installing a Local Plugin","content":"By default, Spin will look in the plugins catalogue for a plugin. However, when\ndeveloping and testing a plugin, it is unlikely to be in the the catalogue. For\nboth installs and upgrades, the --file or --url flags can be used to point\nto specific local or remote plugin manifests. For example, a local manifest\ncalled practice.json can be installed and run as follows:$ spin plugin install --file practice.json\n$ spin practice","keywords":"","subsectionKeywords":"","url":"/v1/plugin-authoring#installing-a-local-plugin"},{"project":"v1","title":"Creating Spin Plugins","subheading":"Contributing a Plugin","content":"If you think the community would benefit from your newly created plugin, create\na PR to add it to the undefined!","keywords":"","subsectionKeywords":"","url":"/v1/plugin-authoring#contributing-a-plugin"},{"project":"v1","title":"Building Spin Components in Python","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedWith <a href=\"https://www.python.org/\" target=\"_blank\">Python</a> being a very popular language, Spin provides support for building components with Python; undefined. The development of the Python SDK is continually being worked on to improve user experience and also add new features.undefinedundefinedundefined There is a blog article undefined if you are interested in some further reading; in addition to this technical documentation.","subsectionKeywords":"","url":"/v1/python-components"},{"project":"v1","title":"Building Spin Components in Python","subheading":"Spin's Python Plugin","content":"To compile Python programs to Spin components, you need to install a Spin plugin called py2wasm. The following commands will ensure that you have the latest version of the plugin installed:# Fetch all of the latest Spin plugins from the spin-plugins repository\n$ spin plugin update\n# Install py2wasm plugin\n$ spin plugin install py2wasmundefined For more information about managing spin plugins, see the undefined in the Spin Command Line Interface (CLI) documentation.","keywords":"","subsectionKeywords":"","url":"/v1/python-components#spins-python-plugin"},{"project":"v1","title":"Building Spin Components in Python","subheading":"Spin's Python HTTP Request Handler Template","content":"Spin's Python HTTP Request Handler Template can be installed from undefined using the following command:$ spin templates install --git https://github.com/spinframework/spin-python-sdk --updateThe above command will install the http-py template and produce an output similar to the following:Copying remote template source\nInstalling template http-py...\nInstalled 1 template(s)\n\n+---------------------------------------------+\n| Name      Description                       |\n+=============================================+\n| http-py   HTTP request handler using Python |\n+---------------------------------------------+undefined For more information about managing spin templates, see the undefined in the Spin Command Line Interface (CLI) documentation.","keywords":"","subsectionKeywords":"","url":"/v1/python-components#spins-python-http-request-handler-template"},{"project":"v1","title":"Building Spin Components in Python","subheading":"Structure of a Python Component","content":"A new Python component can be created using the following command:$ spin new http-py hello-world --accept-defaultsThis creates a directory of the following structure:hello-world/\n├── app.py\n├── Pipfile\n└── spin.tomlThe spin.toml file will look similar to the following:spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\nname = \"hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"hello-world\"\nsource = \"app.wasm\"\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"spin py2wasm app -o app.wasm\"","keywords":"","subsectionKeywords":"","url":"/v1/python-components#structure-of-a-python-component"},{"project":"v1","title":"Building Spin Components in Python","subheading":"A Simple HTTP Components Example","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request and must return an HTTP response at the end of their execution. Components can be built in any language that compiles to WASI. If you would like additional information about building HTTP applications you may find undefined useful.Building a Spin HTTP component using the Python SDK means writing a single function that takes an HTTP request as a parameter, and returns an HTTP response. Here is an example of the default Python code which the previous spin new created for us; a simple example of a request/response:from spin_http import Response\n\ndef handle_request(request):\n    return Response(200,\n                    {\"content-type\": \"text/plain\"},\n                    bytes(f\"Hello from the Python SDK\", \"utf-8\"))The important things to note in the implementation above:undefinedundefinedThe source code for this Python HTTP component example is in the app.py file. The app.py file is compiled into a .wasm module thanks to the py2wasm plugin. This all happens behind the scenes.","keywords":"","subsectionKeywords":"","url":"/v1/python-components#a-simple-http-components-example"},{"project":"v1","title":"Building Spin Components in Python","subheading":"Building and Running the Application","content":"All you need to do is run the spin build command from within the project's directory; as shown below:$ cd hello-world\n$ spin buildEssentially, we have just created a new Spin compatible module which can now be run using the spin up command, as shown below:$ spin upWith Spin running our application in our terminal, we can now go ahead (grab a new terminal) and call the Spin application via an HTTP request:$ curl -i localhost:3000/hello\n\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 25\n\nHello from the Python SDKundefined","keywords":"","subsectionKeywords":"","url":"/v1/python-components#building-and-running-the-application"},{"project":"v1","title":"Building Spin Components in Python","subheading":"An Outbound HTTP Example","content":"This next example will create an outbound request, to obtain a random fact about animals, which will be returned to the calling code. If you would like to try this out, you can go ahead and update your existing app.py file from the previous step; using the following source code:from spin_http import Request, Response, http_send\n\n\ndef handle_request(request):\n\n    response = http_send(\n        Request(\"GET\", \"https://random-data-api.fermyon.app/animals/json\", {}, None))\n\n    return Response(200,\n                    {\"content-type\": \"text/plain\"},\n                    bytes(f\"Here is an animal fact: {str(response.body, 'utf-8')}\", \"utf-8\"))","keywords":"","subsectionKeywords":"","url":"/v1/python-components#an-outbound-http-example"},{"project":"v1","title":"Building Spin Components in Python","subheading":"Configuration","content":"The Spin framework protects your code from making outbound requests to just any URL. For example, if we try to run the above code undefined, we will correctly get the following error AssertionError: HttpError::DestinationNotAllowed. To allow our component to request the random-data-api.fermyon.app domain, all we have to do is add that domain to the specific component of the application that is making the request. Here is an example of an updated spin.toml file where we have added allowed_http_hosts:spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\nname = \"hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"hello-world\"\nsource = \"app.wasm\"\nallowed_http_hosts = [\"random-data-api.fermyon.app\"]\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"spin py2wasm app -o app.wasm\"","keywords":"","subsectionKeywords":"","url":"/v1/python-components#configuration"},{"project":"v1","title":"Building Spin Components in Python","subheading":"Building and Running the Application","content":"If we re-build the application with this new configuration and re-run, we will get our new animal fact:$ spin build\n$ spin upA new request now correctly returns an animal fact from the API endpoint.$ curl -i localhost:3000/hello\n\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 130\n\nHere is an animal fact: {\"timestamp\":1684299253331,\"fact\":\"Reindeer grow new antlers every year\"}   ","keywords":"","subsectionKeywords":"","url":"/v1/python-components#building-and-running-the-application"},{"project":"v1","title":"Building Spin Components in Python","subheading":"An Outbound Redis Example","content":"In this final example, we talk to an existing Redis instance. You can find the official undefined. We also gave a quick run-through on setting up Redis with Spin in our previous article called undefined, so please take a look at that blog if you need a hand.","keywords":"","subsectionKeywords":"","url":"/v1/python-components#an-outbound-redis-example"},{"project":"v1","title":"Building Spin Components in Python","subheading":"Configuration","content":"After installing Redis on localhost, we simply add the config = { redis_address = \"redis://127.0.0.1:6379\" } to the spin.toml file, as shown below:spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\nname = \"hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"hello-world\"\nsource = \"app.wasm\"\nconfig = { redis_address = \"redis://127.0.0.1:6379\" }\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"spin py2wasm app -o app.wasm\"If you are still following along, please go ahead and update your app.py file one more time, as follows:from spin_http import Response\nfrom spin_redis import redis_del, redis_get, redis_incr, redis_set, redis_sadd, redis_srem, redis_smembers\nfrom spin_config import config_get\n\n\ndef handle_request(request):\n\n    redis_address = config_get(\"redis_address\")\n    redis_set(redis_address, \"foo\", b\"bar\")\n    value = redis_get(redis_address, \"foo\")\n    redis_del(redis_address, [\"testIncr\"])\n    redis_incr(redis_address, \"testIncr\")\n\n    redis_sadd(redis_address, \"testSets\", [\"hello\", \"world\"])\n    content = redis_smembers(redis_address, \"testSets\")\n    redis_srem(redis_address, \"testSets\", [\"hello\"])\n\n    assert value == b\"bar\", f\"expected \\\"bar\\\", got \\\"{str(value, 'utf-8')}\\\"\"\n\n    return Response(200,\n                    {\"content-type\": \"text/plain\"},\n                    bytes(f\"Executed outbound Redis commands: {request.uri}\", \"utf-8\"))","keywords":"","subsectionKeywords":"","url":"/v1/python-components#configuration"},{"project":"v1","title":"Building Spin Components in Python","subheading":"Building and Running the Application","content":"After we re-build and re-run, again, we can make one final request to our Spin application:$ spin build\n$ spin upThis latest request correctly returns the correct output, in accordance with our Python source code from above:$ curl -i localhost:3000/hello\n\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 40\ndate: Mon, 27 Feb 2023 05:16:03 GMT\n\nExecuted outbound Redis commands: /helloIf we go into our Redis CLI on localhost we can see that the value foo which was set in the Python source code ( redis_set(redis_address, \"foo\", b\"bar\") ) is now correctly set to the value of bar:redis-cli\n127.0.0.1:6379> get foo\n\"bar\"","keywords":"","subsectionKeywords":"","url":"/v1/python-components#building-and-running-the-application"},{"project":"v1","title":"Building Spin Components in Python","subheading":"Storing Data in the Spin Key-Value Store","content":"Spin has a key-value store built in. For information about using it from Python, see undefined.","keywords":"","subsectionKeywords":"","url":"/v1/python-components#storing-data-in-the-spin-key-value-store"},{"project":"v1","title":"Building Spin Components in Python","subheading":"Storing Data in SQLite","content":"For more information about using SQLite from Python, see undefined.","keywords":"","subsectionKeywords":"","url":"/v1/python-components#storing-data-in-sqlite"},{"project":"v1","title":"Building Spin Components in Python","subheading":"AI Inferencing From Python Components","content":"For more information about using Serverless AI from Python, see the undefined API guide","keywords":"","subsectionKeywords":"","url":"/v1/python-components#ai-inferencing-from-python-components"},{"project":"v1","title":"Taking Spin for a spin","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedLet's get Spin and take it from nothing to a \"hello world\" application!","keywords":"quickstart","subsectionKeywords":"","url":"/v1/quickstart"},{"project":"v1","title":"Taking Spin for a spin","subheading":"Install Spin","content":"{{ tabs \"os\" }}{{ startTab \"Linux\"}}Download the spin binary along with a starter set of templates and plugins using the install.sh script hosted on this site:Then move the spin binary somewhere in your path, so you can run it from anywhere. For example:$ sudo mv ./spin /usr/local/bin/spin{{ blockEnd }}{{ startTab \"macOS\"}}Download the spin binary along with a starter set of templates and plugins using the install.sh script hosted on this site:Then move the spin binary somewhere in your path, so you can run it from anywhere. For example:$ sudo mv ./spin /usr/local/bin/spin{{ blockEnd }}{{ startTab \"Windows\"}}Download <a href=\"https://github.com/spinframework/spin/releases/latest\" class=\"spin-install\" id=\"spin-install-windows\">the Windows binary release of Spin</a> from GitHub.Unzip the binary release and place the spin.exe in your system path.{{ blockEnd }}\n{{ blockEnd }}undefined","keywords":"","subsectionKeywords":"","url":"/v1/quickstart#install-spin"},{"project":"v1","title":"Taking Spin for a spin","subheading":"Install the Prerequisites","content":"","keywords":"","subsectionKeywords":"","url":"/v1/quickstart#install-the-prerequisites"},{"project":"v1","title":"Taking Spin for a spin","subheading":"Install a Template","content":"The quickest and most convenient way to start a new application is to install and use a Spin template for your preferred language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}$ spin templates install --git https://github.com/spinframework/spin --update\nCopying remote template source\nInstalling template redis-rust...\nInstalling template http-rust...\n... other templates omitted ...\n+------------------------------------------------------------------------+\n| Name                Description                                        |\n+========================================================================+\n| ... other templates omitted ...                                        |\n| http-rust           HTTP request handler using Rust                    |\n| redis-rust          Redis message handler using Rust                   |\n| ... other templates omitted ...                                        |\n+------------------------------------------------------------------------+Note: The Rust templates are in a repo that contains several other languages; they will all be installed together.{{ blockEnd }}{{ startTab \"TypeScript\" }}$ spin templates install --git https://github.com/spinframework/spin-js-sdk --update\nCopying remote template source\nInstalling template http-js...\nInstalling template http-ts...\n+------------------------------------------------------------------------+\n| Name                Description                                        |\n+========================================================================+\n| http-js             HTTP request handler using Javascript              |\n| http-ts             HTTP request handler using Typescript              |\n+------------------------------------------------------------------------+{{ blockEnd }}{{ startTab \"Python\" }}$ spin templates install --git https://github.com/spinframework/spin-python-sdk --update\nCopying remote template source\nInstalling template http-py...\n+---------------------------------------------+\n| Name      Description                       |\n+=============================================+\n| http-py   HTTP request handler using Python |\n+---------------------------------------------+{{ blockEnd }}{{ startTab \"TinyGo\" }}$ spin templates install --git https://github.com/spinframework/spin --update\nCopying remote template source\nInstalling template redis-go...\nInstalling template http-go...\n+------------------------------------------------------------------------+\n| Name                Description                                        |\n+========================================================================+\n| ... other templates omitted ...                                        |\n| http-go             HTTP request handler using (Tiny)Go                |\n| redis-go            Redis message handler using (Tiny)Go               |\n| ... other templates omitted ...                                        |\n+------------------------------------------------------------------------+Note: The Go templates are in a repo that contains several other languages; they will all be installed together.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/quickstart#install-a-template"},{"project":"v1","title":"Taking Spin for a spin","subheading":"Install the Tools","content":"Some languages require additional tool support for Wasm:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}You'll need the wasm32-wasi target for Rust:$ rustup target add wasm32-wasiundefined{{ blockEnd }}{{ startTab \"TypeScript\" }}You'll need the Spin js2wasm plugin:$ spin plugins update\n$ spin plugins install js2wasm --yesundefined{{ blockEnd }}{{ startTab \"Python\" }}You'll need the Spin py2wasm plugin:$ spin plugins update\n$ spin plugins install py2wasm --yesundefined{{ blockEnd }}{{ startTab \"TinyGo\" }}You'll need the TinyGo compiler, as the standard Go compiler does not yet support the WASI standard.  See the undefined.undefined{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/quickstart#install-the-tools"},{"project":"v1","title":"Taking Spin for a spin","subheading":"Create Your First Application","content":"{{suh_cards}}\n{{card_element \"sample\" \"Checklist Sample App\" \"A checklist app that persists data in a key value store\" \"https://developer.fermyon.com/hub/preview/sample_checklist\" \"Typescript,Http,Kv\" true }}\n{{card_element \"sample\" \"AI-assisted News Summarizer\" \"Read an RSS newsfeed and have AI summarize it for you\" \"https://developer.fermyon.com/hub/preview/sample_newsreader_ai\" \"Typescript,Javascript,Ai\" true }}\n{{blockEnd}}Now you are ready to create your first Spin application:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}Use the spin new command and the http-rust template to scaffold a new Spin application:$ spin new\nPick a template to start your application with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-csharp (HTTP request handler using C# (EXPERIMENTAL))\n  http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n> http-rust (HTTP request handler using Rust)\n  http-swift (HTTP request handler using SwiftWasm)\n  http-zig (HTTP request handler using Zig)\n  redis-go (Redis message handler using (Tiny)Go)\n  redis-rust (Redis message handler using Rust)\n\nEnter a name for your new application: hello_rust\nProject description: My first Rust Spin application\nHTTP base: /\nHTTP path: /...This command created a directory with the necessary files needed to build and run a Rust Spin application.  Change to that directory, and look at the files.  It looks very much like a normal Rust library project:$ cd hello_rust\n$ tree\n.\n├── .cargo\n│   └── config.toml\n├── .gitignore\n├── Cargo.toml\n├── spin.toml\n└── src\n    └── lib.rsThe additional spin.toml file is the manifest file, which tells Spin what events should trigger what components.  In this case our trigger is HTTP, for a Web application, and we have only one component, at the route /....  This is a wildcard that matches any route:spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first Rust Spin application\"\nname = \"hello_rust\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"hello-rust\"\nsource = \"target/wasm32-wasi/release/hello_rust.wasm\"\nallowed_http_hosts = []\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"This represents a simple Spin HTTP application (triggered by an HTTP request), with\na single component called hello-rust. This component is on the route /..., which is a wildcard\nmeaning it will match any route.  When the application gets an HTTP request, Spin will map its route\nto the hello-rust component, and execute the associated hello_rust.wasm\nWebAssembly module.undefinedNow let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in Rust — a regular Rust function that\ntakes an HTTP request as a parameter and returns an HTTP response, and it is\nannotated with the http_component macro which identifies it as the entry point\nfor HTTP requests:use anyhow::Result;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n};\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn handle_hello_rust(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req.headers());\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(\"Hello, Fermyon\".into()))?)\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}Use the spin new command and the http-ts template to scaffold a new Spin application.  (If you prefer JavaScript to TypeScript, the http-js template is very similar.):$ spin new\nPick a template to start your application with:\n  http-js (HTTP request handler using Javascript)\n> http-ts (HTTP request handler using Typescript)\nEnter a name for your new application: hello_typescript\nProject description: My first TypeScript Spin application\nHTTP base: /\nHTTP path: /...This command created a directory with the necessary files needed to build and run a TypeScript Spin application.  Change to that directory, and look at the files.  It looks similar to a lot of NPM projects:$ cd hello_typescript\n$ tree\n.\n├── package.json\n├── README.md\n├── spin.toml\n├── src\n│   └── index.ts\n├── tsconfig.json\n└── webpack.config.jsThe additional spin.toml file is the manifest file, which tells Spin what events should trigger what components.  In this case our trigger is HTTP, for a Web application, and we have only one component, at the route /....  This is a wildcard that matches any route:spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first TypeScript Spin application\"\nname = \"hello_typescript\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"hello-typescript\"\nsource = \"target/spin-http-js.wasm\"\nexclude_files = [\"**/node_modules\"]\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"npm run build\"This represents a simple Spin HTTP application (triggered by an HTTP request), with\na single component called hello-typescript. This component is on the route /..., which is a wildcard\nmeaning it will match any route.  When the application gets an HTTP request, Spin will map its route\nto the hello-typescript component, and execute the associated spin-http-js.wasm\nWebAssembly module.undefinedNow let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in TypeScript — a regular function named handleRequest that\ntakes an HTTP request as a parameter and returns an HTTP response.  (The\nJavaScript version looks slightly different, but is still a function with\nthe same signature.)  The Spin js2wasm plugin looks for the handleRequest function\nby name when building your application into a Wasm module:import { HandleRequest, HttpRequest, HttpResponse} from \"@fermyon/spin-sdk\"\n\nconst encoder = new TextEncoder()\n\nexport const handleRequest: HandleRequest = async function(request: HttpRequest): Promise<HttpResponse> {\n    return {\n      status: 200,\n      headers: { \"foo\": \"bar\" },\n      body: encoder.encode(\"Hello from TS-SDK\").buffer\n    }\n}{{ blockEnd }}{{ startTab \"Python\"}}Use the spin new command and the http-py template to scaffold a new Spin application.$ spin new\nPick a template to start your application with:\n> http-py (HTTP request handler using Python)\nEnter a name for your new application: hello_python\nDescription: My first Python Spin application\nHTTP base: /\nHTTP path: /...This command created a directory with the necessary files needed to build and run a Python Spin application.  Change to that directory, and look at the files.  It contains a minimal Python application:$ cd hello_python\n$ tree\n.\n├── app.py\n├── Pipfile\n├── README.md\n└── spin.tomlThe additional spin.toml file is the manifest file, which tells Spin what events should trigger what components.  In this case our trigger is HTTP, for a Web application, and we have only one component, at the route /....  This is a wildcard that matches any route.spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first Python Spin application\"\nname = \"hello_python\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"hello-python\"\nsource = \"app.wasm\"\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"spin py2wasm app -o app.wasm\"This represents a simple Spin HTTP application (triggered by an HTTP request), with\na single component called hello-python. This component is on the route /..., which is a wildcard\nmeaning it will match any route.  When the application gets an HTTP request, Spin will map its route\nto the hello-python component, and execute the associated app.wasm\nWebAssembly module.undefinedNow let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in Python — a regular function named handle_request that\ntakes an HTTP request as a parameter and returns an HTTP response.  The Spin py2wasm plugin looks for the handle_request function by name when building your application into a Wasm module.from spin_http import Response\n\ndef handle_request(request):\n    return Response(200,\n                    [(\"content-type\", \"text/plain\")],\n                    bytes(f\"Hello from the Python SDK\", \"utf-8\")){{ blockEnd }}{{ startTab \"TinyGo\"}}Use the spin new command and the http-go template to scaffold a new Spin application.$ spin new\nPick a template to start your application with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-empty (HTTP application with no components)\n> http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n  http-php (HTTP request handler using PHP)\n  http-rust (HTTP request handler using Rust)\nEnter a name for your new application: hello_go\nDescription: My first Go Spin application\nHTTP base: /\nHTTP path: /...This command created a directory with the necessary files needed to build and run a Go Spin application using the TinyGo compiler.  Change to that directory, and look at the files.  It looks very much like a normal Go project:$ cd hello_go\n$ tree\n.\n├── go.mod\n├── go.sum\n├── main.go\n└── spin.tomlThe additional spin.toml file is the manifest file, which tells Spin what events should trigger what components.  In this case our trigger is HTTP, for a Web application, and we have only one component, at the route /....  This is a wildcard that matches any route.spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first Go Spin application\"\nname = \"hello_go\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"hello-go\"\nsource = \"main.wasm\"\nallowed_http_hosts = []\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"This represents a simple Spin HTTP application (triggered by an HTTP request), with\na single component called hello-go. This component is on the route /..., which is a wildcard\nmeaning it will match any route.  When the application gets an HTTP request, Spin will map its route\nto the hello-go component, and execute the associated main.wasm\nWebAssembly module.undefinedNow let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in Go. Notice where the work is done.  The\nmain function is empty (and Spin never calls it).  Instead, the init function\nsets up a callback, and passes that callback to spinhttp.Handle to register it as\nthe handler for HTTP requests.  You can learn more about this structure\nin the undefined.package main\n\nimport (\n        \"fmt\"\n        \"net/http\"\n\n        spinhttp \"github.com/fermyon/spin/sdk/go/http\"\n)\n\nfunc init() {\n        spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n                w.Header().Set(\"Content-Type\", \"text/plain\")\n                fmt.Fprintln(w, \"Hello Fermyon!\")\n        })\n}\n\nfunc main() {}{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/quickstart#create-your-first-application"},{"project":"v1","title":"Taking Spin for a spin","subheading":"Build Your Application","content":"The Spin template creates starter source code.  Now you need to turn that into a Wasm module.  The template puts build instructions for each component into the manifest.  Use the spin build command to run them:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}$ spin build\nExecuting the build command for component hello-rust: cargo build --target wasm32-wasi --release\n    Updating crates.io index\n    Updating git repository `https://github.com/spinframework/spin`\n    Updating git repository `https://github.com/bytecodealliance/wit-bindgen`\n   Compiling anyhow v1.0.69\n   Compiling version_check v0.9.4\n   # ...\n   Compiling spin-sdk v0.10.0 \n   Compiling hello-rust v0.1.0 (/home/ivan/testing/start/hello_rust)\n    Finished release [optimized] target(s) in 11.94s\nSuccessfully ran the build command for the Spin components.If the build fails, check:undefinedundefinedundefinedIf you would like to know what build command Spin runs for a component, you can find it in the manifest, in the component.build section:[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"You can always run this command manually; spin build is a shortcut to save you having to remember it.{{ blockEnd }}{{ startTab \"TypeScript\"}}As normal for NPM projects, before you build for the first time, you must run npm install:$ npm install\n\nadded 134 packages, and audited 135 packages in 2s\n\n18 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilitiesThen run spin build:$ spin build\nExecuting the build command for component hello-typescript: npm run build\n\n> hello-typescript@1.0.0 build\n> npx webpack --mode=production && mkdir -p target && spin js2wasm -o target/spin-http-js.wasm dist/spin.js\n\nasset spin.js 4.57 KiB [emitted] (name: main)\nruntime modules 670 bytes 3 modules\n./src/index.ts 2.85 KiB [built] [code generated]\nwebpack 5.75.0 compiled successfully in 1026 ms\n\nStarting to build Spin compatible module\nPreinitiating using Wizer\nOptimizing wasm binary using wasm-opt\nSpin compatible module built successfully\nSuccessfully ran the build command for the Spin components.If the build fails, check:undefinedundefinedundefinedIf you would like to know what build command Spin runs for a component, you can find it in the manifest, in the component.build section:[component.build]\ncommand = \"npm run build\"You can always run this command manually; spin build is a shortcut.{{ blockEnd }}{{ startTab \"Python\"}}$ spin build\nExecuting the build command for component hello-python: spin py2wasm app -o app.wasm\nSpin-compatible module built successfully\nSuccessfully ran the build command for the Spin components.If the build fails, check:undefinedundefinedIf you would like to know what build command Spin runs for a component, you can find it in the manifest, in the component.build section:[component.build]\ncommand = \"spin py2wasm app -o app.wasm\"You can always run this command manually; spin build is a shortcut.{{ blockEnd }}{{ startTab \"TinyGo\"}}$ spin build\nExecuting the build command for component hello-go: tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\ngo: downloading github.com/fermyon/spin/sdk/go v0.10.0\nSuccessfully ran the build command for the Spin components.If the build fails, check:undefinedundefinedundefinedundefinedIf you would like to know what build command Spin runs for a component, you can find it in the manifest, in the component.build section:[component.build]\ncommand = \"tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"You can always run this command manually; spin build is a shortcut to save you having to remember it.{{ blockEnd }}{{ blockEnd }}undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/quickstart#build-your-application"},{"project":"v1","title":"Taking Spin for a spin","subheading":"Run Your Application","content":"Now that you have created the application and built the component, you can undefined\nthe application (pun intended):$ spin up\nServing http://127.0.0.1:3000\nAvailable Routes:\n  hello-typescript: http://127.0.0.1:3000 (wildcard)If you would like to see what Spin is doing under the hood, set the RUST_LOG environment variable for detailed logs, before running spin up:$ export RUST_LOG=spin=traceundefinedSpin instantiates all components from the application manifest, and\ncreates the router configuration for the HTTP trigger according to the routes in the manifest. The\ncomponent can now be invoked by making requests to http://localhost:3000/\n(or any path under that, since it's a wildcard):$ curl -i localhost:3000\nHTTP/1.1 200 OK\nfoo: bar\ncontent-length: 14\ndate: Thu, 02 Mar 2023 00:05:42 GMT\n\nHello, FermyonundefinedCongratulations! You just created, built and ran your first Spin application!","keywords":"","subsectionKeywords":"","url":"/v1/quickstart#run-your-application"},{"project":"v1","title":"Taking Spin for a spin","subheading":"Next Steps","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/quickstart#next-steps"},{"project":"v1","title":"Relational Database Storage","subheading":"","content":"undefinedSpin provides two interfaces for relational (SQL) databases:undefinedundefinedThis page covers the \"bring your own database\" scenario.  See undefined for the built-in service.{{ details \"Why do I need a Spin interface? Why can't I just use my language's database libraries?\" \"The current version of the WebAssembly System Interface (WASI) doesn't provide a sockets interface, so database libraries that depend on sockets can't be built to Wasm. The Spin interface means Wasm modules can bypass this limitation by asking Spin to make the database connection on their behalf.\" }}","subsectionKeywords":"","url":"/v1/rdbms-storage"},{"project":"v1","title":"Relational Database Storage","subheading":"Using MySQL and PostgreSQL From Applications","content":"The Spin SDK surfaces the Spin MySQL and PostgreSQL interfaces to your language. The set of operations is the same across both databases:| Operation  | Parameters                          | Returns             | Behavior |\n|------------|-------------------------------------|---------------------|----------|\n| query    | address, statement, SQL parameters  | database records    | Runs the specified statement against the database, returning the query results as a set of rows. |\n| execute  | address, statement, SQL parameters  | integer (not MySQL) | Runs the specified statement against the database, returning the number of rows modified by the statement.  (MySQL does not return the modified row count.) |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}MySQL functions are available in the spin_sdk::mysql module, and PostgreSQL functions in the spin_sdk::pg module. The function names match the operations above. This example shows MySQL:use spin_sdk::mysql::{self, Decode, ParameterValue};\n\nlet params = vec![ParameterValue::Int32(id)];\nlet rowset = mysql::query(&address, \"SELECT id, name FROM pets WHERE id = ?\", &params)?;\n\nmatch rowset.rows.first() {\n    None => /* no rows matched query */,\n    Some(row) => {\n        let name = String::decode(&row[1])?;\n    }\n}undefinedundefinedundefinedundefinedundefinedundefinedYou can find complete examples for using relational databases in the Spin repository on GitHub (undefined, undefined).{{ blockEnd }}{{ startTab \"TypeScript\"}}The JavaScript/TypeScript SDK doesn't surface the MySQL or PostgreSQL APIs. However, you can use hosted relational database services that are accessible over HTTP. For an example, see the JavaScript SDK repository on GitHub (undefined, undefined).{{ blockEnd }}{{ startTab \"Python\"}}The Python SDK doesn't currently surface the MySQL or PostgreSQL APIs.{{ blockEnd }}{{ startTab \"TinyGo\"}}The Go SDK doesn't currently surface the MySQL or PostgreSQL APIs.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/rdbms-storage#using-mysql-and-postgresql-from-applications"},{"project":"v1","title":"Redis Storage","subheading":"","content":"undefinedSpin provides an interface for you to read and write the Redis key/value store, and to publish Redis pub-sub messages.{{ details \"Why do I need a Spin interface? Why can't I just use my language's Redis library?\" \"The current version of the WebAssembly System Interface (WASI) doesn't provide a sockets interface, so Redis libraries that depend on sockets can't be built to Wasm. The Spin interface means Wasm modules can bypass this limitation by asking Spin to make the Redis connection on their behalf.\" }}","subsectionKeywords":"","url":"/v1/redis-outbound"},{"project":"v1","title":"Redis Storage","subheading":"Using Redis From Applications","content":"The Spin SDK surfaces the Spin Redis interface to your language. The set of operations is common across all SDKs:| Operation  | Parameters | Returns | Behavior |\n|------------|------------|---------|----------|\n| Single value operations                      |\n| get        | address, key        | bytes   | Returns the value of key. If the key does not exist, returns a zero-length array. |\n| set        | address, key, bytes | -       | Sets the value of key, overwriting any existing value. |\n| incr       | address, key        | integer | Increments the value at key by 1. If the key does not exist, its value is set to 0 first (and immediately incremented to 1). If the current value isn't an integer, or a string that represents an integer, it errors and the value is not changed. |\n| del        | address, list of keys | -     | Removes the specified keys. Keys that don't exist are ignored (they do undefined cause an error). |\n| Set value operations                         |\n| sadd       | address, key, list of strings | integer | Adds the strings to the set of values of key, and returns the number of newly added values. If the key does not exist, its value is set to the set of values |\n| smembers   | address, key        | list of strings | Returns the set of values of key. if the key does not exist, this is an empty set. |\n| srem       | address, key, list of strings | integer | Removes the strings from the set of values of key, and returns the number of newly removed values. If the key does not exist, this does nothing. |\n| Pub-sub operations                           |\n| publish    | address, channel, bytes | - | Publishes a message to the specified channel, with the specified payload bytes. |\n| General operations                           |\n| execute    | address, command, list of argument values | list of results | Executes the specified command with the specified arguments. This is a general-purpose 'escape hatch' if you need a command that isn't covered by the built-in operations. |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}Redis functions are available in the spin_sdk::redis module. The function names match the operations above. For example:use spin_sdk::redis;\n\nlet value = redis::get(&address, &key)?;undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedYou can find a complete Rust code example for using outbound Redis from an HTTP component in the undefined. Please also see this, related, undefined.{{ blockEnd }}{{ startTab \"TypeScript\"}}Redis functions are available on the Redis object. The function names match the operations above. For example:import {Redis} from \"@fermyon/spin-sdk\"\n\nconst value = Redis.get(address, key);undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedYou can find a complete TypeScript example for using outbound Redis from an HTTP component in the undefined. Please also see this, related, undefined.{{ blockEnd }}{{ startTab \"Python\"}}Redis functions are available in the spin_redis module. The function names are prefixed redis_. For example:from spin_redis import redis_get\n\nvalue = redis_get(address, key)undefinedundefinedundefinedundefinedundefinedundefinedYou can find a complete Python code example for using outbound Redis from an HTTP component in the undefined. Please also see this, related, undefined.{{ blockEnd }}{{ startTab \"TinyGo\"}}Redis functions are available in the github.com/fermyon/spin/sdk/go/redis package. undefined. The function names are TitleCased. For example:import (\n\t\"github.com/fermyon/spin/sdk/go/redis\"\n)\n\npayload, err := redis.Get(address, key)undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedYou can find a complete TinyGo example for using outbound Redis from an HTTP component in the undefined. Please also see this, related, undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/redis-outbound#using-redis-from-applications"},{"project":"v1","title":"The Spin Redis trigger","subheading":"","content":"undefinedundefinedundefinedundefinedPub-sub (publish-subscribe) messaging is a popular architecture for asynchronous message processing. Spin has built-in support to creating and running applications in response to messages on undefined.The Redis trigger in Spin subscribes to messages from a given Redis instance, and dispatches those messages to components for handling.undefined","subsectionKeywords":"","url":"/v1/redis-trigger"},{"project":"v1","title":"The Spin Redis trigger","subheading":"Specifying an Application as Redis","content":"Every Spin application has a trigger specified in the manifest, which declares the type of events it responds to.\nFor Redis applications, the application trigger has type = \"redis\":# spin.toml\ntrigger = { type = \"redis\", address = \"redis://localhost:6379\" }The Redis trigger also requires an address field.  This is the address of the Redis instance to monitor.  Specify it using the redis: URL scheme.undefinedBy default, Spin does not authenticate to Redis. You can work around this by providing a password in the redis:// URL.  For example: address = \"redis://:p4ssw0rd@localhost:6379\"undefinedundefinedIn addition, each component must have Redis-specific configuration in its [component.trigger] table.","keywords":"","subsectionKeywords":"","url":"/v1/redis-trigger#specifying-an-application-as-redis"},{"project":"v1","title":"The Spin Redis trigger","subheading":"Mapping a Channel to a Component","content":"Each component handles one channel, specified in the channel field of the component trigger table.  For example, Spin will trigger this component when it receives a message on the purchaseorders channel:[component.trigger]\nchannel = \"purchaseorders\"undefined","keywords":"","subsectionKeywords":"","url":"/v1/redis-trigger#mapping-a-channel-to-a-component"},{"project":"v1","title":"The Spin Redis trigger","subheading":"Redis Components","content":"Spin runs Redis components using the undefined.  In this model, the Wasm module exports a well-known function that Spin calls to handle the Redis message.","keywords":"","subsectionKeywords":"","url":"/v1/redis-trigger#redis-components"},{"project":"v1","title":"The Spin Redis trigger","subheading":"The Message Handler","content":"The exact signature of the Redis handler, and how a function is identified to be exported as the handler, will depend on your language.{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}In Rust, the handler is identified by the #[spin_sdk::redis_component] attribute.  It takes a bytes::Bytes, representing the raw payload of the Redis message, and returns an anyhow::Result indicating success or an error with details.  This example just logs the payload as a string:use anyhow::Result;\nuse bytes::Bytes;\nuse spin_sdk::redis_component;\nuse std::str::from_utf8;\n\n/// A simple Spin Redis component.\n#[redis_component]\nfn on_message(message: Bytes) -> Result<()> {\n    println!(\"{}\", from_utf8(&message)?);\n    Ok(())\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}The JavaScript/TypeScript SDK doesn't currently support Redis components.  Please undefined if this is important to you.{{ blockEnd }}{{ startTab \"Python\"}}The Python SDK doesn't currently support Redis components.  Please undefined if this is important to you.{{ blockEnd }}{{ startTab \"TinyGo\"}}In Go, you register the handler as a callback in your program's init function.  Call redis.Handle (from the Spin SDK redis package), passing your handler as the sole argument.  Your handler takes a single byte slice ([]byte) argument, and may return an error or nil.undefinedThis example just logs the payload as a string:package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/fermyon/spin/sdk/go/redis\"\n)\n\nfunc init() {\n\tredis.Handle(func(payload []byte) error {\n\t\tfmt.Println(string(payload))\n\t\treturn nil\n\t})\n}\n\nfunc main() {}{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/redis-trigger#the-message-handler"},{"project":"v1","title":"The Spin Redis trigger","subheading":"Inside Redis Components","content":"For the most part, you'll build Redis component modules using a language SDK (see the Language Guides section), such as a Rust crate or Go package.  If you're interested in what happens inside the SDK, or want to implement Redis components in another language, read on!undefinedThe Redis component interface is defined using a WebAssembly Interface (WIT) file.  (undefined).  You can find the latest WITs for Spin Redis components at undefined.The core Redis types are defined in undefined, though note that not all of these are used in the pub-sub Redis trigger:// General purpose error.\nenum error {\n    success,\n    error,\n}\n\n// The message payload.\ntype payload = list<u8>\n\n// Remaining types are not used in the triggerundefinedThe entry point for Spin Redis components is then defined in undefined:// wit/ephemeral/spin-redis.wit\n\nuse * from redis-types\n\n// The entry point for a Redis handler.\nhandle-redis-message: func(message: payload) -> expected<unit, error>This is the function signature that all Redis components must implement, and\nwhich is used by Spin when instantiating and invoking the component.This interface (spin-redis.wit) can be directly used together with the\nundefined\nto build a component that Spin can invoke.This is exactly how Spin SDKs, such as the undefined and undefined SDKs, are built.\nAs more languages add support for the component model, we plan to add support for them in the same way.undefined","keywords":"","subsectionKeywords":"","url":"/v1/redis-trigger#inside-redis-components"},{"project":"v1","title":"Spin Apps in Registries","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v1/registry-tutorial"},{"project":"v1","title":"Spin Apps in Registries","subheading":"Spin Registry Support","content":"With Spin's registry support, you can package and save your Spin application as an artifact in a registry like undefined or undefined and then run your Spin app from these registries.","keywords":"","subsectionKeywords":"","url":"/v1/registry-tutorial#spin-registry-support"},{"project":"v1","title":"Spin Apps in Registries","subheading":"Prerequisites","content":"First, follow undefined to ensure you have the latest version of Spin installed (this tutorial refers to Spin 1.0 and above). You can check the Spin version using the following command:$ spin --version","keywords":"","subsectionKeywords":"","url":"/v1/registry-tutorial#prerequisites"},{"project":"v1","title":"Spin Apps in Registries","subheading":"Publishing and Running Spin Applications Using Registries (Video)","content":"The following video shows you how to push a Spin app to GHCR, and then run that artifact with Spin or with Docker. The video also contains additional information about signing and verifying your GHCR artifacts.The rest of this page shows you how to use GHCR artifacts locally with Spin.","keywords":"","subsectionKeywords":"","url":"/v1/registry-tutorial#publishing-and-running-spin-applications-using-registries-video"},{"project":"v1","title":"Spin Apps in Registries","subheading":"Set Up Your GHCR Instance","content":"To use a GHCR instance, you need to set up authentication. Follow undefined to generate a personal access token and then use it to sign into your GHCR. You should see the following message to confirm your login attempt to GHCR was successful:> Login Succeed","keywords":"","subsectionKeywords":"","url":"/v1/registry-tutorial#set-up-your-ghcr-instance"},{"project":"v1","title":"Spin Apps in Registries","subheading":"Push a Spin App to GHCR","content":"Let's use this full-stack undefined to walk through this tutorial. If you have a Spin app already feel free to navigate to that directory and skip the step below.Fork and clone the app undefined:$ git clone https://github.com/USERNAME/spin-react-fullstack.gitNow, switch to that directory and rebuild the application:$ cd spin-react-fullstack\n$ spin buildNow we're ready to push the application. Run the spin registry push command to push your application to the registry:$ spin registry push ghcr.io/USERNAME/spin-react-fullstack:v1undefinedYou now have a Spin application stored in your registry. You can see the artifact under packages in the undefined.","keywords":"","subsectionKeywords":"","url":"/v1/registry-tutorial#push-a-spin-app-to-ghcr"},{"project":"v1","title":"Spin Apps in Registries","subheading":"Pull a Spin App From GHCR","content":"Now that we've successfully pushed a Spin app, let's see if we can pull it. To do so, run the following command:$ spin registry pull ghcr.io/USERNAME/spin-react-fullstack:v1","keywords":"","subsectionKeywords":"","url":"/v1/registry-tutorial#pull-a-spin-app-from-ghcr"},{"project":"v1","title":"Spin Apps in Registries","subheading":"Run a Spin App From GHCR","content":"Lastly, let's run this Spin application:$ spin up -f ghcr.io/USERNAME/spin-react-fullstack:v1","keywords":"","subsectionKeywords":"","url":"/v1/registry-tutorial#run-a-spin-app-from-ghcr"},{"project":"v1","title":"Spin Apps in Registries","subheading":"Conclusion","content":"Congratulations on completing this tutorial! You have now successfully built, pushed, pulled, and run a Spin app using GHCR. Behind the scenes, Spin uses undefined project to distribute Spin apps across container registries. To learn more about how this feature works, take a look at undefined and undefined.","keywords":"","subsectionKeywords":"","url":"/v1/registry-tutorial#conclusion"},{"project":"v1","title":"Spin Apps in Registries","subheading":"Next Steps","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v1/registry-tutorial#next-steps"},{"project":"v1","title":"Running Spin Applications","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedOnce you have created and built your application, it's ready to run.  To run an application, use the spin up command.","subsectionKeywords":"","url":"/v1/running-apps"},{"project":"v1","title":"Running Spin Applications","subheading":"Specifying the Application to Run","content":"By default, spin up looks for a file named spin.toml in the current directory.If your manifest is named something different, or isn't in your current directory, use the -f (--from) flag. You also use -f to run remote applications.| -f Value                      | spin up Behavior  |\n|---------------------------------|---------------------|\n| File name: -f demo.toml       | Runs the specified manifest file |\n| Directory name: -f demo/      | Looks for a spin.toml file in that directory and runs that |\n| Registry reference: -f ghcr.io/fermyon/example:v1 | Pulls the application from the registry and runs that |undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/running-apps#specifying-the-application-to-run"},{"project":"v1","title":"Running Spin Applications","subheading":"Testing HTTP Applications","content":"By default, HTTP applications listen on localhost:3000.  You can override this with the --listen option.  Spin prints links to the application components to make it easy to open them in the browser or copy them to curl commands for testing.","keywords":"","subsectionKeywords":"","url":"/v1/running-apps#testing-http-applications"},{"project":"v1","title":"Running Spin Applications","subheading":"Application Output","content":"By default, Spin prints application output, and any of its own error messages, to the console.To hide application output, pass the --quiet flag:$ spin up --quietTo limit application output to specific components, pass the --follow flag:$ spin up --follow cart --follow cart-api","keywords":"","subsectionKeywords":"","url":"/v1/running-apps#application-output"},{"project":"v1","title":"Running Spin Applications","subheading":"Persistent Logs","content":"By default:undefinedundefinedTo control logging, pass the --log-dir flag.  The logs will be saved to the specified directory (no matter whether the application is local or remote).$ spin up --log-dir ~/dev/bugbash","keywords":"","subsectionKeywords":"","url":"/v1/running-apps#persistent-logs"},{"project":"v1","title":"Running Spin Applications","subheading":"Trigger-Specific Options","content":"Some trigger types support additional spin up flags.  For example, HTTP applications can have a --listen flag to specify an address and port to listen on.  See the undefined and undefined pages for more details.","keywords":"","subsectionKeywords":"","url":"/v1/running-apps#trigger-specific-options"},{"project":"v1","title":"Running Spin Applications","subheading":"Monitoring Applications for Changes","content":"Spin's watch command rebuilds and restarts Spin applications whenever files change. You can use the spin watch undefined in place of the spin build and spin up commands, to build, run and then keep your Spin application running without manual intervention while staying on the latest code and files.undefinedBy default, Spin watch monitors:undefinedundefinedundefinedundefinedIf any of these change, Spin will rebuild the application if necessary, then restart the application with the new files.undefinedThe following spin.toml configuration (belonging to a Spin http-rust application) is configured to ensure that the application is both undefined (via cargo build --target wasm32-wasi --release) and undefined whenever changes occur in any Rust source (.rs) files, the Cargo.toml file or the spin.toml file, itself. When changes occur in either the Wasm binary file (target/wasm32-wasi/release/test.wasm) or the text file (my-files/changing-file.txt) the application is only undefined using the initial spin up command:[[component]]\n// -- snip\nfiles = [\"my-files/changing-file.txt\"]\nsource = \"target/wasm32-wasi/release/test.wasm\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\n# Example watch configuration for a Rust application\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]If the build section specifies a workdir, then watch patterns are relative to that directory. Otherwise, watch patterns are relative to the directory containing the spin.toml file.If you would prefer Spin watch to only rerun the application (without a rebuild) when changes occur, you can use the --skip-build option when running the spin watch command.  In this case, Spin will ignore the component.build.watch section, and monitor only the spin.toml, component.source and component.files.The table below outlines exactly which files spin watch will monitor for changes depending on how you run the command. spin watch uses the configuration found on every component in your application.| Files                   | spin watch monitors for changes              | spin watch --skip-build monitors for changes |\n| ----------------------- | ---------------------------------------------- | ---------------------------------------------- |\n| Application manifest spin.toml   | Yes                                            | Yes                                            |\n| component.build.watch | Yes                                            | No                                             |\n| component.files       | Yes                                            | Yes                                            |\n| component.source      | No (Yes if the component has no build command) | YesSpin watch waits up to 100 milliseconds before responding to filesystem events, then processes all events that occurred in that interval together. This is so that if you make several changes close together (for example, using a Save All command), you get them all processed in one rebuild/reload cycle, rather than going through a cycle for each one. You can override the interval by passing in the --debounce option; e.g. spin watch --debounce 1000 will make Spin watch respond to filesystem events at most once per second.undefinedPassing the --clear flag clears the screen anytime a rebuild or rerun occurs. Spin watch does not clear the screen between rebuild and rerun as this provides you with an opportunity to see any warnings.For additional information about Spin's watch feature, please see the undefined blog article.","keywords":"","subsectionKeywords":"","url":"/v1/running-apps#monitoring-applications-for-changes"},{"project":"v1","title":"Running Spin Applications","subheading":"Next Steps","content":"undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/running-apps#next-steps"},{"project":"v1","title":"Building Spin components in Rust","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedSpin aims to have best-in-class support for building components in Rust, and\nwriting such components should be familiar for Rust developers.undefinedundefinedundefined","subsectionKeywords":"","url":"/v1/rust-components"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Prerequisites","content":"","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#prerequisites"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Install the Templates","content":"You don't need the Spin Rust templates to work on Rust components, but they speed up creating new applications and components.  You can install them as follows:$ spin templates install --git https://github.com/spinframework/spin --update\nCopying remote template source\nInstalling template redis-rust...\nInstalling template http-rust...\n... other templates omitted ...\n+------------------------------------------------------------------------+\n| Name                Description                                        |\n+========================================================================+\n| ... other templates omitted ...                                        |\n| http-rust           HTTP request handler using Rust                    |\n| redis-rust          Redis message handler using Rust                   |\n| ... other templates omitted ...                                        |\n+------------------------------------------------------------------------+Note: The Rust templates are in a repo that contains several other languages; they will all be installed together.","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#install-the-templates"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Install the Tools","content":"To build Spin components, you'll need the wasm32-wasi target for Rust.$ rustup target add wasm32-wasiundefined","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#install-the-tools"},{"project":"v1","title":"Building Spin components in Rust","subheading":"HTTP Components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, but Rust has improved support\nfor writing Spin components with the Spin Rust SDK.undefinedBuilding a Spin HTTP component using the Rust SDK means writing a single function\nthat takes an HTTP request as a parameter, and returns an HTTP response — below\nis a complete implementation for such a component:use anyhow::Result;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n};\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn hello_world(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req);\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(\"Hello, Fermyon!\".into()))?)\n}The important things to note in the implementation above:undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#http-components"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Redis Components","content":"Besides the HTTP trigger, Spin has built-in support for a Redis trigger —\nwhich will connect to a Redis instance and will execute Spin components for\nnew messages on the configured channels.undefinedWriting a Redis component in Rust also takes advantage of the SDK:use anyhow::Result;\nuse bytes::Bytes;\nuse spin_sdk::redis_component;\n\n/// A simple Spin Redis component.\n#[redis_component]\nfn on_message(message: Bytes) -> Result<()> {\n    println!(\"{}\", std::str::from_utf8(&message)?);\n    Ok(())\n}undefinedundefinedundefinedThe component can be built with Cargo by executing:$ cargo build --target wasm32-wasi --releaseThe manifest for a Redis application must contain the address of the Redis\ninstance the trigger must connect to:spin_manifest_version = \"1\"\nname = \"spin-redis\"\ntrigger = { type = \"redis\", address = \"redis://localhost:6379\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"echo-message\"\nsource = \"target/wasm32-wasi/release/spinredis.wasm\"\n[component.trigger]\nchannel = \"messages\"This application will connect to redis://localhost:6379, and for every new\nmessage on the messages channel, the echo-message component will be executed:# first, start redis-server on the default port 6379\n$ redis-server --port 6379\n# then, start the Spin application\n$ spin up --file spin.toml\n# the application log file will output the following\nINFO spin_redis_engine: Connecting to Redis server at redis://localhost:6379\nINFO spin_redis_engine: Subscribed component 0 (echo-message) to channel: messagesFor every new message on the  messages channel:$ redis-cli\n127.0.0.1:6379> publish messages \"Hello, there!\"Spin will instantiate and execute the component we just built, which will emit the println! message to the application log file:INFO spin_redis_engine: Received message on channel \"messages\"\nHello, there!undefined","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#redis-components"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Sending Outbound HTTP Requests","content":"If allowed, Spin components can send outbound HTTP requests.\nLet's see an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:use anyhow::Result;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n};\n\n/// Send an HTTP request and return the response.\n#[http_component]\nfn send_outbound(_req: Request) -> Result<Response> {\n    let mut res = spin_sdk::outbound_http::send_request(\n        http::Request::builder()\n            .method(\"GET\")\n            .uri(\"https://random-data-api.fermyon.app/animals/json\")\n            .body(None)?,\n    )?;\n    res.headers_mut()\n        .insert(\"spin-component\", \"rust-outbound-http\".try_into()?);\n    println!(\"{:?}\", res);\n    Ok(res)\n}undefinedBefore we can execute this component, we need to add the random-data-api.fermyon.app\ndomain to the application manifest allowed_http_hosts list containing the list of\ndomains the component is allowed to make HTTP requests to:# spin.toml\nspin_manifest_version = \"1\"\nname = \"spin-hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"hello\"\nsource = \"target/wasm32-wasi/release/spinhelloworld.wasm\"\nallowed_http_hosts = [\"random-data-api.fermyon.app\"]\n[component.trigger]\nroute = \"/outbound\"Running the application using spin up --file spin.toml will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /outbound:$ curl -i localhost:3000/outbound\nHTTP/1.1 200 OK\ndate: Fri, 18 Mar 2022 03:54:36 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 185\nserver: spin/0.1.0\n\n{\"timestamp\":1684299253331,\"fact\":\"Reindeer grow new antlers every year\"}   undefinedundefinedWe just built a WebAssembly component that sends an HTTP request to another\nservice, manipulates that result, then responds to the original request.\nThis can be the basis for building components that communicate with external\ndatabases or storage accounts, or even more specialized components like HTTP\nproxies or URL shorteners.","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#sending-outbound-http-requests"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Storing Data in Redis From Rust Components","content":"Using the Spin's Rust SDK, you can use the Redis key/value store and to publish\nmessages to Redis channels. This can be used from both HTTP and Redis triggered\ncomponents.Let's see how we can use the Rust SDK to connect to Redis:use anyhow::{anyhow, Result};\nuse spin_sdk::{\n    http::{internal_server_error, Request, Response},\n    http_component, redis,\n};\n\n// The environment variable set in `spin.toml` that points to the\n// address of the Redis server that the component will publish\n// a message to.\nconst REDIS_ADDRESS_ENV: &str = \"REDIS_ADDRESS\";\n\n// The environment variable set in `spin.toml` that specifies\n// the Redis channel that the component will publish to.\nconst REDIS_CHANNEL_ENV: &str = \"REDIS_CHANNEL\";\n\n/// This HTTP component demonstrates fetching a value from Redis\n/// by key, setting a key with a value, and publishing a message\n/// to a Redis channel. The component is triggered by an HTTP\n/// request served on the route configured in the `spin.toml`.\n#[http_component]\n\nfn publish(_req: Request) -> Result<Response> {\n    let address = std::env::var(REDIS_ADDRESS_ENV)?;\n    let channel = std::env::var(REDIS_CHANNEL_ENV)?;\n\n    // Get the message to publish from the Redis key \"mykey\"\n    let payload = redis::get(&address, \"mykey\").map_err(|_| anyhow!(\"Error querying Redis\"))?;\n\n    // Set the Redis key \"spin-example\" to value \"Eureka!\"\n    redis::set(&address, \"spin-example\", &b\"Eureka!\"[..])\n        .map_err(|_| anyhow!(\"Error executing Redis set command\"))?;\n\n    // Set the Redis key \"int-key\" to value 0\n    redis::set(&address, \"int-key\", format!(\"{:x}\", 0).as_bytes())\n        .map_err(|_| anyhow!(\"Error executing Redis set command\"))?;\n    let int_value = redis::incr(&address, \"int-key\")\n        .map_err(|_| anyhow!(\"Error executing Redis incr command\",))?;\n    assert_eq!(int_value, 1);\n\n    // Publish to Redis\n    match redis::publish(&address, &channel, &payload) {\n        Ok(()) => Ok(http::Response::builder().status(200).body(None)?),\n        Err(_e) => internal_server_error(),\n    }\n}This HTTP component demonstrates fetching a value from Redis by key, setting a\nkey with a value, and publishing a message to a Redis channel. The component is\ntriggered by an HTTP request served on the route configured in the spin.toml:[[component]]\nenvironment = { REDIS_ADDRESS = \"redis://127.0.0.1:6379\", REDIS_CHANNEL = \"messages\" }\n[component.trigger]\nroute = \"/publish\"This HTTP component can be paired with a Redis component, triggered on new\nmessages on the messages Redis channel.undefined","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#storing-data-in-redis-from-rust-components"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Storing Data in the Spin Key-Value Store","content":"Spin has a key-value store built in. For information about using it from Rust, see undefined.","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#storing-data-in-the-spin-key-value-store"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Serializing Objects to the Key-Value Store","content":"The Spin key-value API stores and retrieves only lists of bytes. The Rust SDK provides helper functions that allow you to store and retrieve undefined serializable values in a typed way. The underlying storage format is JSON (and is accessed via the get_json and set_json helpers).To use the get_json and set_json helpers, you must enable the Spin SDK's optional json feature in your Cargo.toml file. To make your objects serializable, you will also need a reference to serde. The relevant Cargo.toml entries look like this:[dependencies]\n// --snip --\nserde = {version = \"1.0.163\", features = [\"derive\"]}\nspin-sdk = {git = \"https://github.com/spinframework/spin\", version = \"1.2.0\", features = [\"json\"]}\n// --snip --The Rust code below shows how to store and retrieve serializable objects from the key-value store (note how the example below implements Serde's derive feature):use anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n    key_value::Store,\n};\n\n// Define a serializable User type\n#[derive(Serialize, Deserialize)]\nstruct User {\n    fingerprint: String,\n    location: String,\n}\n\n#[http_component]\nfn handle_request(_req: Request) -> Result<Response> {\n    // Open the default key-value store\n    let store = Store::open_default()?;\n\n    // Create an instance of a User object and populate the values\n    let user = User {\n        fingerprint: \"0x1234\".to_owned(),\n        location: \"Brisbane\".to_owned(),\n    };\n    // Store the User object using the \"my_json\" key\n    store.set_json(\"my_json\", &user)?;\n    // Retrieve the user object from the key-value store, using the \"my_json\" key\n    let retrieved_user: User = store.get_json(\"my_json\")?;\n    // Return the user's fingerprint as the response body\n    Ok(http::Response::builder()\n        .status(200)\n        .body(Some(retrieved_user.fingerprint.into()))?)\n}Once built and running (using spin build and spin up) you can test the above example in your browser (by visiting localhost:3000) or via curl, as shown below:$ curl localhost:3000\nHTTP/1.1 200 OK\n\n0x1234","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#serializing-objects-to-the-key-value-store"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Storing Data in SQLite","content":"For more information about using SQLite from Rust, see undefined.","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#storing-data-in-sqlite"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Storing Data in Relational Databases","content":"Spin provides clients for MySQL and PostgreSQL. For information about using them from Rust, see undefined.","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#storing-data-in-relational-databases"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Using External Crates in Rust Components","content":"In Rust, Spin components are regular libraries that contain a function\nannotated using the http_component macro, compiled to the wasm32-wasi target.\nThis means that any undefined that compiles to wasm32-wasi can\nbe used when implementing the component.","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#using-external-crates-in-rust-components"},{"project":"v1","title":"Building Spin components in Rust","subheading":"AI Inferencing From Rust Components","content":"For more information about using Serverless AI from Rust, see the undefined API guide.","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#ai-inferencing-from-rust-components"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Troubleshooting","content":"If you bump into issues building and running your Rust component, here are some common causes of problems:undefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#troubleshooting"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Manually Creating New Projects With Cargo","content":"The recommended way of creating new Spin projects is by starting from a template.\nThis section shows how to manually create a new project with Cargo.When creating a new Spin project with Cargo, you should use the --lib flag:$ cargo init --libA Cargo.toml with standard Spin dependencies looks like this:[package]\nname = \"your-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\n# Required to have a `cdylib` (dynamic library) to produce a Wasm module.\ncrate-type = [ \"cdylib\" ]\n\n[dependencies]\n# Useful crate to handle errors.\nanyhow = \"1\"\n# Crate to simplify working with bytes.\nbytes = \"1\"\n# General-purpose crate with common HTTP types.\nhttp = \"0.2\"\n# The Spin SDK.\nspin-sdk = { git = \"https://github.com/spinframework/spin\" }\n# Crate that generates Rust Wasm bindings from a WebAssembly interface.\nwit-bindgen-rust = { git = \"https://github.com/bytecodealliance/wit-bindgen\", rev = \"cb871cfa1ee460b51eb1d144b175b9aab9c50aba\" }undefined","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#manually-creating-new-projects-with-cargo"},{"project":"v1","title":"Building Spin components in Rust","subheading":"Read the Rust Spin SDK Documentation","content":"Although you learned a lot by following the concepts and samples shown here, you can dive even deeper and read the undefined.","keywords":"","subsectionKeywords":"","url":"/v1/rust-components#read-the-rust-spin-sdk-documentation"},{"project":"v1","title":"Built With Spin","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedSpin can be used to build many different types of applications. The following blog articles show how different applications are built with Spin.","subsectionKeywords":"","url":"/v1/see-what-people-have-built-with-spin"},{"project":"v1","title":"Built With Spin","subheading":"Like Button","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v1/see-what-people-have-built-with-spin#like-button"},{"project":"v1","title":"Built With Spin","subheading":"Social App","content":"The 'Building a Social App with Spin' series covers the process and decision-making of building an authenticated, dynamic, database-backed application and API, right the way from downloading Spin and setting up the project to deploying the finished application to the cloud.undefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/see-what-people-have-built-with-spin#social-app"},{"project":"v1","title":"Built With Spin","subheading":"Static Content Server","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v1/see-what-people-have-built-with-spin#static-content-server"},{"project":"v1","title":"Built With Spin","subheading":"Bots","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v1/see-what-people-have-built-with-spin#bots"},{"project":"v1","title":"Built With Spin","subheading":"URL Shortener and QR Code Generator","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v1/see-what-people-have-built-with-spin#url-shortener-and-qr-code-generator"},{"project":"v1","title":"Built With Spin","subheading":"Content Management System (CMS)","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v1/see-what-people-have-built-with-spin#content-management-system-cms"},{"project":"v1","title":"Built With Spin","subheading":"The Finicky Whiskers Game","content":"The 'Finicky Whiskers' series covers the journey of creating a game with an architecture designed to undefined and showcase how WebAssembly modules can be started, executed, and shut down in the blink of an eye.undefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/see-what-people-have-built-with-spin#the-finicky-whiskers-game"},{"project":"v1","title":"Built With Spin","subheading":"Accessing External APIs","content":"Chances are whatever you are building will want to talk to other endpoints on the web. If so, Spin's HTTP library can help. The following article explains how to access external APIs from within Spin applications.undefined","keywords":"","subsectionKeywords":"","url":"/v1/see-what-people-have-built-with-spin#accessing-external-apis"},{"project":"v1","title":"Built With Spin","subheading":"SQLite Storage Using Javascript","content":"Check out our undefined blog article that provides an SQLite database example (using Javascript).","keywords":"","subsectionKeywords":"","url":"/v1/see-what-people-have-built-with-spin#sqlite-storage-using-javascript"},{"project":"v1","title":"Built With Spin","subheading":"Next Steps","content":"undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/see-what-people-have-built-with-spin#next-steps"},{"project":"v1","title":"Serverless AI API","subheading":"","content":"undefinedundefinedThe nature of AI and LLM workloads on already trained models lends itself very naturally to a serverless-style architecture. As a framework for building and deploying serverless applications, Spin provides an interface for you to perform AI inference within Spin applications.","subsectionKeywords":"","url":"/v1/serverless-ai-api-guide"},{"project":"v1","title":"Serverless AI API","subheading":"Using Serverless AI From Applications","content":"","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-api-guide#using-serverless-ai-from-applications"},{"project":"v1","title":"Serverless AI API","subheading":"Configuration","content":"By default, a given component of a Spin application will not have access to any Serverless AI models. Access must be provided explicitly via the Spin application's manifest (the spin.toml file).  For example, an individual component in a Spin application could be given access to the llama2-chat model by adding the following ai_models configuration inside the specific [[component]] section:// -- snip --\n\n[[component]]\nai_models = [\"codellama-instruct\"]\n\n// -- snip --undefined","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-api-guide#configuration"},{"project":"v1","title":"Serverless AI API","subheading":"File Structure","content":"By default, the Spin framework will expect any already trained model files (which are configured as per the previous section) to be downloaded by the user and made available inside a .spin/ai-models/ file path of a given application. For example:code-generator-rs/.spin/ai-models/llama/codellama-instructSee the undefined documentation for more concrete examples of implementing the Fermyon Serverless AI API, in your favorite language.undefined","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-api-guide#file-structure"},{"project":"v1","title":"Serverless AI API","subheading":"Serverless AI Interface","content":"The Spin SDK surfaces the Serverless AI interface to a variety of different languages. See the undefined to see if your specific language is supported.The set of operations is common across all supporting language SDKs:| Operation | Parameters | Returns | Behavior |\n|:-----|:----------------|:-------|:----------------|\n| infer  | modelstring<br /> promptstring| string  | The infer is performed on a specific model.<br /> <br />The name of the model is the first parameter provided (i.e. llama2-chat, codellama-instruct, or other; passed in as a string).<br /> <br />The second parameter is a prompt; passed in as a string.<br />|\n| infer_with_options  | modelstring<br /> promptstring<br /> paramslist | string  | The infer_with_options is performed on a specific model.<br /> <br />The name of the model is the first parameter provided (i.e. llama2-chat, codellama-instruct, or other; passed in as a string).<br /><br /> The second parameter is a prompt; passed in as a string.<br /><br /> The third parameter is a mix of float and unsigned integers relating to inferencing parameters in this order: <br /><br />- max-tokens (unsigned 32 integer) Note: the backing implementation may return less tokens. <br /> Default is 100<br /><br /> - repeat-penalty (float 32) The amount the model should avoid repeating tokens. <br /> Default is 1.1<br /><br /> - repeat-penalty-last-n-token-count (unsigned 32 integer) The number of tokens the model should apply the repeat penalty to. <br /> Default is 64<br /><br /> - temperature (float 32) The randomness with which the next token is selected. <br /> Default is 0.8<br /><br /> - top-k (unsigned 32 integer) The number of possible next tokens the model will choose from. <br /> Default is 40<br /><br /> - top-p (float 32) The probability total of next tokens the model will choose from. <br /> Default is 0.9<br /><br /> The result from infer_with_options is a string |\n| generate-embeddings  | modelstring<br /> promptlist<string>| string  | The generate-embeddings is performed on a specific model.<br /> <br />The name of the model is the first parameter provided (i.e. all-minilm-l6-v2, passed in as a string).<br /> <br />The second parameter is a prompt; passed in as a list of strings.<br /><br /> The result from generate-embeddings is a two-dimension array containing float32 type values only |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}To use Serverless AI functions, the llm module from the Spin SDK provides the methods. The following snippet is from the undefined:use spin_sdk::{\n    http::{Request, Response},\n    llm,\n};\n\n// -- snip --\n\nfn handle_code(req: Request) -> Result<Response> {\n    // -- snip --\n\n    let result = llm::infer_with_options(\n        llm::InferencingModel::CodellamaInstruct,\n        &prompt,\n        llm::InferencingParams {\n            max_tokens: 400,\n            repeat_penalty: 1.1,\n            repeat_penalty_last_n_token_count: 64,\n            temperature: 0.8,\n            top_k: 40,\n            top_p: 0.9,\n        },\n    )?;\n\n    // -- snip --\t\n}\nundefinedThe infer_with_options examples, operation:undefinedundefinedundefinedundefined{{ blockEnd }}{{ startTab \"Typescript\"}}To use Serverless AI functions, the Llm module from the Spin SDK provides two methods: infer and generateEmbeddings. For example:import { EmbeddingModels, HandleRequest, HttpRequest, HttpResponse, InferencingModels, Llm} from \"@fermyon/spin-sdk\"\n\nexport const handleRequest: HandleRequest = async function (request: HttpRequest): Promise<HttpResponse> {\n    let embeddings = Llm.generateEmbeddings(EmbeddingModels.AllMiniLmL6V2, [\"someString\"])\n    console.log(embeddings.embeddings)\n    let result = Llm.infer(InferencingModels.Llama2Chat, prompt)\n    return {\n        status: 200,\n        headers: {\"content-type\":\"text/plain\"},\n        body: result.text\n    }\n}undefinedinfer operation:undefinedundefinedundefinedundefinedgenerateEmbeddings operation:undefinedundefinedundefined{{ blockEnd }}{{ startTab \"Python\"}}from spin_http import Response\nfrom spin_llm import llm_infer\n\n\ndef handle_request(request):\n    prompt=\"You are a stand up comedy writer. Tell me a joke.\"\n    result=llm_infer(\"llama2-chat\", prompt)\n    return Response(200,\n                    {\"content-type\": \"text/plain\"},\n                    bytes(result.text, \"utf-8\"))undefinedllm_infer operation:undefinedundefinedundefined{{ blockEnd }}{{ startTab \"TinyGo\"}}The TinyGo SDK doesn't currently surface the Serverless AI API.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-api-guide#serverless-ai-interface"},{"project":"v1","title":"Build your first AI app using Serverless AI Inferencing","subheading":"","content":"undefinedundefinedundefinedundefinedThis tutorial will show you how to use Fermyon Serverless AI to quickly build your first AI-enabled serverless application that can run on Fermyon Cloud.\nIn this tutorial we will:undefinedundefinedundefined","subsectionKeywords":"","url":"/v1/serverless-ai-hello-world"},{"project":"v1","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Tutorial Prerequisites","content":"","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-hello-world#tutorial-prerequisites"},{"project":"v1","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Spin","content":"You will need to undefined. Serverless AI is supported on Spin v1.5 and above\nIf you already have Spin installed, undefined if required.","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-hello-world#spin"},{"project":"v1","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Dependencies","content":"undefined\nThe above installation script automatically installs the latest SDKs for Rust, which enables Serverless AI functionality.undefinedTo enable Serverless AI functionality via TypeScript/Javascript, please ensure you have the latest TypeScript/JavaScript template installed:$ spin templates install --git <https://github.com/spinframework/spin-js-sdk> --upgradeundefinedTo enable Serverless AI functionality via Python, please ensure you have the latest Python plugin and template installed:$ spin plugins update\n$ spin plugins install py2wasm\n$ spin templates install --git https://github.com/spinframework/spin-python-sdk --upgrade","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-hello-world#dependencies"},{"project":"v1","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Licenses","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-hello-world#licenses"},{"project":"v1","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Serverless AI Inferencing With Spin","content":"Now, let's write your first Serverless AI application with Spin.","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-hello-world#serverless-ai-inferencing-with-spin"},{"project":"v1","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Creating a New Spin Application","content":"{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}The Rust code snippets below are taken from the undefined.$ spin new http-rust\nEnter a name for your new application: hello-world\nDescription: My first Serverless AI app\nHTTP base: /\nHTTP path: /...{{ blockEnd }}{{ startTab \"Python\" }}The Python code snippets below are taken from the undefined.$ spin new http-py\nEnter a name for your new application: hello-world\nDescription: My first Serverless AI app\nHTTP base: /\nHTTP path: /...{{ blockEnd }}{{ startTab \"TypeScript\" }}The TypeScript code snippets below are taken from the undefined.$ spin new http-ts\nEnter a name for your new application: hello-world\nDescription: My first Serverless AI app\nHTTP base: /\nHTTP path: /...{{ blockEnd }}\n{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-hello-world#creating-a-new-spin-application"},{"project":"v1","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Configuring Your Application","content":"The spin.toml file is the manifest file which tells Spin what events should trigger what components. Configure the [[component]] section of our application's manifest explicitly naming our model of choice. For this example, we specify the llama2-chat value for our ai_models configuration:ai_models = [\"llama2-chat\"]This is what your spin.toml file should look like, based on whether you’re using Rust, TypeScript or Python:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\nname = \"hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n[[component]]\nid = \"hello-world\"\nsource = \"target/wasm32-wasi/release/hello-world.wasm\"\nallowed_http_hosts = []\nai_models = [\"llama2-chat\"]\nkey_value_stores = [\"default\"]\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]{{ blockEnd }}{{ startTab \"TypeScript\" }}spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\nname = \"hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n[[component]]\nid = \"hello-world\"\nsource = \"target/hello-world.wasm\"\nexclude_files = [\"**/node_modules\"]\nai_models = [\"llama2-chat\"]\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"npm run build\"\nwatch = [\"src/index.ts\"]{{ blockEnd }}{{ startTab \"Python\" }}spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\nname = \"hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"  \n[[component]]\nid = \"hello-world\"\nsource = \"target/hello-world.wasm\"\nexclude_files = [\"**/node_modules\"]\nai_models = [\"llama2-chat\"]\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"spin py2wasm app -o app.wasm\"\nwatch = [\"app.py\", \"Pipfile\"]{{ blockEnd }}\n{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-hello-world#configuring-your-application"},{"project":"v1","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Source Code","content":"Now let's use the Spin SDK to access the model from our app. Executing inference from a LLM is a single line of code. Add the Llm and the InferencingModels to your app and use the Llm.infer to execute an inference. Here’s how the code looks:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}use anyhow::{Context, Result};\nuse spin_sdk::{\n   http::{Request, Response},\n   http_component, llm,\n};\n/// A simple Spin HTTP component.\n#[http_component]\nfn hello_world(_req: Request) -> Result<Response> {\n   let model = llm::InferencingModel::Llama2Chat;\n   let inference = llm::infer(model, \"Can you tell me a joke about cats\".into());\n   Ok(http::Response::builder()\n       .status(200)\n       .body(Some(format!(\"{:?}\", inference).into()))?)\n}  {{ blockEnd }}{{ startTab \"TypeScript\"}}import { Llm, InferencingModels, HandleRequest, HttpRequest, HttpResponse } from  \"@fermyon/spin-sdk\"\nconst  model = InferencingModels.Llama2Chat\nexport  const  handleRequest: HandleRequest = async  function (request: HttpRequest): Promise<HttpResponse> {\nconst  prompt = \"Can you tell me a joke about cats\"\nconst  out = Llm.infer(model, prompt)\nreturn {\n\tstatus:  200,\n\tbody:  out.text\n\t}\n}{{ blockEnd }}{{ startTab \"Python\"}}from spin_http import Response\nfrom spin_llm import llm_infer\nimport json\nimport re\n\ndef handle_request(request):\n    try:\n        result = llm_infer(\"llama2-chat\", \"Can you tell me a joke abut cats\")\n        return Response(200, {\"content-type\": \"text/plain\"}, bytes(result.text, \"utf-8\"))\n    except Exception as e:\n        return Response(500, {\"content-type\": \"text/plain\"}, bytes(f\"Error: {str(e)}\", \"utf-8\"))\n\n{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-hello-world#source-code"},{"project":"v1","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Building and Deploying Your Spin Application","content":"Now that you have written your first Serverless AI app, it’s time to build and deploy it. To build your app run the following commands from inside your app’s folder (where the spin.toml file is located):{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}$ spin build{{ blockEnd }}{{ startTab \"TypeScript\" }}\n$ npm install\n$ spin build\n{{ blockEnd }}\n{{ startTab \"Python\" }}\n$ spin build\n{{ blockEnd }}Now that your app is built, there are three ways to test your Serverless AI app. One way to test the app is to run inferencing locally. This means running a LLM on your CPU. This is not as optimal compared to deploying to Fermyon’s Serverless AI, which uses high-powered GPUs in the cloud. To know more about this method, including downloading LLMs to your local machine, check out undefined on Building a Sentiment Analysis API using Serverless AI.Here are the two other methods for testing your app:undefinedYou can deploy the app to the cloud by using the spin deploy command. In case you have not logged into your account before deploying your application, you need to grant access via a one-time token. Follow the instructions in the prompt to complete the auth process.Once you have logged in and the app is deployed, you will see a URL, upon successful deployment. The app is now deployed and can be accessed by anyone with the URL:$ spin deploy\n\n>Uploading hello-world version 0.1.0+ra01f74e2...\nDeploying...\nWaiting for application to become ready...... ready\nAvailable Routes:\nhello-world: https://hello-world-XXXXXX.fermyon.app (wildcard)The app’s manifest file reads the line ai_models = [\"llama2-chat\"] and uses that model in the cloud. For any changes to take effect in the app, it needs to be re-deployed to the cloud.undefinedTo avoid having to deploy the app for every change, you can use the undefined to deploy locally, with the LLM running in the cloud. While the app is hosted locally (running on localhost), every inferencing request is sent to the LLM that is running in the cloud. Follow the steps to use the cloud-gpu plugin.undefined: This plugin works only with spin v1.5.1 and above.First, install the plugin using the command:$ spin plugins install -u https://github.com/spinframework/spin-cloud-gpu/releases/download/canary/cloud-gpu.json -yLet’s initialize the plugin. This command essentially deploys the Spin app to a Cloud GPU proxy and generates a runtime-config:$ spin cloud-gpu init\n\n[llm_compute]\ntype = \"remote_http\"\nurl = \"https://fermyon-cloud-gpu-<AUTO_GENERATED_STRING>.fermyon.app\"\nauth_token = \"<AUTO_GENERATED_TOKEN>\"In the root of your Spin app directory, create a file named runtime-config.toml and paste the runtime-config generated in the previous step.Now you are ready to test the Serverless AI app locally, using a GPU that is running in the cloud. To deploy the app locally you can use spin up (or spin watch) but with the following flag:$ spin up --runtime-config-file <path/to/runtime-config.toml>\n\nLogging component stdio to  \".spin/logs/\"\nServing http://127.0.0.1:3000\nAvailable Routes:\nhello-world: http://127.0.0.1:3000 (wildcard)","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-hello-world#building-and-deploying-your-spin-application"},{"project":"v1","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Next Steps","content":"This was just a small example of what Serverless AI Inferencing can do. To check out more detailed code samples:undefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/serverless-ai-hello-world#next-steps"},{"project":"v1","title":"Application Structure","subheading":"","content":"As mentioned in this undefined, we are often asked about how to structure Spin applications that involve multiple source code components. There are a few nuances to this discussion, such as the use of different application trigger types and how to modify an existing application's structure. These nuances are discussed in the blog post and also in undefined. This page, however, will focus only on creating multi-component Spin applications from scratch using the http-empty template. This template serves as the foundation for the recommended Spin application structure when creating applications that respond to HTTP requests.","keywords":"structure","subsectionKeywords":"","url":"/v1/spin-application-structure"},{"project":"v1","title":"Application Structure","subheading":"Recommended Application Structure","content":"If we start with a blank canvas and use the http-empty template we will get a new Spin application:$ spin new http-empty\nEnter a name for your new application: myapp\nDescription: My application\nHTTP base: /The above command will provide an empty structure, as shown below:└── myapp\n    └── spin.tomlTo add new components to the application, we simply move into the myapp directory and begin to add components using the spin add subcommand:$ spin add http-rust\nEnter a name for your new component: first-http-rust-component\nDescription: The first of many new components\nHTTP path: /first/...\n$ spin add http-rust\nEnter a name for your new component: second-http-rust-component\nDescription: The second of many new components\nHTTP path: /second/...After adding two new components, we can see the visual representation of our application. Notice the symmetry; there is no hierarchy or nesting of components:.\n├── first-http-rust-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n├── second-http-rust-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.tomlTo customize each of the two components, we can modify the lib.rs (Rust source code) of each component:/// A simple Spin HTTP component.\n#[http_component]\nfn handle_first_http_rust_component(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req.headers());\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(\"Hello, First Component\".into()))?)\n}/// A simple Spin HTTP component.\n#[http_component]\nfn handle_second_http_rust_component(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req.headers());\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(\"Hello, Second Component\".into()))?)\n}As an additional example of adding more components, let's add a new static file server component:$ spin add static-fileserver\nEnter a name for your new component: assets\nHTTP path: /static/...\nDirectory containing the files to serve: assetsAfter the static file server component is added, we create the assets directory (our local directory containing the files to serve) and then add some static content into the assets directory to be served:$ mkdir assets\n$ cp ~/Desktop/my-static-image.jpg assets\n$ cp ~/Desktop/old.txt assets\n$ cp ~/Desktop/new.txt assetsundefinedWhy stop there? We can add even more functionality to our application. Let's now add a redirect component to redirect requests made to /static/old.txt and forward those through to /static/new.txt:$ spin add redirect\nEnter a name for your new component: additional-component-redirect\nRedirect from: /static/old.txt\nRedirect to: /static/new.txtWe now have 4 separate components scaffolded for us by Spin. Note the application manifest (the spin.toml file) is correctly configured based on our spin add commands:spin_manifest_version = \"1\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My application\"\nname = \"myapp\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"first-http-rust-component\"\nsource = \"first-http-rust-component/target/wasm32-wasi/release/first_http_rust_component.wasm\"\nallowed_http_hosts = []\n[component.trigger]\nroute = \"/first/...\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nworkdir = \"first-http-rust-component\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]\n\n[[component]]\nid = \"second-http-rust-component\"\nsource = \"second-http-rust-component/target/wasm32-wasi/release/second_http_rust_component.wasm\"\nallowed_http_hosts = []\n[component.trigger]\nroute = \"/second/...\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nworkdir = \"second-http-rust-component\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]\n\n[[component]]\nsource = { url = \"https://github.com/spinframework/spin-fileserver/releases/download/v0.0.2/spin_static_fs.wasm\", digest = \"sha256:65456bf4e84cf81b62075e761b2b0afaffaef2d0aeda521b245150f76b96421b\" }\nid = \"assets\"\nfiles = [ { source = \"assets\", destination = \"/\" } ]\n[component.trigger]\nroute = \"/static/...\"\n\n[[component]]\nsource = { url = \"https://github.com/spinframework/spin-redirect/releases/download/v0.0.1/redirect.wasm\", digest = \"sha256:d57c3d91e9b62a6b628516c6d11daf6681e1ca2355251a3672074cddefd7f391\" }\nid = \"additional-component-redirect\"\nenvironment = { DESTINATION = \"/static/new.txt\" }\n[component.trigger]\nroute = \"/static/old.txt\"\nexecutor = { type = \"wagi\" }Also, note that the application's folder structure, scaffolded for us by Spin via the spin add commands, is symmetrical and shows no nesting of components:├── assets\n│   ├── my-static-image.jpg\n│   ├── new.txt\n│   └── old.txt\n├── first-http-rust-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n├── second-http-rust-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.tomlThis is the recommended Spin application structure.","keywords":"","subsectionKeywords":"","url":"/v1/spin-application-structure#recommended-application-structure"},{"project":"v1","title":"Application Structure","subheading":"Next Steps","content":"undefinedundefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/spin-application-structure#next-steps"},{"project":"v1","title":"SQLite Storage","subheading":"","content":"undefinedundefinedundefinedundefinedSpin provides an interface for you to persist data in an SQLite database managed by Spin. This database allows Spin developers to persist relational data across application invocations.{{ details \"Why do I need a Spin interface? Why can't I just use my own external database?\" \"You can absolutely still use your own external database either with the undefined. However, if you're interested in quick, local relational storage without any infrastructure set-up then Spin's SQLite database is a great option.\" }}","subsectionKeywords":"","url":"/v1/sqlite-api-guide"},{"project":"v1","title":"SQLite Storage","subheading":"Granting SQLite Database Permissions to Components","content":"By default, a given component of an app will not have access to any SQLite databases. Access must be granted specifically to each component via the component manifest.  For example, a component could be given access to the default store using:[component]\nsqlite_databases = [\"default\"]undefined","keywords":"","subsectionKeywords":"","url":"/v1/sqlite-api-guide#granting-sqlite-database-permissions-to-components"},{"project":"v1","title":"SQLite Storage","subheading":"Using SQLite Storage From Applications","content":"The Spin SDK surfaces the Spin SQLite database interface to your language.The set of operations is common across all SDKs:| Operation  | Parameters | Returns | Behavior |\n|------------|------------|---------|----------|\n| open  | name | connection  | Open the database with the specified name. If name is the string \"default\", the default database is opened, provided that the component that was granted access in the component manifest from spin.toml. Otherwise, name must refer to a store defined and configured in a undefined supplied with the application.|\n| execute | connection, sql, parameters | database records | Executes the SQL statement and returns the results of the statement. SELECT statements typically return records or scalars. INSERT, UPDATE, and DELETE statements typically return empty result sets, but may return values in some cases. The execute operation recognizes the undefined. |\n| close | connection | - | Close the specified connection. |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}SQLite functions are available in the spin_sdk::sqlite module. The function names match the operations above. For example:use anyhow::Result;\nuse serde::Serialize;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n    sqlite::{Connection, Error, ValueParam},\n};\n\n#[http_component]\nfn handle_request(req: Request) -> Result<Response> {\n    let connection = Connection::open_default()?;\n\n    let execute_params = [\n        ValueParam::Text(\"Try out Spin SQLite\"),\n        ValueParam::Text(\"Friday\"),\n    ];\n    connection.execute(\n        \"INSERT INTO todos (description, due) VALUES (?, ?)\",\n        execute_params.as_slice(),\n    )?;\n\n    let rowset = connection.execute(\n        \"SELECT id, description, due FROM todos\",\n        &[]\n    )?;\n\n    let todos: Vec<_> = rowset.rows().map(|row|\n        ToDo {\n            id: row.get::<u32>(\"id\").unwrap(),\n            description: row.get::<&str>(\"description\").unwrap().to_owned(),\n            due: row.get::<&str>(\"due\").unwrap().to_owned(),\n        }\n    ).collect();\n\n    let body = serde_json::to_vec(&todos)?;\n    Ok(http::Response::builder().status(200).body(Some(body.into()))?)\n}\n\n// Helper for returning the query results as JSON\n#[derive(Serialize)]\nstruct ToDo {\n    id: u32,\n    description: String,\n    due: String,\n}undefinedundefinedundefinedundefinedundefinedundefined{{ blockEnd }}{{ startTab \"Typescript\"}}To use SQLite functions, use the Sqlite.open or Sqlite.openDefault function to obtain a Connection object. Connection provides the execute method as described above. For example:import {Sqlite} from \"@fermyon/spin-sdk\"\n\nconst conn = Sqlite.openDefault();\nconst result = conn.execute(\"SELECT * FROM todos WHERE id > (?);\", [1]);\nconst json = JSON.stringify(result.rows);undefinedundefinedundefinedundefinedundefinedundefined{{ blockEnd }}{{ startTab \"Python\"}}To use SQLite functions, use the spin_sqlite module in the Python SDK. The sqlite_open and sqlite_open_default functions return a connection object. The connection object provides the execute method as described above. For example:from spin_http import Response\nfrom spin_sqlite import sqlite_open_default\n\ndef handle_request(request):\n    conn = sqlite_open_default()\n    result = conn.execute(\"SELECT * FROM todos WHERE id > (?);\", [1])\n    rows = result.rows()\n    return Response(200,\n                    {\"content-type\": \"application/json\"},\n                    bytes(str(rows), \"utf-8\"))undefinedundefinedundefinedundefinedundefined{{ blockEnd }}{{ startTab \"TinyGo\"}}The Go SDK is implemented as a driver for the standard library's undefined interface.package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\tspinhttp \"github.com/fermyon/spin/sdk/go/http\"\n\t\"github.com/fermyon/spin/sdk/go/sqlite\"\n)\n\ntype Todo struct {\n\tID          string\n\tDescription string\n\tDue         string\n}\n\nfunc init() {\n\tspinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n\t\tdb := sqlite.Open(\"default\")\n\t\tdefer db.Close()\n\n\t\t_, err := db.Exec(\"INSERT INTO todos (description, due) VALUES (?, ?)\", \"Try out Spin SQLite\", \"Friday\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\trows, err := db.Query(\"SELECT id, description, due FROM todos\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tvar todos []*Todo\n\t\tfor rows.Next() {\n\t\t\tvar todo Todo\n\t\t\tif err := rows.Scan(&todo.ID, &todo.Description, &todo.Due); err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttodos = append(todos, &todo)\n\t\t}\n\t\tjson.NewEncoder(w).Encode(todos)\n\t})\n}\n\nfunc main() {}undefinedA convenience function sqlite.Open() is provided to create a database connection. Because the http.Handle function is inside the init() function the Spin SQLite driver cannot be initialized the same way as other drivers using undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/sqlite-api-guide#using-sqlite-storage-from-applications"},{"project":"v1","title":"SQLite Storage","subheading":"Preparing an SQLite Database","content":"Although Spin provides SQLite as a built-in database, SQLite still needs you to create its tables.  In most cases, the most convenient way to do this is to use the spin up --sqlite option to run whatever SQL statements you need before your application starts.  This is typically used to create or alter tables, but can be used for whatever other maintenance or troubleshooting tasks you need.You can run a SQL script from a file using the @filename syntax:spin up --sqlite @migration.sqlOr you can pass SQL statements directly on the command line as a (quoted) string:spin up --sqlite \"CREATE TABLE IF NOT EXISTS todos (id INTEGER PRIMARY KEY AUTOINCREMENT, description TEXT NOT NULL, due TEXT NOT NULL)\"As with runtime operations, this flag uses the undefined.You can provide the --sqlite flag more than once; Spin runs the statements (or files) in the order you provide them, and waits for each to complete before running the next.undefined","keywords":"","subsectionKeywords":"","url":"/v1/sqlite-api-guide#preparing-an-sqlite-database"},{"project":"v1","title":"SQLite Storage","subheading":"Custom SQLite Databases","content":"Spin defines a database named \"default\" and provides automatic backing storage.  If you need to customize Spin with additional databases, or to change the backing storage for the default database, you can do so via the --runtime-config-file flag and the runtime-config.toml file.  See undefined for details.","keywords":"","subsectionKeywords":"","url":"/v1/sqlite-api-guide#custom-sqlite-databases"},{"project":"v1","title":"SQLite Storage","subheading":"Granting Access to Custom SQLite Databases","content":"As mentioned above, by default, a given component of an app will not have access to any SQLite databases. Access must be granted specifically to each component via the component manifest, using the component.sqlite_databases field in the manifest.Components can be given access to different databases, and may be granted access to more than one database. For example:# c1 has no access to any databases\n[component]\nname = \"c1\"\n\n# c2 can use the default database, but no custom databases\n[component]\nname = \"c2\"\nsqlite_databases = [\"default\"]\n\n# c3 can use the custom databases \"marketing\" and \"sales\", which must be\n# defined in the runtime config file, but cannot use the default database\n[component]\nname = \"c3\"\nsqlite_databases = [\"marketing\", \"sales\"]","keywords":"","subsectionKeywords":"","url":"/v1/sqlite-api-guide#granting-access-to-custom-sqlite-databases"},{"project":"v1","title":"Creating Spin templates","subheading":"","content":"undefinedundefinedundefinedundefinedSpin templates allow a Spin developer to quickly create the skeleton of an\napplication or component, ready for the application logic to be filled in.A template consists of two directories, content and metadata.undefinedundefinedFor examples of the directory contents, see the templates directory in the\nundefined.Templates must always be shared in a templates directory.  This allows the\ninstaller to locate them in repos that contain other content.","subsectionKeywords":"","url":"/v1/template-authoring"},{"project":"v1","title":"Creating Spin templates","subheading":"Authoring the Content","content":"Copy all the files that you want to be copied as part of the template into\nthe content directory. If you do nothing more, they will be copied\nverbatim. Often, though, you'll want to allow the user to put their own\nvalues in - for example, a project name, or an HTTP route.To do this, replace the text you want the user to be able to substitute\nwith an expression of the form {{parameter-name}}, where parameter-name\nis an identifier of your choice.  undefined - see below.You can reuse a parameter in more than one place - it will be prompted only once and will get the same value in each place.You can also transform the user value by specifying a filter after a bar:\n{{parameter-name | filter-name}}.  This is particularly useful when you\nwant to conform to specific language conventions. The following filters\nare supported:| Name          | Effect |\n|---------------|--------|\n| kebab_case  | Transforms input into kebab case, e.g. My Application to my-application |\n| snake_case  | Transforms input into snake case, e.g. My Application to my_application |\n| pascal_case | Transforms input into Pascal case, e.g. my appplication to MyApplication |","keywords":"","subsectionKeywords":"","url":"/v1/template-authoring#authoring-the-content"},{"project":"v1","title":"Creating Spin templates","subheading":"Authoring the Manifest","content":"The template manifest is a TOML file. It must be named spin-template.toml:manifest_version = \"1\"\nid = \"my-application\"\ndescription = \"An application\"\ntags = [\"my-tag\"]\n\n[parameters]\n# Example parameter\nproject-name = { type = \"string\", prompt = \"Project name\" }undefinedundefinedundefinedundefinedThe parameters table is where you list the placeholders that you edited\ninto your content for the user to substitute. You should include an entry\nfor each parameter. The key is the parameter name, and the value a JSON\ndocument that contains at minimum a type and prompt.  type must\ncurrently be string.  prompt is displayed when prompting the user\nfor the value to substitute.The document may also have a default, which will be displayed to the user\nand can be accepted by pressing Enter. It may also specify constraints\non what the user is allowed to enter. The following constraints are\nsupported:| Key           | Value and usage |\n|---------------|-----------------|\n| pattern     | A regular expression. The user input must match the regular expression to be accepted. |","keywords":"","subsectionKeywords":"","url":"/v1/template-authoring#authoring-the-manifest"},{"project":"v1","title":"Creating Spin templates","subheading":"Supporting  spin add","content":"The spin add command lets users add your template as a new component in\nan existing application. If you'd like to support this, you'll need to\nadd a few items to your metadata.undefinedundefined| Key             | Value and usage |\n|-----------------|-----------------|\n| snippets      | A subtable with an entry named component, whose value is the name of the file containing the component manifest template. (Don't include the snippets directory prefix - Spin knows to look in the snippets directory.) |\n| skip_files    | Optional array of content files that should undefined be copied when running in \"add component\" mode. For example, if your template contains a spin.toml file, you should use this setting to exclude that, because you want to add a new entry to the existing file, not overwrite it. |\n| skip_parameters | Optional array of parameters that Spin should undefined prompt for when running in \"add component\" mode. For example, the HTTP templates don't prompt for the base path, because that's defined at the application level, not set on an individual component. |Here is an example add_component table from a HTTP template:[add_component]\nskip_files = [\"spin.toml\"]\nskip_parameters = [\"http-base\"]\n[add_component.snippets]\ncomponent = \"component.txt\"undefined","keywords":"","subsectionKeywords":"","url":"/v1/template-authoring#supporting-spin-add"},{"project":"v1","title":"Creating Spin templates","subheading":"Hosting Templates in Git","content":"You can publish templates in a Git repo.  The templates must be in the /templates\ndirectory, with a subdirectory per template.When a user installs templates from your repo, by default Spin looks for a tag\nto identify a compatible version of the templates.  This tag is of the\nform spin/templates/vX.Y, where X is the major version, and Y the minor\nversion, of the user's copy of Spin. For example, if the user is on\nSpin 0.3.1, templates will be installed from spin/templates/v0.3.  If this\ntag does not exist, Spin installs templates from HEAD.","keywords":"","subsectionKeywords":"","url":"/v1/template-authoring#hosting-templates-in-git"},{"project":"v1","title":"Troubleshooting Application Development","subheading":"","content":"The spin doctor command detects problems that could stop your application building and running, and can help to fix them.  These include problems like invalid manifests, missing Wasm files, and missing tools.To troubleshoot using spin doctor, run the command:$ spin doctorundefinedSpin performs a series of checks on your application. If it finds a problem, it prints a description and, if possible, offers to fix it. Here's an example where a stray keystroke has messed up the version field in the application manifest:$ spin doctor\n📟 The Spin Doctor is in.\n🩺 Checking spin.toml...\n\n❗ Diagnosis: Manifest 'spin_manifest_version' must be \"1\", not \"11\"\n🩹 The Spin Doctor can help! Would you like to:\n> Set manifest version to \"1\"\n  Do nothing\n  See more details about the recommended changesIf spin doctor detects a problem it can fix, you can choose to accept the fix, skip it to fix manually later, or see more details before choosing.  If spin doctor can't fix the problem, it displays the problem so you can make your own decision about how to fix it.undefined","subsectionKeywords":"","url":"/v1/troubleshooting-application-dev"},{"project":"v1","title":"Upgrade Spin","subheading":"","content":"undefinedundefinedundefined","subsectionKeywords":"","url":"/v1/upgrade"},{"project":"v1","title":"Upgrade Spin","subheading":"Are You on the Latest Version?","content":"The best way to know if you're on the latest version of Spin is to run spin --version:$ spin --versionYou can compare the output from the above command with the undefined listed in the Spin GitHub repository (which is also shown in the image below):undefined","keywords":"","subsectionKeywords":"","url":"/v1/upgrade#are-you-on-the-latest-version"},{"project":"v1","title":"Upgrade Spin","subheading":"Upgrade Spin","content":"Spin can be installed in many ways, and therefore the upgrade procedure can differ between users. Here are a few suggested ways to upgrade Spin to the latest version. If you're not sure how or where you installed your current version of Spin try using the which command on undefined and the where command on undefined, as shown below:{{ tabs \"os\" }}{{ startTab \"Linux\"}}$ which spin{{ blockEnd }}{{ startTab \"macOS\"}}$ which spin{{ blockEnd }}{{ startTab \"Windows\"}}$ where spin{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/upgrade#upgrade-spin"},{"project":"v1","title":"Upgrade Spin","subheading":"Cargo","content":"If you originally followed the documentation's undefined, please revisit to reinstall.undefined~/.cargo/bin/spin","keywords":"","subsectionKeywords":"","url":"/v1/upgrade#cargo"},{"project":"v1","title":"Upgrade Spin","subheading":"Installer","content":"If you originally followed the documentation's undefined, please revisit to reinstall.undefined/usr/local/bin/spin","keywords":"","subsectionKeywords":"","url":"/v1/upgrade#installer"},{"project":"v1","title":"Upgrade Spin","subheading":"Source","content":"If you followed the documentation's undefined please revisit to reinstall.undefined~/spin/target/release/spin","keywords":"","subsectionKeywords":"","url":"/v1/upgrade#source"},{"project":"v1","title":"Upgrade Spin","subheading":"Homebrew","content":"If you installed Spin using undefined please use the following commands to upgrade Spin.$ brew update\n$ brew upgrade fermyon/tap/spin","keywords":"","subsectionKeywords":"","url":"/v1/upgrade#homebrew"},{"project":"v1","title":"Upgrade Spin","subheading":"Troubleshooting","content":"If you have upgraded Spin and don't see the newer version, please consider the following.","keywords":"","subsectionKeywords":"","url":"/v1/upgrade#troubleshooting"},{"project":"v1","title":"Upgrade Spin","subheading":"Not Seeing the Latest Version?","content":"It may be possible that you have installed Spin undefined of the above methods. In this case, the Spin executable that runs is the one that is listed first in your PATH system variable.If you have upgraded Spin yet still see the old version using spin --version this can be due to the order of precedence in your PATH. Try echoing your path to the screen and checking to see whether the location of your intended Spin executable is listed before or after other pre-existing installation paths:echo $PATH\n/Users/my_user/.cargo/bin:/usr/local/binundefinedIn the above case, the undefined's installation will take precedence over the undefined's installation.In this case, you can either remove the Cargo installation of Spin using cargo uninstall spin-cli or update your system path to prioritize the Spin binary path that you prefer.","keywords":"","subsectionKeywords":"","url":"/v1/upgrade#not-seeing-the-latest-version"},{"project":"v1","title":"Building a URL Shortener With Spin","subheading":"","content":"undefinedundefinedundefined","subsectionKeywords":"","url":"/v1/url-shortener-tutorial"},{"project":"v1","title":"Building a URL Shortener With Spin","subheading":"A Simple URL Shortener Built With Spin","content":"This tutorial will walk you through building a Spin component that\nredirects short URLs to their configured destinations.\nIn essence, this is a simple HTTP component that returns a response that contains\nredirect information based on the user-defined routes.This is an evolving tutorial. As Spin allows building more complex components\n(through supporting access to services like databases), this tutorial will be\nupdated to reflect that.","keywords":"","subsectionKeywords":"","url":"/v1/url-shortener-tutorial#a-simple-url-shortener-built-with-spin"},{"project":"v1","title":"Building a URL Shortener With Spin","subheading":"Here Is One We Prepared Earlier","content":"The complete implementation for this tutorial undefined.First, our URL shortener allows users to configure their own final URLs —\ncurrently, that is done through a configuration file that contains multiple\n[[route]] entries, each containing the shortened path as source, and\nthe destination URL:[[route]]\nsource = \"/spin\"\ndestination = \"https://github.com/spinframework/spin\"\n\n[[route]]\nsource = \"/hype\"\ndestination = \"https://www.fermyon.com/blog/how-to-think-about-wasm\"Whenever a request for https://<domain>/spin is sent, our component will\nredirect to https://github.com/spinframework/spin. Now that we have a basic\nunderstanding of how the component should behave, let's see how to implement it\nusing Spin.First, we start with undefined:/// A Spin HTTP component that redirects requests \n/// based on the router configuration.\n#[http_component]\nfn redirect(req: Request) -> Result<Response> {\n    let router = Router::default()?;\n    router.redirect(req)\n}All the component does is create a new router based on the default configuration,\nthen use it to redirect the request. Let's see how the router is defined:#[derive(Debug, Deserialize, Serialize)]\npub struct Route {\n    pub source: String,\n    pub destination: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct Router {\n    #[serde(rename = \"route\")]\n    pub routes: Vec<Route>,\n}The Router structure is a Rust representation of the TOML configuration above.pub fn redirect(self, req: Request) -> Result<Response> {\n    // read the request path from the `spin-path-info` header\n    let path_info = req\n        .headers()\n        .get(\"spin-path-info\")\n        .expect(\"cannot get path info from request headers\");\n    // if the path is not present in the router configuration,\n    // return 404 Not Found.\n    let route = match self.path(path_info.to_str()?) {\n        Some(r) => r,\n        None => return not_found(),\n    };\n    // otherwise, return the redirect to the destination\n    let res = http::Response::builder()\n        .status(http::StatusCode::PERMANENT_REDIRECT)\n        .header(http::header::LOCATION, route.destination)\n        .body(None)?;\n    Ok(res)\n}The redirect function is straightforward — it reads the request path from the\nspin-path-info header (make sure to read the undefined\nfor an overview of the HTTP headers present in Spin components), selects the\ncorresponding destination from the router configuration, then sends the\nHTTP redirect to the new location.At this point, we can build and run the module with Spin:$ spin build\n$ spin upAnd the component can now handle incoming requests:# based on the configuration file, a request\n# to /spin should be redirected\n$ curl -i localhost:3000/spin\nHTTP/1.1 308 Permanent Redirect\nlocation: https://github.com/spinframework/spin\ncontent-length: 0\n# based on the configuration file, a request\n# to /hype should be redirected\n$ curl -i localhost:3000/hype\nHTTP/1.1 308 Permanent Redirect\nlocation: https://www.fermyon.com/blog/how-to-think-about-wasm\ncontent-length: 0\n# /abc is not present in the router configuration,\n# so this returns a 404.\n$ curl -i localhost:3000/abc\nHTTP/1.1 404 Not Found\ncontent-length: 9\n\nNot FoundundefinedWe can now undefined (together\nwith router configuration file):$ spin registry push ghcr.io/alyssa-p-hacker/url-shortener:v1\nPushed with digest sha256:3c408a1b29b3098286c7ea5ab22f47248ccfadcc63ad5596ca0d85e3f522c43dAnd now we can run the application directly from the registry:$ spin up -f ghcr.io/alyssa-p-hacker/url-shortener:v1\n\nServing http://127.0.0.1:3000\nAvailable Routes:\n  shortener: http://127.0.0.1:3000 (wildcard)","keywords":"","subsectionKeywords":"","url":"/v1/url-shortener-tutorial#here-is-one-we-prepared-earlier"},{"project":"v1","title":"Building a URL Shortener With Spin","subheading":"Conclusion","content":"In this tutorial we built a simple URL shortener as a Spin component.\nIn the future we will expand this tutorial by storing the router configuration\nin a database supported by Spin, and potentially create another component that\ncan be used to add new routes to the configuration.","keywords":"","subsectionKeywords":"","url":"/v1/url-shortener-tutorial#conclusion"},{"project":"v1","title":"Application Variables","subheading":"","content":"undefinedundefinedSpin supports dynamic application variables. Instead of being static, their values can be updated without modifying the application, creating a simpler experience for rotating secrets, updating API endpoints, and more.These variables are defined in a Spin application manifest (in the [variables] section), and their values can be set or overridden at runtime by an undefined. When running Spin locally, the variables provider can be undefined for secrets, or host environment variables.For information about configuring application variables providers, refer to the undefined.","subsectionKeywords":"","url":"/v1/variables"},{"project":"v1","title":"Application Variables","subheading":"Adding Variables to Your Applications","content":"Variables are added to an application under the top-level [variables] section of an application manifest (spin.toml). Each entry must either have a default value or be marked as required = true. “Required” entries must be undefined with a value.For example, say an application needs to access a secret. A [variables] section could be added to an application's manifest with one entry for a variable named secret. Since there is no reasonable default value for a secret, the variable is set as required with required = true:# Add this above the [component] section\n[variables]\nsecret = { required = true }Variables are surfaced to a specific component by adding a [component.config] section to the component and referencing them within it. The [component.config] section contains a mapping of component variables and values. Entries can be static (like api_host below) or reference an updatable application variable (like password below) using undefined-inspired string templates. Only components that explicitly use variables in their configuration section will get access to them. This enables only exposing variables (such as secrets) to the desired components of an application.# Add this below the [component.build] section\n[component.config]\npassword = \"\\{{ secret }}\"\napi_host = \"https://my-api.com\"When a component configuration variable references an application variable, it's value will dynamically update as the application variable changes. For example, if the secret variable is provided using the undefined, it can be updated by changing the value in HashiCorp Vault. The next time the component gets the value of password, the latest value of secret will be returned by the provider. See the undefined to learn how to use Spin's configuration SDKs to get configuration variables within applications.A complete application manifest with a secret variable and a component that uses it would look similar to the following, with the [component.build] section varying depending on the language used to build the password_checker component:spin_manifest_version = \"1\"\ndescription = \"A Spin app with a dynamically updatable secret\"\nname = \"password_checker\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[variables]\nsecret = { required = true }\n\n[[component]]\nid = \"password_checker\"\nsource = \"app.wasm\"\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"spin py2wasm app -o app.wasm\"\n[component.config]\npassword = \"\\{{ secret }}\"\napi_host = \"https://my-api.com\"","keywords":"","subsectionKeywords":"","url":"/v1/variables#adding-variables-to-your-applications"},{"project":"v1","title":"Application Variables","subheading":"Using Variables From Applications","content":"The Spin SDK surfaces the Spin configuration interface to your language. The undefined consists of one operation:| Operation  | Parameters                          | Returns             | Behavior |\n|------------|-------------------------------------|---------------------|----------|\n| get-config    | Variable name  | Variable value    | Gets the value of the variable from the configured provider |To illustrate the config API, each of the following examples receives a password via the HTTP request body, compares it to the value stored in the application variable, and returns a JSON response indicating whether the submitted password matched or not. The application manifest associated with the examples would look similar to the one described undefined.The exact details of calling the config SDK from a Spin application depends on the language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}The config function is available in the spin_sdk::config module and is named get.use anyhow::Result;\nuse spin_sdk::{\n    config,\n    http::{Request, Response},\n    http_component,\n};\n\n#[http_component]\nfn handle_spin_example(req: Request) -> Result<Response> {\n    let password = std::str::from_utf8(req.body().as_ref().unwrap()).unwrap();\n    let expected = config::get(\"password\").expect(\"could not get variable\");\n    let response = if expected == password {\n        \"accepted\"\n    } else {\n        \"denied\"\n    };\n    let response_json = format!(\"\\{{\\\"authentication\\\": \\\"{}\\\"}}\", response);\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"Content-Type\", \"application/json\")\n        .body(Some(response_json.into()))?)\n}\n{{ blockEnd }}{{ startTab \"TypeScript\"}}The config function is available in the Config package and is named get.import { HandleRequest, HttpRequest, HttpResponse, Config } from \"@fermyon/spin-sdk\"\n\nconst decoder = new TextDecoder(\"utf-8\")\n\nexport const handleRequest: HandleRequest = async function (request: HttpRequest): Promise<HttpResponse> {\n  const expected = decoder.decode(request.body)\n  let password = Config.get(\"password\")\n  let access = \"denied\"\n  if (expected === password) {\n      access = \"accepted\"\n  }\n  let responseJson = `{\\\"authentication\\\": \\\"${access}\\\"}`;\n\n  return {\n    status: 200,\n    headers: { \"Content-Type\": \"application/json\" },\n    body: responseJson\n  }\n}\n{{ blockEnd }}{{ startTab \"Python\"}}The config function is available in the spin_config package and is named config_get.from spin_http import Response\nfrom spin_config import config_get\n\ndef handle_request(request):\n    password = request.body.decode(\"utf-8\")\n    expected = config_get(\"password\")\n    access = \"denied\"\n    if expected == password:\n        access = \"accepted\"\n    response = f'\\{{\"authentication\": \"{access}\"}}'\n    return Response(200,\n                    {\"content-type\": \"application/json\"},\n                    bytes(response, \"utf-8\")){{ blockEnd }}{{ startTab \"TinyGo\"}}The config function is available in the github.com/fermyon/spin/sdk/go/config package and is named Get. See undefined for reference documentation.import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\n\tspinconfig \"github.com/fermyon/spin/sdk/go/config\"\n\tspinhttp \"github.com/fermyon/spin/sdk/go/http\"\n)\n\nspinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n    access := \"denied\"\n    password, err := io.ReadAll(r.Body)\n    if err == nil {\n        expected, err := spinconfig.Get(\"password\")\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n        if expected == string(password) {\n            access = \"accepted\"\n        }\n    }\n    response := fmt.Sprintf(\"{\\\"authentication\\\": \\\"%s\\\"}\", access)\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    fmt.Fprintln(w, response)\n}){{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v1/variables#using-variables-from-applications"},{"project":"v1","title":"Writing Spin Applications","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedA Spin application consists of a set of WebAssembly (Wasm) undefined, and a undefined that lists those components with some data about when and how to run them.  This page describes how to write components, manifests, and hence applications.","subsectionKeywords":"","url":"/v1/writing-apps"},{"project":"v1","title":"Writing Spin Applications","subheading":"Writing an Application Manifest","content":"undefinedA Spin undefined is a undefined file that contains:undefinedundefinedundefinedundefinedBy convention, the Spin manifest file is usually called spin.toml.This example is the manifest for a simple HTTP application with a single component executed when the /hello endpoint is accessed:# General identification information\nspin_manifest_version = \"1\"\nname = \"spin-hello-world\"\nversion = \"1.0.0\"\ndescription = \"A simple application that returns hello world.\"\n# The application trigger. This application responds to HTTP requests\ntrigger = { type = \"http\", base = \"/\" }\n\n# The single component\n[[component]]\nid = \"hello\"\ndescription = \"A simple component that returns hello world.\"\n# The Wasm module to run for the component\nsource = \"target/wasm32-wasi/release/helloworld.wasm\"\n# The component trigger. This component responds to HTTP requests to \"/hello\"\n[component.trigger]\nroute = \"/hello\"\n# How to build the Wasm module from source\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"You can look up the various fields in the undefined, but let's look at the key fields in more detail.","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#writing-an-application-manifest"},{"project":"v1","title":"Writing Spin Applications","subheading":"The Application  trigger","content":"The most important field in the application-level section is the trigger field.  This tells Spin the undefined of event that it should hook the application up to.  Spin has built-in support for responding to HTTP requests (trigger = { type = \"http\" }) and Redis messages (trigger = { type = \"redis\" })undefinedSome triggers have additional application-level configuration options.  For example, the HTTP trigger requires you to provide a base field, which tells Spin the \"root\" route to which all component routes are relative.  See the undefined and undefined documentation for more details.","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#the-application-trigger"},{"project":"v1","title":"Writing Spin Applications","subheading":"The Component  id","content":"Component ids are identifier strings.  While not significant in themselves, they must be unique within the application.  Spin uses the id in logging and error messages to tell you which component a message applies to.[[component]]\nid = \"hello\"","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#the-component-id"},{"project":"v1","title":"Writing Spin Applications","subheading":"The Component  source","content":"Each component has a source field which tells Spin where to load the Wasm module from.For components that you are working on locally, set it to the file path to the compiled Wasm module file.  This must be a relative path from the directory containing spin.toml.[[component]]\nsource = \"dist/cart.wasm\"For components that are published on the Web, provide a url field containing the URL of the Wasm module, and a digest field indicating the expected SHA256 hash of the module contents.  The digest must be prefixed with the string sha256:.  Spin uses the digest to check that the module is what you were expecting, and won't load the module if the content doesn't match.[[component]]\nsource = { url = \"https://github.com/spinframework/spin-fileserver/releases/download/v0.0.1/spin_static_fs.wasm\", digest = \"sha256:650376c33a0756b1a52cad7ca670f1126391b79050df0321407da9c741d32375\" }Multiple components can have the same source.  An example is a document archive, where one component might serve user interface assets (CSS, images, etc.) on one route, while another serves the documents themselves on another route - both using the same file server module, but with different settings.","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#the-component-source"},{"project":"v1","title":"Writing Spin Applications","subheading":"The Component  trigger","content":"Each component has a trigger field which contains per-component settings (as opposed to the application-level ones on the application's trigger).  In particular, this tells Spin when to run undefined component rather than any other component.  For HTTP applications, the component trigger has a route that says which HTTP route the component should handle.  For Redis applications, the component trigger has a channel that says which Redis channel's messages the component should handle.  See the undefined and undefined documentation for more details.[[component]]\n[component.trigger]\nroute = \"/hello\"","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#the-component-trigger"},{"project":"v1","title":"Writing Spin Applications","subheading":"Writing a Component Wasm Module","content":"undefinedAt the Wasm level, a Spin component is a Wasm module that exports a handler for the application trigger.  At the developer level, a Spin component is a library or program that implements your event handling logic, and uses Spin interfaces, libraries, or tools to associate that with the events handled by Spin.See the Language Guides section for how to do this in your preferred language. As an example, this is a component written in the Rust language. The hello_world function uses an attribute #[http_component] to identify the function as handling a Spin HTTP event. The function takes a Request and returns a Result<Response>:#[http_component]​\nfn hello_world(_req: Request) -> Result<Response> {​\n    Ok(http::Response::builder()​\n        .status(200)​\n        .body(Some(\"Hello, Fermyon!\".into()))?)​\n}​","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#writing-a-component-wasm-module"},{"project":"v1","title":"Writing Spin Applications","subheading":"Creating an Application From a Template","content":"If you've installed the Spin templates for your preferred language, you can use them to get started without having to write a manifest or the boilerplate code yourself.  To do this, run the spin new command, and choose the template that matches the type of application you want to create, and the language you want to use.{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}Choose the http-rust template to create a new HTTP application, or redis-rust to create a new Redis application.$ spin new\nPick a template to start your application with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-csharp (HTTP request handler using C# (EXPERIMENTAL))\n  http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n> http-rust (HTTP request handler using Rust)\n  http-swift (HTTP request handler using SwiftWasm)\n  http-zig (HTTP request handler using Zig)\n  redis-go (Redis message handler using (Tiny)Go)\n  redis-rust (Redis message handler using Rust)\n\nEnter a name for your new application: hello_rust\nProject description: My first Rust Spin application\nHTTP base: /\nHTTP path: /...{{ blockEnd }}{{ startTab \"TypeScript\"}}Choose the http-ts or http-js template to create a new HTTP application, according to whether you want to use TypeScript or JavaScript.undefined$ spin new\nPick a template to start your application with:\n  http-js (HTTP request handler using Javascript)\n> http-ts (HTTP request handler using Typescript)\nEnter a name for your new application: hello_typescript\nProject description: My first TypeScript Spin application\nHTTP base: /\nHTTP path: /...{{ blockEnd }}{{ startTab \"Python\"}}Choose the http-py template to create a new HTTP application.undefined$ spin new\nPick a template to start your application with:\n> http-py (HTTP request handler using Python)\nEnter a name for your new application: hello_python\nDescription: My first Python Spin application\nHTTP base: /\nHTTP path: /...{{ blockEnd }}{{ startTab \"TinyGo\"}}Choose the http-go template to create a HTTP application, or redis-go to create a Redis application.$ spin new\nPick a template to start your application with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-empty (HTTP application with no components)\n> http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n  http-php (HTTP request handler using PHP)\n  http-rust (HTTP request handler using Rust)\nEnter a name for your new application: hello_go\nDescription: My first Go Spin application\nHTTP base: /\nHTTP path: /...{{ blockEnd }}{{ blockEnd }}All of these templates create a manifest containing a single component, and the source code for a minimal \"hello world\" component.","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#creating-an-application-from-a-template"},{"project":"v1","title":"Writing Spin Applications","subheading":"Adding a New Component to an Application","content":"To add a new component to an existing application using a template, run the spin add command. This works in a very similar way to spin new, except that it expects the spin.toml file to already exist, and adds the details for the new component to that spin.toml.undefined","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#adding-a-new-component-to-an-application"},{"project":"v1","title":"Writing Spin Applications","subheading":"Including Files with Components","content":"You can include files with a component.  This means that:undefinedundefinedTo do this, use the files field in the component manifest:[[component]]\nfiles = [ \"images/**/*.jpg\", { source = \"styles/dist\", destination = \"/styles\" } ]The files field is an array listing the files, patterns and directories you want to include. Each element of the array can be:undefinedundefinedIf your files list would match some files or directories that you undefined want included, you can use the exclude_files field to omit them.undefined","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#including-files-with-components"},{"project":"v1","title":"Writing Spin Applications","subheading":"Adding Environment Variables to Components","content":"Environment variables can be provided to components via the Spin application manifest.To do this, use the environment field in the component manifest:[[component]]\nenvironment = { PET = \"CAT\", FOOD = \"WATERMELON\" }The field accepts a map of environment variable key/value pairs. They are mapped inside the component at runtime.The environment variables can then be accessed inside the component. For example, in Rust:#[http_component]\nfn handle_hello_rust(req: Request) -> Result<Response> {\n    let response = format!(\"My {} likes to eat {}\", std::env::var(\"PET\")?, std::env::var(\"FOOD\")?);\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(response.into()))?)\n}","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#adding-environment-variables-to-components"},{"project":"v1","title":"Writing Spin Applications","subheading":"Granting Networking Permissions to Components","content":"By default, Spin components are not allowed to make outgoing HTTP requests.  This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing.  To grant a component permission to make HTTP requests to a particular host, use the allowed_http_hosts field in the component manifest:[[component]]\nallowed_http_hosts = [ \"dog-facts.example.com\", \"api.example.com:8080\" ]The Wasm module can make HTTP requests undefined to the specified hosts.  If a port is specified, the module can make requests only to that port; otherwise, the module can make requests only on the default HTTP and HTTPS ports.  Requests to other hosts (or other ports) will fail with an error.For development-time convenience, you can also pass the string \"insecure:allow-all\" in the allowed_http_hosts collection.  This allows the Wasm module to make HTTP requests to undefined host and on any port.  However, once you've determined which hosts your code needs, you should remove this string, and list the hosts instead.  Other Spin implementations may restrict host access, and may disallow components that ask to connect to anything and everything!","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#granting-networking-permissions-to-components"},{"project":"v1","title":"Writing Spin Applications","subheading":"Granting Storage Permissions to Components","content":"By default, Spin components are not allowed to access Spin's storage services.  This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing.  To grant a component permission to use a Spin-provided store, use the key_value_stores field in the component manifest:[[component]]\nkey_value_stores = [ \"default\" ]See undefined for more information.","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#granting-storage-permissions-to-components"},{"project":"v1","title":"Writing Spin Applications","subheading":"Example Manifests","content":"This section shows some examples of Spin component manifests.","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#example-manifests"},{"project":"v1","title":"Writing Spin Applications","subheading":"Including a Directory of Files","content":"This example shows a Spin HTTP component that includes all the files in static/ under the application directory, made available to the Wasm module at the / path.[[component]]\nsource = \"modules/spin_static_fs.wasm\"\nid = \"fileserver\"\nfiles = [ { source = \"static/\", destination = \"/\" } ]\n[component.trigger]\nroute = \"/static/...\"","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#including-a-directory-of-files"},{"project":"v1","title":"Writing Spin Applications","subheading":"Using Public Components","content":"This is similar to the file server component above, but gets the Wasm module from a public release instead of a local copy.  Notice that the files are still drawn from a local path.  This is a way in which you can use off-the-shelf component logic with your own application data.[[component]]\nsource = { url = \"https://github.com/spinframework/spin-fileserver/releases/download/v0.0.1/spin_static_fs.wasm\", digest = \"sha256:650376c33a0756b1a52cad7ca670f1126391b79050df0321407da9c741d32375\" }\nid = \"fileserver\"\nfiles = [ { source = \"static/\", destination = \"/\" } ]\n[component.trigger]\nroute = \"/static/...\"","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#using-public-components"},{"project":"v1","title":"Writing Spin Applications","subheading":"Customizing the Executor","content":"This example shows an HTTP component whose Wasm module, instead of using the default Spin HTTP interface, uses the CGI-like WAGI (WebAssembly Gateway Interface) protocol. Spin can't work out the application model from the component, so the manifest needs to tell Spin to use WAGI instead of its default mode. It does this via the executor field. This is specific to the HTTP trigger so it goes under component.trigger.In addition, this module does not provide its WAGI functionality via the default _start entry point, but via a custom entry point named serve-wagi.  The executor table needs to tell Spin this via the entrypoint field.  Finally, this component needs to run the WAGI entry point with a specific set of command line arguments, which are expressed in the WAGI executor's argv field.[[component]]\nsource = \"modules/env_wagi.wasm\"\nid = \"env\"\nfiles = [ \"content/**/*\" , \"templates/*\", \"scripts/*\", \"config/*\"]\n[component.trigger]\nroute = \"/...\"\nexecutor = { type = \"wagi\", argv = \"test ${SCRIPT_NAME} ${ARGS} done\", entrypoint = \"serve-wagi\" }","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#customizing-the-executor"},{"project":"v1","title":"Writing Spin Applications","subheading":"Setting the Redis Channel to Monitor","content":"The example shows a Redis component.  The manifest sets the channel field to say which channel the component should monitor.  In this case, the component is invoked for new messages on the messages channel.[[component]]\nid = \"echo-message\"\nsource = \"spinredis.wasm\"\n[component.trigger]\nchannel = \"messages\"","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#setting-the-redis-channel-to-monitor"},{"project":"v1","title":"Writing Spin Applications","subheading":"Next Steps","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v1/writing-apps#next-steps"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedArtificial Intelligence (AI) Inferencing performs well on GPUs. However, GPU infrastructure is both scarce and expensive. This tutorial will show you how to use Fermyon Serverless AI to quickly build advanced AI-enabled serverless applications that can run on Fermyon Cloud. Your applications will benefit from 50 millisecond cold start times and operate 100x faster than other on-demand AI infrastructure services. Take a quick look at the video below to learn about executing inferencing on LLMs with no extra setup.In this tutorial we will:undefinedundefinedundefined","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Tutorial Prerequisites","content":"","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#tutorial-prerequisites"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Spin","content":"You will need to undefined. Serverless AI is supported on Spin versions 1.5 and above.If you already have Spin installed, undefined if required.","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#spin"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Dependencies","content":"The above installation script automatically installs the latest SDKs for Rust (which will enable us to write Serverless AI applications in Rust). However, some of the Serverless AI examples are written using TypeScript/Javascript, Python and TinyGo. To enable Serverless AI functionality via TypeScript/Javascript, Python and TinyGo, please ensure you have the latest TypeScript/JavaScript, Python or TinyGo template installed:undefined$ spin templates install --git https://github.com/spinframework/spin-js-sdk --upgrade --branch sdk-v2undefinedEnsure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.Some of the Serverless AI examples are written using Python. To enable Serverless AI functionality via Python, please ensure you have the latest Python template installed:$ spin templates install --git https://github.com/spinframework/spin-python-sdk --upgradeundefinedSome of the Serverless AI examples are written using TinyGo. To enable Serverless AI functionality via TinyGo, please ensure you have the latest Spin template installed (the following command will make the http-go template available):$ spin templates install --git https://github.com/spinframework/spin --upgrade","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#dependencies"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Licenses","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#licenses"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Serverless AI Inferencing With Spin Applications","content":"Now, let's dive deep into a comprehensive tutorial and unlock your potential to use Fermyon Serverless AI.\nundefined The full source code with other examples can be found in our undefined","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#serverless-ai-inferencing-with-spin-applications"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Creating a New Spin Application","content":"{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}The Rust code snippets below are taken from the undefinedundefined$ spin new -t http-rust\nEnter a name for your new application: sentiment-analysis\nDescription: A sentiment analysis API that demonstrates using LLM inferencing and KV stores together\nHTTP path: /api/...{{ blockEnd }}{{ startTab \"TypeScript\" }}The TypeScript code snippets below are taken from the undefinedundefined$ spin new -t http-ts\nEnter a name for your new application: sentiment-analysis\nDescription: A sentiment analysis API that demonstrates using LLM inferencing and KV stores together\nHTTP path: /api/...{{ blockEnd }}{{ startTab \"Python\" }}The Python code snippets below are taken from the undefinedundefined$ spin new -t http-py\nEnter a name for your new application: sentiment-analysis\nDescription: A sentiment analysis API that demonstrates using LLM inferencing and KV stores together\nHTTP path: /api/...{{ blockEnd }}{{ startTab \"TinyGo\" }}undefined$ spin new -t http-go\nEnter a name for your new application: sentiment-analysis\nDescription: A sentiment analysis API that demonstrates using LLM inferencing and KV stores together\nHTTP path: /api/...{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#creating-a-new-spin-application"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Supported AI Models","content":"Fermyon's Spin and Serverless AI currently support:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#supported-ai-models"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Model Optimization","content":"The models need to be in a particular format for Spin to be able to use them (quantized, which is a form of optimization). The official download links for the models (in non-quantized format) are listed in the previous section. However, for your convenience, the code examples below fetch models which are already in the special quantized format.","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#model-optimization"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Application Structure","content":"Next, we need to create the appropriate folder structure from within the application directory (alongside our spin.toml file). The code below demonstrates the variations in folder structure depending on which model is being used. Once the folder structure is in place, we then fetch the pre-trained AI model for our application:undefinedundefinedundefined# llama2-chat\n$ mkdir -p .spin/ai-models/llama\n$ cd .spin/ai-models/llama\n$ wget https://huggingface.co/TheBloke/Llama-2-13B-chat-GGML/resolve/a17885f653039bd07ed0f8ff4ecc373abf5425fd/llama-2-13b-chat.ggmlv3.q3_K_L.bin\n$ mv llama-2-13b-chat.ggmlv3.q3_K_L.bin llama2-chattree .spin\n.spin\n└── ai-models\n    └── llama\n        └── llama2-chatundefinedundefined# codellama-instruct\n$ mkdir -p .spin/ai-models/llama\n$ cd .spin/ai-models/llama\n$ wget https://huggingface.co/TheBloke/CodeLlama-13B-Instruct-GGML/resolve/b3dc9d8df8b4143ee18407169f09bc12c0ae09ef/codellama-13b-instruct.ggmlv3.Q3_K_L.bin\n$ mv codellama-13b-instruct.ggmlv3.Q3_K_L.bin codellama-instructtree .spin\n.spin\n└── ai-models\n    └── llama\n        └── codellama-instructundefinedThe following section fetches a specific version of the undefined model:$ mkdir -p .spin/ai-models/all-minilm-l6-v2\n$ cd .spin/ai-models/all-minilm-l6-v2\n$ wget https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2/resolve/7dbbc90392e2f80f3d3c277d6e90027e55de9125/tokenizer.json\n$ wget https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2/resolve/0b6dc4ef7c29dba0d2e99a5db0c855c3102310d8/model.safetensorstree .spin\n.spin\n└── ai-models\n    └── all-minilm-l6-v2\n        ├── model.safetensors\n        └── tokenizer.jsonundefinedln -s ~/my-ai-models/ ~/application-one/.spin/ai-models","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#application-structure"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Application Configuration","content":"Then, we configure the [component.sentiment-analysis] section of our application's manifest (the spin.toml file); explicitly naming our model of choice. For example, in the case of the sentiment analysis application, we specify the llama2-chat value for our ai_models configuration, and add a default key-value store:undefined[component.sentiment-analysis]\n...\nai_models = [\"llama2-chat\"]\nkey_value_stores = [\"default\"]\n...","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#application-configuration"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Source Code","content":"Now let's use the Spin SDK to access the model from our app:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}The Rust source code for this sentiment analysis example uses serde. There are a couple of ways to add the required serde dependencies:undefinedundefinedserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"Once you have added serde, as explained above, modify your src/lib.rs file to match the following content:use std::str::FromStr;\n\nuse anyhow::Result;\nuse spin_sdk::{\n    http::{IntoResponse, Json, Params, Request, Response, Router},\n    http_component,\n    key_value::Store,\n    llm::{infer_with_options, InferencingModel::Llama2Chat},\n};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize)]\npub struct SentimentAnalysisRequest {\n    pub sentence: String,\n}\n\n#[derive(Serialize)]\npub struct SentimentAnalysisResponse {\n    pub sentiment: String,\n}\n\nconst PROMPT: &str = r#\"\\\n<<SYS>>\nYou are a bot that generates sentiment analysis responses. Respond with a single positive, negative, or neutral.\n<</SYS>>\n<INST>\nFollow the pattern of the following examples:\n\nUser: Hi, my name is Bob\nBot: neutral\n\nUser: I am so happy today\nBot: positive\n\nUser: I am so sad today\nBot: negative\n</INST>\n\nUser: {SENTENCE}\n\"#;\n\n/// A Spin HTTP component that internally routes requests.\n#[http_component]\nfn handle_route(req: Request) -> Response {\n    let mut router = Router::new();\n    router.any(\"/api/*\", not_found);\n    router.post(\"/api/sentiment-analysis\", perform_sentiment_analysis);\n    router.handle(req)\n}\n\nfn not_found(_: Request, _: Params) -> Result<impl IntoResponse> {\n    Ok(Response::new(404, \"Not found\"))\n}\n\nfn perform_sentiment_analysis(\n    req: http::Request<Json<SentimentAnalysisRequest>>,\n    _params: Params,\n) -> Result<impl IntoResponse> {\n    // Do some basic clean up on the input\n    let sentence = req.body().sentence.trim();\n    println!(\"Performing sentiment analysis on: {}\", sentence);\n\n    // Prepare the KV store\n    let kv = Store::open_default()?;\n\n    // If the sentiment of the sentence is already in the KV store, return it\n    if kv.exists(sentence).unwrap_or(false) {\n        println!(\"Found sentence in KV store returning cached sentiment\");\n        let sentiment = kv.get(sentence)?;\n        let resp = SentimentAnalysisResponse {\n            sentiment: String::from_utf8(sentiment.unwrap())?,\n        };\n        let resp_str = serde_json::to_string(&resp)?;\n\n        return Ok(Response::new(200, resp_str));\n    }\n    println!(\"Sentence not found in KV store\");\n\n    // Otherwise, perform sentiment analysis\n    println!(\"Running inference\");\n    let inferencing_result = infer_with_options(\n        Llama2Chat,\n        &PROMPT.replace(\"{SENTENCE}\", sentence),\n        spin_sdk::llm::InferencingParams {\n            max_tokens: 8,\n            ..Default::default()\n        },\n    )?;\n\n    println!(\"Inference result {:?}\", inferencing_result);\n\n    let sentiment = inferencing_result\n        .text\n        .lines()\n        .next()\n        .unwrap_or_default()\n        .strip_prefix(\"Bot:\")\n        .unwrap_or_default()\n        .parse::<Sentiment>();\n    println!(\"Got sentiment: {sentiment:?}\");\n\n    if let Ok(sentiment) = sentiment {\n        println!(\"Caching sentiment in KV store\");\n        let _ = kv.set(sentence, sentiment.as_str().as_bytes());\n    }\n\n    // Cache the result in the KV store\n    let resp = SentimentAnalysisResponse {\n        sentiment: sentiment\n            .as_ref()\n            .map(ToString::to_string)\n            .unwrap_or_default(),\n    };\n\n    let resp_str = serde_json::to_string(&resp)?;\n\n    Ok(Response::new(200, resp_str))\n}\n\n#[derive(Copy, Clone, Debug)]\nenum Sentiment {\n    Positive,\n    Negative,\n    Neutral,\n}\n\nimpl Sentiment {\n    fn as_str(&self) -> &str {\n        match self {\n            Self::Positive => \"positive\",\n            Self::Negative => \"negative\",\n            Self::Neutral => \"neutral\",\n        }\n    }\n}\n\nimpl std::fmt::Display for Sentiment {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.write_str(self.as_str())\n    }\n}\n\nimpl FromStr for Sentiment {\n    type Err = String;\n\n    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {\n        let sentiment = match s.trim() {\n            \"positive\" => Self::Positive,\n            \"negative\" => Self::Negative,\n            \"neutral\" => Self::Neutral,\n            _ => return Err(s.into()),\n        };\n        Ok(sentiment)\n    }\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}import {\n  HandleRequest,\n  HttpRequest,\n  HttpResponse,\n  Llm,\n  InferencingModels,\n  InferencingOptions,\n  Router,\n  Kv,\n} from \"@fermyon/spin-sdk\";\n\ninterface SentimentAnalysisRequest {\n  sentence: string;\n}\n\ninterface SentimentAnalysisResponse {\n  sentiment: \"negative\" | \"neutral\" | \"positive\";\n}\n\nconst decoder = new TextDecoder();\n\nconst PROMPT = `\\\n<<SYS>>\nYou are a bot that generates sentiment analysis responses. Respond with a single positive, negative, or neutral.\n<</SYS>>\n<INST>\nFollow the pattern of the following examples:\n\nHi, my name is Bob\nneutral\n\nI am so happy today\npositive\n\nI am so sad today\nnegative\n</INST>\n\n<SENTENCE>\n`;\n\nasync function performSentimentAnalysis(request: HttpRequest) {\n  // Parse sentence out of request\n  let data = request.json() as SentimentAnalysisRequest;\n  let sentence = data.sentence;\n  console.log(\"Performing sentiment analysis on: \" + sentence);\n\n  // Prepare the KV store\n  let kv = Kv.openDefault();\n\n  // If the sentiment of the sentence is already in the KV store, return it\n  if (kv.exists(sentence)) {\n    console.log(\"Found sentence in KV store returning cached sentiment\");\n    return {\n      status: 200,\n      body: JSON.stringify({\n        sentiment: decoder.decode(kv.get(sentence)),\n      } as SentimentAnalysisResponse),\n    };\n  }\n  console.log(\"Sentence not found in KV store\");\n\n  // Otherwise, perform sentiment analysis\n  console.log(\"Running inference\");\n  let options: InferencingOptions = { maxTokens: 6 };\n  let inferenceResult = Llm.infer(\n    InferencingModels.Llama2Chat,\n    PROMPT.replace(\"<SENTENCE>\", sentence),\n    options\n  );\n  console.log(\n    `Inference result (${inferenceResult.usage.generatedTokenCount} tokens): ${inferenceResult.text}`\n  );\n  let sentiment = inferenceResult.text.split(/\\s+/)[0]?.trim();\n\n  // Clean up result from inference\n  if (\n    sentiment === undefined ||\n    ![\"negative\", \"neutral\", \"positive\"].includes(sentiment)\n  ) {\n    sentiment = \"neutral\";\n    console.log(\"Invalid sentiment, marking it as neutral\");\n  }\n\n  // Cache the result in the KV store\n  console.log(\"Caching sentiment in KV store\");\n  kv.set(sentence, sentiment);\n\n  return {\n    status: 200,\n    body: JSON.stringify({\n      sentiment,\n    } as SentimentAnalysisResponse),\n  };\n}\n\nlet router = Router();\n\n// Map the route to the handler\nrouter.post(\"/api/sentiment-analysis\", async (_, req) => {\n  console.log(`${new Date().toISOString()} POST /sentiment-analysis`);\n  return await performSentimentAnalysis(req);\n});\n\n// Catch all 404 handler\nrouter.all(\"/api/*\", async (_, req) => {\n  return {\n    status: 404,\n    body: \"Not found\",\n  };\n});\n\n// Entry point to the Spin handler\nexport const handleRequest: HandleRequest = async function (\n  request: HttpRequest\n): Promise<HttpResponse> {\n  return await router.handleRequest(request, request);\n};{{ blockEnd }}{{ startTab \"Python\"}}from spin_http import Response\nfrom spin_llm import llm_infer\nfrom spin_key_value import kv_open_default\nimport json\nimport re\n\nPROMPT=\"\"\"<<SYS>>\nYou are a bot that generates sentiment analysis responses. Respond with a single positive, negative, or neutral.\n<</SYS>>\n[INST]\nFollow the pattern of the following examples:\n\nUser: Hi, my name is Bob\nBot: neutral\n\nUser: I am so happy today\nBot: positive\n\nUser: I am so sad today\nBot: negative\n\n[/INST]\nUser: \"\"\"\n\ndef handle_request(request):\n    # Extracting the sentence from the request\n    request_body=json.loads(request.body)\n    sentence=request_body[\"sentence\"].strip()\n    print(\"Performing sentiment analysis on: \" + sentence)\n\n    # Open the default KV store\n    store = kv_open_default()\n\n    # Check if the sentence is already in the KV store\n    if store.exists(sentence) is False:\n        result=llm_infer(\"llama2-chat\", PROMPT+sentence).text\n        print(\"Raw result: \" + result)\n        sentiment = get_sentiment_from_sentence(result)\n        print(\"Storing result in the KV store\")\n        store.set(sentence, str.encode(sentiment))\n    else:\n        sentiment = store.get(sentence).decode()\n        print(\"Found a cached result\")\n\n    response_body=json.dumps({\"sentence\": sentiment})\n\n    return Response(200,\n                    {\"content-type\": \"application/json\"},\n                    bytes(response_body, \"utf-8\"))\n\ndef get_sentiment_from_sentence(sentence) -> str:\n    words = sentence.lower().split()\n    sentiments = [\"positive\", \"negative\", \"neutral\"]\n    result = next((word for word in sentiments if word in words), None)\n\n    if result is not None:\n        return result\n    else:\n        print(\"Inconclusive, returning 'neutral'\")\n        return \"neutral\"{{ blockEnd }}{{ startTab \"TinyGo\"}}package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\n\tspinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n\t\"github.com/fermyon/spin/sdk/go/v2/kv\"\n\t\"github.com/fermyon/spin/sdk/go/v2/llm\"\n)\n\ntype sentimentAnalysisRequest struct {\n\tSentence string\n}\n\ntype sentimentAnalysisResponse struct {\n\tSentiment string\n}\n\nconst prompt = `\\\nYou are a bot that generates sentiment analysis responses. Respond with a single positive, negative, or neutral.\nHi, my name is Bob\nneutral\nI am so happy today\npositive\nI am so sad today\nnegative\n<SENTENCE>\n`\n\nfunc init() {\n\tspinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n\t\trouter := spinhttp.NewRouter()\n\t\trouter.POST(\"/api/sentiment-analysis\", performSentimentAnalysis)\n\t\trouter.ServeHTTP(w, r)\n\t})\n}\n\nfunc performSentimentAnalysis(w http.ResponseWriter, r *http.Request, ps spinhttp.Params) {\n\tvar req sentimentAnalysisRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tfmt.Printf(\"Performing sentiment analysis on: %q\\n\", req.Sentence)\n\n\t// Open the KV store\n\tstore, err := kv.OpenStore(\"default\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer store.Close()\n\n\t// If the sentiment of the sentence is already in the KV store, return it\n\texists, err := store.Exists(req.Sentence)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif exists {\n\t\tfmt.Println(\"Found sentence in KV store returning cached sentiment\")\n\t\tvalue, err := store.Get(req.Sentence)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tres := sentimentAnalysisResponse{\n\t\t\tSentiment: string(value),\n\t\t}\n\t\tif err := json.NewEncoder(w).Encode(res); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n\tfmt.Println(\"Sentence not found in KV store\")\n\n\t// Otherwise, perform sentiment analysis\n\tfmt.Println(\"Running inference\")\n\tparams := &llm.InferencingParams{\n\t\tMaxTokens:   10,\n\t\tTemperature: 0.5,\n\t}\n\n\tresult, err := llm.Infer(\"llama2-chat\", strings.Replace(prompt, \"<SENTENCE>\", req.Sentence, 1), params)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Inference result (%d tokens): %s\\n\", result.Usage.GeneratedTokenCount, result.Text)\n\n\tvar sentiment string\n\tif fields := strings.Fields(result.Text); len(fields) > 0 {\n\t\tsentiment = fields[0]\n\t}\n\n\t// Cache the result in the KV store\n\tfmt.Println(\"Caching sentiment in KV store\")\n\tstore.Set(req.Sentence, []byte(sentiment))\n\n\tres := &sentimentAnalysisResponse{\n\t\tSentiment: sentiment,\n\t}\n\tif err := json.NewEncoder(w).Encode(res); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n\nfunc main() {}\n{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#source-code"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Additional Functionality","content":"This application also includes two more components, a key/value explorer and static-fileserver component. Let's quickly go ahead and create those (letting Spin do all of the scaffolding for us).","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#additional-functionality"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Static Fileserver Component For The UI","content":"We use the spin add command to add the new static-fileserver that we will name ui:$ spin add -t static-fileserver\nEnter a name for your new component: ui\nHTTP path [/static/...]: /...\nDirectory containing the files to serve [assets]: assets\nWe create an assets directory where we can store files to serve statically (see the spin.toml file for more configuration information):$ mkdir assets","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#static-fileserver-component-for-the-ui"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Add the Front-End","content":"We can add a webpage that asks the user for some text and does the sentiment analysis on it. In your assets folder, create two files dynamic.js and index.html.Here's the code snippet for index.html<!DOCTYPE html>\n<html data-theme=\"cupcake\">\n  <head>\n    <title>Sentiment Analyzer</title>\n    <meta name=\"description\" content=\"Perform sentiment analysis\" />\n\n    <!-- Tailwind and Daisy UI -->\n    <link\n      href=\"https://cdn.jsdelivr.net/npm/daisyui@3.2.1/dist/full.css\"\n      rel=\"stylesheet\"\n      type=\"text/css\"\n    />\n    <script src=\"https://cdn.tailwindcss.com?plugins=typography\"></script>\n\n    <!-- Import script to make page dynamic -->\n    <script src=\"dynamic.js\"></script>\n  </head>\n\n  <body class=\"bg-base-200\">\n    <div id=\"alert\" class=\"fixed top-20 inset-x-0 w-1/2 mx-auto\"></div>\n    <div class=\"flex flex-col min-h-screen\">\n      <div\n        class=\"sticky top-0 z-30 flex h-16 w-full justify-center bg-opacity-90 backdrop-blur transition-all duration-100 bg-base-100 text-base-content shadow-md\"\n      >\n        <nav class=\"navbar w-full\">\n          <div class=\"flex-1\">\n            <a href=\"/\" class=\"btn btn-ghost text-4xl font-bold\"\n              >Sentiment Analyzer</a\n            >\n          </div>\n          <div class=\"flex-none\">\n            <a href=\"\" class=\"btn btn-warning\">Restart</a>\n          </div>\n        </nav>\n      </div>\n      <main class=\"mx-auto my-10 prose\">\n        <p>\n          This Sentiment Analyzer is a demonstration of how you can use Fermyon\n          Serverless AI to easily make an AI-powered API. When you type in a\n          sentence it is sent to a Spin app running in the Fermyon Cloud,\n          inferencing is performed using the Fermyon serverless AI feature, and\n          the response is cached in a Fermyon key/value store.\n        </p>\n        <p>\n          Note that LLM's are not perfect and the sentiment analysis performed\n          by this application is not guaranteed to be perfect.\n        </p>\n        <p>\n          To get started type a sentence below and press\n          <kbd class=\"kbd kbd-sm\">enter</kbd>.\n        </p>\n\n        <div class=\"flex flex-col gap-8 w-full\">\n          <input\n            id=\"sentence-input\"\n            type=\"text\"\n            placeholder=\"Type the sentence you want to analyze here\"\n            class=\"input w-full\"\n          />\n          <div>\n            <button class=\"btn btn-primary\" onclick=\"newCard()\">Analyze</button>\n          </div>\n        </div>\n      </main>\n    </div>\n  </body>\n</html>Here's the code snippet for dynamic.js// Listen for the Enter key being pressed\ndocument.addEventListener(\"keydown\", function (event) {\n  if (event.keyCode === 13) {\n    newCard();\n  }\n});\n\nvar globalCardCount = 0;\nvar runningInference = false;\n\nfunction newCard() {\n  if (runningInference) {\n    console.log(\"Already running inference, please wait...\");\n    setAlert(\"Already running inference, please wait...\");\n    return;\n  }\n  var inputElement = document.getElementById(\"sentence-input\");\n  var sentence = inputElement.value;\n  if (sentence === \"\") {\n    console.log(\"Please enter a sentence to analyze\");\n    setAlert(\"Please enter a sentence to analyze\");\n    return;\n  }\n  inputElement.value = \"\";\n\n  var cardIndex = globalCardCount;\n  globalCardCount++;\n  var newCard = document.createElement(\"div\");\n  newCard.id = \"card-\" + cardIndex;\n  newCard.innerHTML = `\n    <div class=\"card bg-base-100 shadow-xl w-full\">\n        <div class=\"m-4 flex flex-col gap-2\">\n            <div>${sentence}</div>\n            <div class=\"flex flex-row justify-end\">\n                <span class=\"loading loading-dots loading-sm\"></span>\n            </div>\n        </div>\n    </div>\n    `;\n  document.getElementById(\"sentence-input\").before(newCard);\n\n  console.log(\"Running inference on sentence: \" + sentence);\n  runningInference = true;\n  fetch(\"/api/sentiment-analysis\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({ sentence: sentence }),\n  })\n    .then((response) => response.json())\n    .then((data) => {\n      console.log(data);\n      updateCard(cardIndex, sentence, data.sentiment);\n    })\n    .catch((error) => {\n      console.log(error);\n    });\n}\n\nfunction updateCard(cardIndex, sentence, sentiment) {\n  badge = \"\";\n  if (sentiment === \"positive\") {\n    badge = `<span class=\"badge badge-success\">Positive</span>`;\n  } else if (sentiment === \"negative\") {\n    badge = `<span class=\"badge badge-error\">Negative</span>`;\n  } else if (sentiment === \"neutral\") {\n    badge = `<span class=\"badge badge-ghost\">Neutral</span>`;\n  } else {\n    badge = `<span class=\"badge badge-ghost\">Unsure</span>`;\n  }\n  var cardElement = document.getElementById(\"card-\" + cardIndex);\n  cardElement.innerHTML = `\n    <div class=\"card bg-base-100 shadow-xl w-full\">\n        <div class=\"m-4 flex flex-col gap-2\">\n            <div>${sentence}</div>\n            <div class=\"flex flex-row justify-end\">\n                ${badge}\n            </div>\n        </div>\n    </div>\n    `;\n  runningInference = false;\n}\n\nfunction setAlert(msg) {\n  var alertElement = document.getElementById(\"alert\");\n  alertElement.innerHTML = `\n    <div class=\"alert alert-error\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"stroke-current shrink-0 h-6 w-6\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z\" /></svg>\n        <span class=\"text-error-content\">${msg}</span>\n    </div>\n    `;\n  setTimeout(function () {\n    alertElement.innerHTML = \"\";\n  }, 3000);\n}","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#add-the-front-end"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Key Value Explorer","content":"For this, we install use a pre-made template by pointing to the templates GitHub repository:$ spin templates install --git https://github.com/spinframework/spin-kv-explorerThen, we again use spin add to add the new component. We will name the component  kv-explorer):$ spin add kv-explorer -t kv-explorer","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#key-value-explorer"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Application Manifest","content":"As shown below, the Spin framework has done all of the scaffolding for us:spin_manifest_version = 2\n\n[application]\nname = \"sentiment-analysis-rust\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"Descr\"\n\n[[trigger.http]]\nroute = \"/api/...\"\ncomponent = \"sentiment-analysis-rust\"\n\n[component.sentiment-analysis-rust]\nsource = \"target/wasm32-wasi/release/sentiment_analysis_rust.wasm\"\nallow_outbound_hosts = []\nai_models = [\"llama2-chat\"]\nkey_value_stores = [\"default\"]\n[component.sentiment-analysis-rust.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"ui\"\n\n[component.ui]\nsource = { url = \"https://github.com/spinframework/spin-fileserver/releases/download/v0.1.0/spin_static_fs.wasm\", digest = \"sha256:96c76d9af86420b39eb6cd7be5550e3cb5d4cc4de572ce0fd1f6a29471536cb4\" }\nfiles = [{ source = \"assets\", destination = \"/\" }]\n\n[[trigger.http]]\nroute = \"/internal/kv-explorer/...\"\ncomponent = \"kvv2\"\n\n[component.kv-explorer]\nsource = { url = \"https://github.com/spinframework/spin-kv-explorer/releases/download/v0.6.0/spin-kv-explorer.wasm\", digest = \"sha256:38110bc277a393cdfb1a885a0fd56923d47314b2086399d1e3bbcb6daa1f04ad\" }\n# add or remove stores you want to explore here\nkey_value_stores = [\"default\"]","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#application-manifest"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Building and Deploying Your Spin Application","content":"undefined Running inferencing on localhost (your CPU) is not as optimal as deploying to Fermyon's Serverless AI (where inferencing is performed by high-powered GPUs). You can skip this spin build --up step and move straight to spin cloud deploy if you:undefinedundefinedNow, let's build and run our Spin Application locally. (undefined If you are following along with the TypeScript/JavaScript example, you will first need to run npm install. Otherwise, please continue to the following spin command.)$ spin build --up","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#building-and-deploying-your-spin-application"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Test Locally","content":"# Create a new POST request to localhost\n$ curl -vXPOST 'localhost:3000/api/sentiment-analysis' -H'Content-Type: application/json' -d \"{\\\"sentence\\\": \\\"Well this is very nice indeed\\\" }\"\n\n{\"sentiment\":\"positive\"}","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#test-locally"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Deploy to Fermyon Cloud","content":"Deploying to the Fermyon Cloud is one simple command. If you have not logged into your Fermyon Cloud account already, the CLI will prompt you to login. Follow the instructions to complete the authorization process.$ spin cloud deploy","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#deploy-to-fermyon-cloud"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Testing in Fermyon Cloud","content":"# Create a new POST request to your apps URL in Fermyon Cloud\n$ curl -vXPOST 'https://abcxyz.fermyon.app/api/sentiment-analysis' -H'Content-Type: application/json' -d \"{\\\"sentence\\\": \\\"Well this is very nice indeed\\\" }\"\n\n{\"sentiment\":\"positive\"}","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#testing-in-fermyon-cloud"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Visit Fermyon Cloud UI","content":"Visiting your apps URL will produce a User Interface (UI) similar to the following.undefinedYou can type in a sentence, and the UI will respond with the sentiment analysis.undefined","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#visit-fermyon-cloud-ui"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Integrating Custom Domain and Storage","content":"The groundbreaking Fermyon Serverless AI introduces a revolutionary addition to the full-stack developer's arsenal. You can now seamlessly integrate the Fermyon undefined, undefined, and even your undefined with the launch of your very own advanced AI-enabled serverless applications.","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#integrating-custom-domain-and-storage"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Conclusion","content":"We want to get feedback on the Serverless AI API. We are curious about what models you would like to use and what applications you are building using Serverless AI. Let us know what you need, and how Fermyon's Serverless AI could potentially help solve a problem for you. We would love to help you write your new Serverless AI application.","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#conclusion"},{"project":"v2","title":"Sentiment Analysis With Serverless AI","subheading":"Next Steps","content":"undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/ai-sentiment-analysis-api-tutorial#next-steps"},{"project":"v2","title":"API Support Overview","subheading":"","content":"The following table shows the status of the interfaces Spin provides to applications.| Host Capabilities/Interfaces                 | Stability    | Cloud   |\n|----------------------------------------------|--------------|---------|\n| undefined               | Stable       | Yes |\n| undefined             | Stable       | No  |\n| undefined               | Experimental | No  |\n| undefined             | Stable       | Yes |\n| undefined           | Stable       | Yes |\n| undefined       | Stable       | Yes |\n| undefined                | Experimental | Yes |\n| undefined                     | Experimental | Yes |\n| undefined    | Stabilizing  | Yes |\n| undefined   | Experimental | Yes |\n| undefined         | Experimental | Yes |\n| undefined             | Experimental | No  |For more information about what is possible in the programming language of your choice, please see our undefined.","subsectionKeywords":"","url":"/v2/api-guides-overview"},{"project":"v2","title":"Building Spin Application Code","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedA Spin application is made up of one or more components. Components are binary Wasm modules; undefined refers to the process of converting your source code into those modules.undefinedBecause most compilers don't target Wasm by default, building Wasm modules often requires special command options, which you may not have at your fingertips.\nWhat's more, when developing a multi-component application, you may need to issue such commands for several components on each iteration.\nDoing this manually can be tedious and error-prone.To make the build process easier, the spin build command allows you to build all the components in one command.undefined","subsectionKeywords":"","url":"/v2/build"},{"project":"v2","title":"Building Spin Application Code","subheading":"Setting Up for  spin build","content":"To use spin build, each component that you want to build must specify the command used to build it in spin.toml, as part of its component.(name).build table:[component.hello]\n# This is the section you need for `spin build`\n[component.hello.build]\ncommand = \"npm run build\"If you generated the component from a Fermyon-supplied template, the build section should be set up correctly for you.  You don't need to change or add anything.undefined{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}For Rust applications, you must have the wasm32-wasi target installed:$ rustup target add wasm32-wasiThe build command typically runs cargo build with the wasm32-wasi target and the --release option:[component.hello.build]\ncommand = \"cargo build --target wasm32-wasi --release\"{{ blockEnd }}{{ startTab \"TypeScript\" }}For JavaScript and TypeScript applications, you must have undefined.It's normally convenient to put the detailed build instructions in package.json. The build script looks like:{\n  \"scripts\": {\n    \"build\": \"npx webpack --mode=production && npx mkdirp target && npx j2w -i dist.js -d combined-wit -n combined -o target/spin-http-js.wasm\"\n  }\n}{{ details \"Parts of the build script\" \"The build script calls out to undefined and j2w which is a script provided by the @fermyon/spin-sdk package that utilizes undefined.\"}}The build command can then call the NPM script:[component.hello.build]\ncommand = \"npm run build\"{{ blockEnd }}{{ startTab \"Python\" }}Ensure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.For Python applications, you must have undefined installed:$ pip3 install componentize-pyThe build command then calls componentize-py on your application file:[component.hello.build]\ncommand = \"componentize-py -w spin-http componentize app -o app.wasm\"{{ blockEnd }}{{ startTab \"TinyGo\" }}For Go applications, you must use the TinyGo compiler, as the standard Go compiler does not yet support the WASI standard.  See the undefined.The build command calls TinyGo with the WASI backend and appropriate options:[component.hello.build]\ncommand = \"tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"{{ blockEnd }}{{ blockEnd }}undefined","keywords":"","subsectionKeywords":"","url":"/v2/build#setting-up-for-spin-build"},{"project":"v2","title":"Building Spin Application Code","subheading":"Running  spin build","content":"Once the build commands are set up, running spin build will execute, sequentially, each build command:$ spin build\nBuilding component hello with `cargo build --target wasm32-wasi --release`\n    Updating crates.io index\n    Updating git repository `https://github.com/spinframework/spin`\n\n    //--snip--\n\n    Compiling hello v0.1.0 (hello)\n    Finished release [optimized] target(s) in 39.05s\nFinished building all Spin componentsundefined","keywords":"","subsectionKeywords":"","url":"/v2/build#running-spin-build"},{"project":"v2","title":"Building Spin Application Code","subheading":"Running the Application After Build","content":"You can pass the --up option to spin build to start the application as soon as the build process completes successfully.This is equivalent to running spin up immediately after spin build.  It accepts all the same flags and options that up does.  See undefined for details.","keywords":"","subsectionKeywords":"","url":"/v2/build#running-the-application-after-build"},{"project":"v2","title":"Building Spin Application Code","subheading":"Overriding the Working Directory","content":"By default, the command to build a component is executed in the directory containing the spin.toml file. If a component's entire build source is under a subdirectory, it is often more convenient to build in that subdirectory rather than try to pass the path to the build command. You can do this by setting the workdir option in the component.(id).build table.For example, consider this Rust component located in subdirectory deep:.\n├── deep\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.tomlTo have the Rust build command run in directory deep, we can set the component's workdir:[component.deep.build]\n# `command` is the normal build command for this language\ncommand = \"cargo build --target wasm32-wasi --release\"\n# This tells Spin to run it in the directory of the build file (in this case Cargo.toml)\nworkdir = \"deep\"undefined","keywords":"","subsectionKeywords":"","url":"/v2/build#overriding-the-working-directory"},{"project":"v2","title":"Building Spin Application Code","subheading":"Next Steps","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/build#next-steps"},{"project":"v2","title":"Spin Internal Data Layout","subheading":"","content":"undefinedundefinedundefinedundefinedThis page describes how Spin lays out its internal data on disk.undefinedundefined","subsectionKeywords":"","url":"/v2/cache"},{"project":"v2","title":"Spin Internal Data Layout","subheading":"Base Directories","content":"Spin uses similar layouts across Linux, MacOS and Windows platforms, but the paths to various areas of the user's home directory differ across the platforms. On this page, the following terms have the following meanings:| Name          | Linux                                    | MacOS                                | Windows |\n|---------------------|------------------------------------------|--------------------------------------|-------------------|\n| DATA_DIR    | $XDG_DATA_HOME or $HOME/.local/share | $HOME/Library/Application Support, or $HOMEBREW_PREFIX/etc/fermyon-spin if installed using Homebrew  | %LOCALAPPDATA% or %USERPROFILE%\\AppData\\Local |\n| CACHE_DIR   | $XDG_CACHE_HOME or $HOME/.cache      | $HOME/Library/Caches               | %LOCALAPPDATA% or %USERPROFILE%\\AppData\\Local |These directories are based on the undefined, and specifically on the cross-platform implementation in the undefined.undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/cache#base-directories"},{"project":"v2","title":"Spin Internal Data Layout","subheading":"Plugins","content":"Installed plugins are stored in (DATA_DIR)/spin/plugins.  A snapshot of the plugins registry is also stored under that directory at (DATA_DIR)/spin/plugins/.spin-plugins; this is structured as a Git repository.undefinedIf you delete the plugins directory, you will no longer be able to run your plugins (until you reinstall them), but other Spin operations will be unaffected.","keywords":"","subsectionKeywords":"","url":"/v2/cache#plugins"},{"project":"v2","title":"Spin Internal Data Layout","subheading":"Templates","content":"Installed templates are stored in (DATA_DIR)/spin/templates.undefinedIf you delete the templates directory, you will lose access to your installed templates (until you reinstall them), but other Spin operations will be unaffected.","keywords":"","subsectionKeywords":"","url":"/v2/cache#templates"},{"project":"v2","title":"Spin Internal Data Layout","subheading":"Application Cache","content":"Downloaded application data, such as applications downloaded from registries or Wasm modules downloaded from URLs, are stored in (CACHE_DIR)/spin/registry.If you delete the application cache directory, Spin will automatically re-download the files as needed.  Spin operations will be otherwise unaffected.","keywords":"","subsectionKeywords":"","url":"/v2/cache#application-cache"},{"project":"v2","title":"Spin Internal Data Layout","subheading":"Inside the Application Cache","content":"undefinedThe application cache is divided into three subdirectories, data, manifests, and wasm.The data directory contains all static assets referenced from applications distributed with remote registries. The wasm directory contains all component sources referenced either in applications distributed with remote registries, or component sources from HTTP endpoints, directly referenced in spin.toml.undefinedThe manifests directory contains the registry manifests for entire apps distributed with remote registries. They are placed in subdirectories that identify the application based on the registry, repository, and digest (or tag).The following tree command shows a typical (abbreviated) cache directory:$ tree ~/Library/Caches/spin/registry/\n\n├── data\n│   ├── sha256:41a4649a8a8c176133792119cb45a7686767d3fa376ffd656e2ff76a6071fb07\n│   └── sha256:da3fda2db338a73483068072e22f7e7eef27afdbae3db824e130932adce703ba\n├── manifests\n│   └── ghcr.io\n│       └── radu-matei\n│           ├── hello-registries\n│           │   └── latest\n│           │       ├── config.json\n│           │       └── manifest.json\n│           └── spin-openai-demo\n│               └── v1\n│                   ├── config.json\n│                   └── manifest.json\n└── wasm\n    ├── sha256:0b985e7d43e719f34cbb54849759a2f8e7913c0f9b17bf7cb2b3d2458d33859e\n    └── sha256:d5f9e1f6b61b90f7404e3800285f7860fe2cfc7d0116023efc370adbb403fe87","keywords":"","subsectionKeywords":"","url":"/v2/cache#inside-the-application-cache"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedThis page documents the Spin Command Line Interface (CLI).undefinedFor information on command stability, see the undefined.","subsectionKeywords":"","url":"/v2/cli-reference"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin add","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin add --help\nspin-add \nScaffold a new component into an existing application\n\nUSAGE:\n    spin add [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -f, --file <APP_MANIFEST_FILE>     Path to spin.toml\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin add --help\nspin-add \nScaffold a new component into an existing application\n\nUSAGE:\n    spin add [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -f, --file <APP_MANIFEST_FILE>     Path to spin.toml\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin add --help\nspin-add \nScaffold a new component into an existing application\n\nUSAGE:\n    spin add [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -f, --file <APP_MANIFEST_FILE>     Path to spin.toml\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin add --help\nspin-add \nScaffold a new component into an existing application\n\nUSAGE:\n    spin add [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -f, --file <APP_MANIFEST_FILE>     Path to spin.toml\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin add --help\nspin-add \nScaffold a new component into an existing application\n\nUSAGE:\n    spin add [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -f, --file <APP_MANIFEST_FILE>     Path to spin.toml\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n        --no-vcs                       An optional argument that allows to skip creating .gitignore\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin add --help\nspin-add \nScaffold a new component into an existing application\n\nUSAGE:\n    spin add [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -f, --file <APP_MANIFEST_FILE>     Path to spin.toml\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n        --no-vcs                       An optional argument that allows to skip creating .gitignore\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin add --help\nspin-add \nScaffold a new component into an existing application\n\nUSAGE:\n    spin add [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n        --allow-overwrite              If the output directory already contains files, generate the\n                                       new files into it without confirming, overwriting any\n                                       existing files with the same names\n    -f, --file <APP_MANIFEST_FILE>     Path to spin.toml\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n        --no-vcs                       An optional argument that allows to skip creating .gitignore\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-add"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin build","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin build --help\nspin-build \nBuild the Spin application\n\nUSAGE:\n    spin build [OPTIONS] [--] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -c, --component-id <COMPONENT_ID>...\n            Component ID to build. This can be specified multiple times. The default is all\n            components\n\n    -f, --from <APP_MANIFEST_FILE>\n            The application to build. This may be a manifest (spin.toml) file, or a directory\n            containing a spin.toml file. If omitted, it defaults to \"spin.toml\" [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n    -u, --up\n            Run the application after building{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin build --help\nspin-build \nBuild the Spin application\n\nUSAGE:\n    spin build [OPTIONS] [--] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -c, --component-id <COMPONENT_ID>...\n            Component ID to build. This can be specified multiple times. The default is all\n            components\n\n    -f, --from <APP_MANIFEST_FILE>\n            The application to build. This may be a manifest (spin.toml) file, or a directory\n            containing a spin.toml file. If omitted, it defaults to \"spin.toml\" [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n    -u, --up\n            Run the application after building{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin build --help\nspin-build \nBuild the Spin application\n\nUSAGE:\n    spin build [OPTIONS] [--] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -c, --component-id <COMPONENT_ID>...\n            Component ID to build. This can be specified multiple times. The default is all\n            components\n\n    -f, --from <APP_MANIFEST_FILE>\n            The application to build. This may be a manifest (spin.toml) file, or a directory\n            containing a spin.toml file. If omitted, it defaults to \"spin.toml\" [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n    -u, --up\n            Run the application after building{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin build --help\nspin-build \nBuild the Spin application\n\nUSAGE:\n    spin build [OPTIONS] [--] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -c, --component-id <COMPONENT_ID>...\n            Component ID to build. This can be specified multiple times. The default is all\n            components\n\n    -f, --from <APP_MANIFEST_FILE>\n            The application to build. This may be a manifest (spin.toml) file, or a directory\n            containing a spin.toml file. If omitted, it defaults to \"spin.toml\" [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n    -u, --up\n            Run the application after building{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin build --help\nspin-build \nBuild the Spin application\n\nUSAGE:\n    spin build [OPTIONS] [--] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -c, --component-id <COMPONENT_ID>...\n            Component ID to build. This can be specified multiple times. The default is all\n            components\n\n    -f, --from <APP_MANIFEST_FILE>\n            The application to build. This may be a manifest (spin.toml) file, or a directory\n            containing a spin.toml file. If omitted, it defaults to \"spin.toml\" [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n    -u, --up\n            Run the application after building{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin build --help\nspin-build \nBuild the Spin application\n\nUSAGE:\n    spin build [OPTIONS] [--] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -c, --component-id <COMPONENT_ID>...\n            Component ID to build. This can be specified multiple times. The default is all\n            components\n\n    -f, --from <APP_MANIFEST_FILE>\n            The application to build. This may be a manifest (spin.toml) file, or a directory\n            containing a spin.toml file. If omitted, it defaults to \"spin.toml\" [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n    -u, --up\n            Run the application after building{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin build --help\nspin-build \nBuild the Spin application\n\nUSAGE:\n    spin build [OPTIONS] [--] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -c, --component-id <COMPONENT_ID>...\n            Component ID to build. This can be specified multiple times. The default is all\n            components\n\n    -f, --from <APP_MANIFEST_FILE>\n            The application to build. This may be a manifest (spin.toml) file, or a directory\n            containing a spin.toml file. If omitted, it defaults to \"spin.toml\" [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n    -u, --up\n            Run the application after building{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-build"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin cloud","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}The spin cloud command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.1\"}}The spin cloud command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.3\"}}The spin cloud command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.4\"}}The spin cloud command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.5\"}}The spin cloud command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.6\"}}The spin cloud command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.7\"}}The spin cloud command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-cloud"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin cloud apps","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}The spin cloud apps command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.1\"}}The spin cloud apps command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.3\"}}The spin cloud apps command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.4\"}}The spin cloud apps command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.5\"}}The spin cloud apps command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.6\"}}The spin cloud apps command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.7\"}}The spin cloud apps command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-cloud-apps"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin cloud deploy","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}The spin cloud deploy command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.1\"}}The spin cloud deploy command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.3\"}}The spin cloud deploy command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.4\"}}The spin cloud deploy command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.5\"}}The spin cloud deploy command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.6\"}}The spin cloud deploy command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.7\"}}The spin cloud deploy command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-cloud-deploy"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin cloud link","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}The spin cloud link command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.1\"}}The spin cloud link command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.3\"}}The spin cloud link command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.4\"}}The spin cloud link command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.5\"}}The spin cloud link command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.6\"}}The spin cloud link command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.7\"}}The spin cloud link command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-cloud-link"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin cloud login","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}The spin cloud login command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.1\"}}The spin cloud login command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.3\"}}The spin cloud login command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.4\"}}The spin cloud login command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.5\"}}The spin cloud login command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.6\"}}The spin cloud login command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.7\"}}The spin cloud login command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-cloud-login"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin cloud sqlite","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}The spin cloud sqlite command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.1\"}}The spin cloud sqlite command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.3\"}}The spin cloud sqlite command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.4\"}}The spin cloud sqlite command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.5\"}}The spin cloud sqlite command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.6\"}}The spin cloud sqlite command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.7\"}}The spin cloud sqlite command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-cloud-sqlite"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin cloud unlink","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}The spin cloud unlink command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.1\"}}The spin cloud unlink command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.3\"}}The spin cloud unlink command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.4\"}}The spin cloud unlink command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.5\"}}The spin cloud unlink command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.6\"}}The spin cloud unlink command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.7\"}}The spin cloud unlink command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-cloud-unlink"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin cloud variables","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}The spin cloud variables command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.1\"}}The spin cloud variables command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.3\"}}The spin cloud variables command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.4\"}}The spin cloud variables command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.5\"}}The spin cloud variables command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.6\"}}The spin cloud variables command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.7\"}}The spin cloud variables command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-cloud-variables"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin deploy","content":"spin deploy is a shortcut to undefined.","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-deploy"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin doctor","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin doctor --help\n\nspin-doctor \nDetect and fix problems with Spin applications\n\nUSAGE:\n    spin doctor [OPTIONS]\n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to check. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin doctor --help\n\nspin-doctor \nDetect and fix problems with Spin applications\n\nUSAGE:\n    spin doctor [OPTIONS]\n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to check. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin doctor --help\n\nspin-doctor \nDetect and fix problems with Spin applications\n\nUSAGE:\n    spin doctor [OPTIONS]\n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to check. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin doctor --help\n\nspin-doctor \nDetect and fix problems with Spin applications\n\nUSAGE:\n    spin doctor [OPTIONS]\n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to check. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin doctor --help\n\nspin-doctor \nDetect and fix problems with Spin applications\n\nUSAGE:\n    spin doctor [OPTIONS]\n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to check. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin doctor --help\n\nspin-doctor \nDetect and fix problems with Spin applications\n\nUSAGE:\n    spin doctor [OPTIONS]\n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to check. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin doctor --help\n\nspin-doctor \nDetect and fix problems with Spin applications\n\nUSAGE:\n    spin doctor [OPTIONS]\n\nOPTIONS:\n    -f, --from <APP_MANIFEST_FILE>    The application to check. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-doctor"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin help","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}undefined{{ blockEnd }}{{ startTab \"v2.1\"}}undefined{{ blockEnd }}{{ startTab \"v2.3\"}}undefined{{ blockEnd }}{{ startTab \"v2.4\"}}undefined{{ blockEnd }}{{ startTab \"v2.5\"}}undefined{{ blockEnd }}{{ startTab \"v2.6\"}}undefined{{ blockEnd }}{{ startTab \"v2.7\"}}undefined{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-help"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin kube","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.5\"}}The spin kube command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.6\"}}The spin kube command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.7\"}}The spin kube command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-kube"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin kube completion","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.5\"}}The spin kube completion command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.6\"}}The spin kube completion command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.7\"}}The spin kube completion command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-kube-completion"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin kube scaffold","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.5\"}}The spin kube scaffold command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.6\"}}The spin kube scaffold command is implemented by the undefined.{{ blockEnd }}{{ startTab \"v2.7\"}}The spin kube scaffold command is implemented by the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-kube-scaffold"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin login","content":"spin login is a shortcut to undefined.","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-login"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin new","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin new --help  \n\nspin-new \nScaffold a new application based on a template\n\nUSAGE:\n    spin new [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin new --help  \n\nspin-new \nScaffold a new application based on a template\n\nUSAGE:\n    spin new [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin new --help  \n\nspin-new \nScaffold a new application based on a template\n\nUSAGE:\n    spin new [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin new --help  \n\nspin-new \nScaffold a new application based on a template\n\nUSAGE:\n    spin new [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n        --no-vcs                       An optional argument that allows to skip creating .gitignore\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin new --help  \n\nspin-new \nScaffold a new application based on a template\n\nUSAGE:\n    spin new [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n        --no-vcs                       An optional argument that allows to skip creating .gitignore\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin new --help  \n\nspin-new \nScaffold a new application based on a template\n\nUSAGE:\n    spin new [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n        --no-vcs                       An optional argument that allows to skip creating .gitignore\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin new --help  \n\nspin-new \nScaffold a new application based on a template\n\nUSAGE:\n    spin new [OPTIONS] [NAME]\n\nARGS:\n    <NAME>    The name of the new application or component\n\nOPTIONS:\n    -a, --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n        --allow-overwrite              If the output directory already contains files, generate the\n                                       new files into it without confirming, overwriting any\n                                       existing files with the same names\n    -h, --help                         Print help information\n        --init                         Create the new application or component in the current\n                                       directory\n        --no-vcs                       An optional argument that allows to skip creating .gitignore\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -t, --template <TEMPLATE_ID>       The template from which to create the new application or\n                                       component. Run `spin templates list` to see available options\n        --tag <TAGS>                   Filter templates to select by tags\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file{{ blockEnd }}{{ blockEnd }}undefined.  These commands are similar except that:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-new"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin plugins","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin plugins --help\n\nspin-plugins \nInstall/uninstall Spin plugins\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    search       Search for plugins by name\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin plugins --help\n\nspin-plugins \nInstall/uninstall Spin plugins\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    search       Search for plugins by name\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin plugins --help\n\nspin-plugins \nInstall/uninstall Spin plugins\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    search       Search for plugins by name\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin plugins --help\n\nspin-plugins \nInstall/uninstall Spin plugins\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    search       Search for plugins by name\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin plugins --help\n\nspin-plugins \nInstall/uninstall Spin plugins\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    search       Search for plugins by name\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin plugins --help\n\nspin-plugins \nInstall/uninstall Spin plugins\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    search       Search for plugins by name\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin plugins --help\n\nspin-plugins \nInstall/uninstall Spin plugins\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    search       Search for plugins by name\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-plugins"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin plugins install","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin plugins install --help\n\nspin-plugins-install \nInstall plugin from a manifest.\n\nThe binary file and manifest of the plugin is copied to the local Spin plugins directory.\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin plugins install --help\n\nspin-plugins-install \nInstall plugin from a manifest.\n\nThe binary file and manifest of the plugin is copied to the local Spin plugins directory.\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin plugins install --help\n\nspin-plugins-install \nInstall plugin from a manifest.\n\nThe binary file and manifest of the plugin is copied to the local Spin plugins directory.\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin plugins install --help\n\nspin-plugins-install \nInstall plugin from a manifest.\n\nThe binary file and manifest of the plugin is copied to the local Spin plugins directory.\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin plugins install --help\n\nspin-plugins-install \nInstall plugin from a manifest.\n\nThe binary file and manifest of the plugin is copied to the local Spin plugins directory.\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin plugins install --help\n\nspin-plugins-install \nInstall plugin from a manifest.\n\nThe binary file and manifest of the plugin is copied to the local Spin plugins directory.\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin plugins install --help\n\nspin-plugins-install \nInstall plugin from a manifest.\n\nThe binary file and manifest of the plugin is copied to the local Spin plugins directory.\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-plugins-install"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin plugins list","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin plugins list --help   \n\nspin-plugins-list \nList available or installed plugins\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n        --filter <FILTER>    Filter the list to plugins containing this string\n    -h, --help               Print help information\n        --installed          List only installed plugins{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin plugins list --help   \n\nspin-plugins-list \nList available or installed plugins\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n        --filter <FILTER>    Filter the list to plugins containing this string\n    -h, --help               Print help information\n        --installed          List only installed plugins{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin plugins list --help   \n\nspin-plugins-list \nList available or installed plugins\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n        --filter <FILTER>    Filter the list to plugins containing this string\n    -h, --help               Print help information\n        --installed          List only installed plugins{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin plugins list --help   \n\nspin-plugins-list \nList available or installed plugins\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n        --filter <FILTER>    Filter the list to plugins containing this string\n    -h, --help               Print help information\n        --installed          List only installed plugins{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin plugins list --help   \n\nspin-plugins-list \nList available or installed plugins\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n        --filter <FILTER>    Filter the list to plugins containing this string\n    -h, --help               Print help information\n        --installed          List only installed plugins{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin plugins list --help   \n\nspin-plugins-list \nList available or installed plugins\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n        --filter <FILTER>    Filter the list to plugins containing this string\n    -h, --help               Print help information\n        --installed          List only installed plugins{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin plugins list --help   \n\nspin-plugins-list \nList available or installed plugins\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n        --all                List all versions of plugins. This is the default behaviour\n        --filter <FILTER>    Filter the list to plugins containing this string\n    -h, --help               Print help information\n        --installed          List only installed plugins\n        --summary            List latest and installed versions of plugins{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-plugins-list"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin plugins search","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin plugins search --help\nspin-plugins-search \nSearch for plugins by name\n\nUSAGE:\n    spin plugins search [FILTER]\n\nARGS:\n    <FILTER>    The text to search for. If omitted, all plugins are returned\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin plugins search --help\nspin-plugins-search \nSearch for plugins by name\n\nUSAGE:\n    spin plugins search [FILTER]\n\nARGS:\n    <FILTER>    The text to search for. If omitted, all plugins are returned\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin plugins search --help\nspin-plugins-search \nSearch for plugins by name\n\nUSAGE:\n    spin plugins search [FILTER]\n\nARGS:\n    <FILTER>    The text to search for. If omitted, all plugins are returned\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin plugins search --help\nspin-plugins-search \nSearch for plugins by name\n\nUSAGE:\n    spin plugins search [FILTER]\n\nARGS:\n    <FILTER>    The text to search for. If omitted, all plugins are returned\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin plugins search --help\nspin-plugins-search \nSearch for plugins by name\n\nUSAGE:\n    spin plugins search [FILTER]\n\nARGS:\n    <FILTER>    The text to search for. If omitted, all plugins are returned\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin plugins search --help\nspin-plugins-search \nSearch for plugins by name\n\nUSAGE:\n    spin plugins search [FILTER]\n\nARGS:\n    <FILTER>    The text to search for. If omitted, all plugins are returned\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin plugins search --help\nspin-plugins-search \nSearch for plugins by name\n\nUSAGE:\n    spin plugins search [FILTER]\n\nARGS:\n    <FILTER>    The text to search for. If omitted, all plugins are returned\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-plugins-search"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin plugins uninstall","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin plugins uninstall --help\n\nspin-plugins-uninstall \nRemove a plugin from your installation\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin plugins uninstall --help\n\nspin-plugins-uninstall \nRemove a plugin from your installation\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin plugins uninstall --help\n\nspin-plugins-uninstall \nRemove a plugin from your installation\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin plugins uninstall --help\n\nspin-plugins-uninstall \nRemove a plugin from your installation\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin plugins uninstall --help\n\nspin-plugins-uninstall \nRemove a plugin from your installation\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin plugins uninstall --help\n\nspin-plugins-uninstall \nRemove a plugin from your installation\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin plugins uninstall --help\n\nspin-plugins-uninstall \nRemove a plugin from your installation\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-plugins-uninstall"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin plugins update","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin plugins update --help\n\nspin-plugins-update \nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin plugins update --help\n\nspin-plugins-update \nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin plugins update --help\n\nspin-plugins-update \nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin plugins update --help\n\nspin-plugins-update \nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin plugins update --help\n\nspin-plugins-update \nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin plugins update --help\n\nspin-plugins-update \nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin plugins update --help\n\nspin-plugins-update \nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-plugins-update"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin plugins upgrade","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin plugins upgrade --help\n\nspin-plugins-upgrade \nUpgrade one or all plugins\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin plugins upgrade --help\n\nspin-plugins-upgrade \nUpgrade one or all plugins\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin plugins upgrade --help\n\nspin-plugins-upgrade \nUpgrade one or all plugins\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin plugins upgrade --help\n\nspin-plugins-upgrade \nUpgrade one or all plugins\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin plugins upgrade --help\n\nspin-plugins-upgrade \nUpgrade one or all plugins\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin plugins upgrade --help\n\nspin-plugins-upgrade \nUpgrade one or all plugins\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin plugins upgrade --help\n\nspin-plugins-upgrade \nUpgrade one or all plugins\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]{{ blockEnd }}{{ blockEnd }}undefined For additional information, please see the undefined and/or undefined sections of the documentation.","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-plugins-upgrade"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin registry","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin registry --help\nspin-registry \nCommands for working with OCI registries to distribute applications\n\nUSAGE:\n    spin registry <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help     Print this message or the help of the given subcommand(s)\n    login    Log in to a registry\n    pull     Pull a Spin application from a registry\n    push     Push a Spin application to a registry{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin registry --help\nspin-registry \nCommands for working with OCI registries to distribute applications\n\nUSAGE:\n    spin registry <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help     Print this message or the help of the given subcommand(s)\n    login    Log in to a registry\n    pull     Pull a Spin application from a registry\n    push     Push a Spin application to a registry{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin registry --help\nspin-registry \nCommands for working with OCI registries to distribute applications\n\nUSAGE:\n    spin registry <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help     Print this message or the help of the given subcommand(s)\n    login    Log in to a registry\n    pull     Pull a Spin application from a registry\n    push     Push a Spin application to a registry{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin registry --help\nspin-registry \nCommands for working with OCI registries to distribute applications\n\nUSAGE:\n    spin registry <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help     Print this message or the help of the given subcommand(s)\n    login    Log in to a registry\n    pull     Pull a Spin application from a registry\n    push     Push a Spin application to a registry{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin registry --help\nspin-registry \nCommands for working with OCI registries to distribute applications\n\nUSAGE:\n    spin registry <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help     Print this message or the help of the given subcommand(s)\n    login    Log in to a registry\n    pull     Pull a Spin application from a registry\n    push     Push a Spin application to a registry{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin registry --help\nspin-registry \nCommands for working with OCI registries to distribute applications\n\nUSAGE:\n    spin registry <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help     Print this message or the help of the given subcommand(s)\n    login    Log in to a registry\n    pull     Pull a Spin application from a registry\n    push     Push a Spin application to a registry{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin registry --help\nspin-registry \nCommands for working with OCI registries to distribute applications\n\nUSAGE:\n    spin registry <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help     Print this message or the help of the given subcommand(s)\n    login    Log in to a registry\n    pull     Pull a Spin application from a registry\n    push     Push a Spin application to a registry{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-registry"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin registry login","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin registry login --help\n\nspin-registry-login \nLog in to a registry\n\nUSAGE:\n    spin registry login [OPTIONS] <SERVER>\n\nARGS:\n    <SERVER>    \n\nOPTIONS:\n    -h, --help                   Print help information\n    -p, --password <PASSWORD>    Password for the registry\n        --password-stdin         Take the password from stdin\n    -u, --username <USERNAME>    Username for the registry{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin registry login --help\n\nspin-registry-login \nLog in to a registry\n\nUSAGE:\n    spin registry login [OPTIONS] <SERVER>\n\nARGS:\n    <SERVER>    OCI registry server (e.g. ghcr.io)\n\nOPTIONS:\n    -h, --help                   Print help information\n    -p, --password <PASSWORD>    Password for the registry\n        --password-stdin         Take the password from stdin\n    -u, --username <USERNAME>    Username for the registry{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin registry login --help\n\nspin-registry-login \nLog in to a registry\n\nUSAGE:\n    spin registry login [OPTIONS] <SERVER>\n\nARGS:\n    <SERVER>    OCI registry server (e.g. ghcr.io)\n\nOPTIONS:\n    -h, --help                   Print help information\n    -p, --password <PASSWORD>    Password for the registry\n        --password-stdin         Take the password from stdin\n    -u, --username <USERNAME>    Username for the registry{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin registry login --help\n\nspin-registry-login \nLog in to a registry\n\nUSAGE:\n    spin registry login [OPTIONS] <SERVER>\n\nARGS:\n    <SERVER>    OCI registry server (e.g. ghcr.io)\n\nOPTIONS:\n    -h, --help                   Print help information\n    -p, --password <PASSWORD>    Password for the registry\n        --password-stdin         Take the password from stdin\n    -u, --username <USERNAME>    Username for the registry{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin registry login --help\n\nspin-registry-login \nLog in to a registry\n\nUSAGE:\n    spin registry login [OPTIONS] <SERVER>\n\nARGS:\n    <SERVER>    OCI registry server (e.g. ghcr.io)\n\nOPTIONS:\n    -h, --help                   Print help information\n    -p, --password <PASSWORD>    Password for the registry\n        --password-stdin         Take the password from stdin\n    -u, --username <USERNAME>    Username for the registry{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin registry login --help\n\nspin-registry-login \nLog in to a registry\n\nUSAGE:\n    spin registry login [OPTIONS] <SERVER>\n\nARGS:\n    <SERVER>    OCI registry server (e.g. ghcr.io)\n\nOPTIONS:\n    -h, --help                   Print help information\n    -p, --password <PASSWORD>    Password for the registry\n        --password-stdin         Take the password from stdin\n    -u, --username <USERNAME>    Username for the registry{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin registry login --help\n\nspin-registry-login \nLog in to a registry\n\nUSAGE:\n    spin registry login [OPTIONS] <SERVER>\n\nARGS:\n    <SERVER>    OCI registry server (e.g. ghcr.io)\n\nOPTIONS:\n    -h, --help                   Print help information\n    -p, --password <PASSWORD>    Password for the registry\n        --password-stdin         Take the password from stdin\n    -u, --username <USERNAME>    Username for the registry{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-registry-login"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin registry pull","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin registry pull --help\n\nspin-registry-pull \nPull a Spin application from a registry\n\nUSAGE:\n    spin registry pull [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n    -h, --help        Print help information\n    -k, --insecure    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin registry pull --help\n\nspin-registry-pull \nPull a Spin application from a registry\n\nUSAGE:\n    spin registry pull [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference in the registry of the published Spin application. This is a string\n                   whose format is defined by the registry standard, and generally consists of\n                   <registry>/<username>/<application-name>:<version>. E.g.\n                   ghcr.io/ogghead/spin-test-app:0.1.0\n\nOPTIONS:\n    -h, --help        Print help information\n    -k, --insecure    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin registry pull --help\n\nspin-registry-pull \nPull a Spin application from a registry\n\nUSAGE:\n    spin registry pull [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference in the registry of the published Spin application. This is a string\n                   whose format is defined by the registry standard, and generally consists of\n                   <registry>/<username>/<application-name>:<version>. E.g.\n                   ghcr.io/ogghead/spin-test-app:0.1.0\n\nOPTIONS:\n    -h, --help        Print help information\n    -k, --insecure    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin registry pull --help\n\nspin-registry-pull \nPull a Spin application from a registry\n\nUSAGE:\n    spin registry pull [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference in the registry of the published Spin application. This is a string\n                   whose format is defined by the registry standard, and generally consists of\n                   <registry>/<username>/<application-name>:<version>. E.g.\n                   ghcr.io/ogghead/spin-test-app:0.1.0\n\nOPTIONS:\n    -h, --help        Print help information\n    -k, --insecure    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin registry pull --help\n\nspin-registry-pull \nPull a Spin application from a registry\n\nUSAGE:\n    spin registry pull [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference in the registry of the published Spin application. This is a string\n                   whose format is defined by the registry standard, and generally consists of\n                   <registry>/<username>/<application-name>:<version>. E.g.\n                   ghcr.io/ogghead/spin-test-app:0.1.0\n\nOPTIONS:\n        --cache-dir <CACHE_DIR>    Cache directory for downloaded registry data\n    -h, --help                     Print help information\n    -k, --insecure                 Ignore server certificate errors{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin registry pull --help\n\nspin-registry-pull \nPull a Spin application from a registry\n\nUSAGE:\n    spin registry pull [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference in the registry of the published Spin application. This is a string\n                   whose format is defined by the registry standard, and generally consists of\n                   <registry>/<username>/<application-name>:<version>. E.g.\n                   ghcr.io/ogghead/spin-test-app:0.1.0\n\nOPTIONS:\n        --cache-dir <CACHE_DIR>    Cache directory for downloaded registry data\n    -h, --help                     Print help information\n    -k, --insecure                 Ignore server certificate errors{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin registry pull --help\n\nspin-registry-pull \nPull a Spin application from a registry\n\nUSAGE:\n    spin registry pull [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference in the registry of the published Spin application. This is a string\n                   whose format is defined by the registry standard, and generally consists of\n                   <registry>/<username>/<application-name>:<version>. E.g.\n                   ghcr.io/ogghead/spin-test-app:0.1.0\n\nOPTIONS:\n        --cache-dir <CACHE_DIR>    Cache directory for downloaded registry data\n    -h, --help                     Print help information\n    -k, --insecure                 Ignore server certificate errors{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-registry-pull"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin registry push","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin registry push --help \n\nspin-registry-push \nPush a Spin application to a registry\n\nUSAGE:\n    spin registry push [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference of the Spin application\n\nOPTIONS:\n        --build                       Specifies to perform `spin build` before pushing the\n                                      application [env: SPIN_ALWAYS_BUILD=]\n    -f, --from <APP_MANIFEST_FILE>    The application to push. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n    -k, --insecure                    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin registry push --help \n\nspin-registry-push \nPush a Spin application to a registry\n\nUSAGE:\n    spin registry push [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference in the registry of the Spin application. This is a string whose\n                   format is defined by the registry standard, and generally consists of\n                   <registry>/<username>/<application-name>:<version>. E.g.\n                   ghcr.io/ogghead/spin-test-app:0.1.0\n\nOPTIONS:\n        --build                       Specifies to perform `spin build` before pushing the\n                                      application [env: SPIN_ALWAYS_BUILD=]\n    -f, --from <APP_MANIFEST_FILE>    The application to push. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n    -k, --insecure                    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin registry push --help \n\nspin-registry-push \nPush a Spin application to a registry\n\nUSAGE:\n    spin registry push [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference in the registry of the Spin application. This is a string whose\n                   format is defined by the registry standard, and generally consists of\n                   <registry>/<username>/<application-name>:<version>. E.g.\n                   ghcr.io/ogghead/spin-test-app:0.1.0\n\nOPTIONS:\n        --build                       Specifies to perform `spin build` before pushing the\n                                      application [env: SPIN_ALWAYS_BUILD=]\n    -f, --from <APP_MANIFEST_FILE>    The application to push. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n    -k, --insecure                    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin registry push --help \n\nspin-registry-push \nPush a Spin application to a registry\n\nUSAGE:\n    spin registry push [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference in the registry of the Spin application. This is a string whose\n                   format is defined by the registry standard, and generally consists of\n                   <registry>/<username>/<application-name>:<version>. E.g.\n                   ghcr.io/ogghead/spin-test-app:0.1.0\n\nOPTIONS:\n        --build                       Specifies to perform `spin build` before pushing the\n                                      application [env: SPIN_ALWAYS_BUILD=]\n    -f, --from <APP_MANIFEST_FILE>    The application to push. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n    -k, --insecure                    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin registry push --help \n\nspin-registry-push \nPush a Spin application to a registry\n\nUSAGE:\n    spin registry push [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference in the registry of the Spin application. This is a string whose\n                   format is defined by the registry standard, and generally consists of\n                   <registry>/<username>/<application-name>:<version>. E.g.\n                   ghcr.io/ogghead/spin-test-app:0.1.0\n\nOPTIONS:\n        --annotation <ANNOTATIONS>    Specifies the OCI image manifest annotations (in key=value\n                                      format). Any existing value will be overwritten. Can be used\n                                      multiple times\n        --build                       Specifies to perform `spin build` before pushing the\n                                      application [env: SPIN_ALWAYS_BUILD=]\n        --cache-dir <CACHE_DIR>       Cache directory for downloaded registry data\n    -f, --from <APP_MANIFEST_FILE>    The application to push. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n    -k, --insecure                    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin registry push --help \n\nspin-registry-push \nPush a Spin application to a registry\n\nUSAGE:\n    spin registry push [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference in the registry of the Spin application. This is a string whose\n                   format is defined by the registry standard, and generally consists of\n                   <registry>/<username>/<application-name>:<version>. E.g.\n                   ghcr.io/ogghead/spin-test-app:0.1.0\n\nOPTIONS:\n        --annotation <ANNOTATIONS>    Specifies the OCI image manifest annotations (in key=value\n                                      format). Any existing value will be overwritten. Can be used\n                                      multiple times\n        --build                       Specifies to perform `spin build` before pushing the\n                                      application [env: SPIN_ALWAYS_BUILD=]\n        --cache-dir <CACHE_DIR>       Cache directory for downloaded registry data\n    -f, --from <APP_MANIFEST_FILE>    The application to push. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n    -k, --insecure                    Ignore server certificate errors{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin registry push --help \n\nspin-registry-push \nPush a Spin application to a registry\n\nUSAGE:\n    spin registry push [OPTIONS] <REFERENCE>\n\nARGS:\n    <REFERENCE>    Reference in the registry of the Spin application. This is a string whose\n                   format is defined by the registry standard, and generally consists of\n                   <registry>/<username>/<application-name>:<version>. E.g.\n                   ghcr.io/ogghead/spin-test-app:0.1.0\n\nOPTIONS:\n        --annotation <ANNOTATIONS>    Specifies the OCI image manifest annotations (in key=value\n                                      format). Any existing value will be overwritten. Can be used\n                                      multiple times\n        --build                       Specifies to perform `spin build` before pushing the\n                                      application [env: SPIN_ALWAYS_BUILD=]\n        --cache-dir <CACHE_DIR>       Cache directory for downloaded registry data\n    -f, --from <APP_MANIFEST_FILE>    The application to push. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n    -k, --insecure                    Ignore server certificate errors{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-registry-push"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin templates","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ startTab \"v2.2\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin templates --help    \n\nspin-templates \nCommands for working with WebAssembly component templates\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation\n    upgrade      Upgrade templates to match your current version of Spin{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-templates"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin templates install","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin templates install --help\n\nspin-templates-install \nInstall templates from a Git repository or local directory.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --upgrade\n            If present, updates existing templates instead of skipping{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin templates install --help\n\nspin-templates-install \nInstall templates from a Git repository or local directory.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --upgrade\n            If present, updates existing templates instead of skipping{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin templates install --help\n\nspin-templates-install \nInstall templates from a Git repository or local directory.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --upgrade\n            If present, updates existing templates instead of skipping{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin templates install --help\n\nspin-templates-install \nInstall templates from a Git repository or local directory.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --upgrade\n            If present, updates existing templates instead of skipping{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin templates install --help\n\nspin-templates-install \nInstall templates from a Git repository or local directory.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --upgrade\n            If present, updates existing templates instead of skipping{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin templates install --help\n\nspin-templates-install \nInstall templates from a Git repository or local directory.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --upgrade\n            If present, updates existing templates instead of skipping{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin templates install --help\n\nspin-templates-install \nInstall templates from a Git repository or local directory.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --upgrade\n            If present, updates existing templates instead of skipping{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-templates-install"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin templates list","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin templates list --help   \n\nspin-templates-list \nList the installed templates\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin templates list --help   \n\nspin-templates-list \nList the installed templates\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin templates list --help   \n\nspin-templates-list \nList the installed templates\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin templates list --help   \n\nspin-templates-list \nList the installed templates\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin templates list --help   \n\nspin-templates-list \nList the installed templates\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin templates list --help   \n\nspin-templates-list \nList the installed templates\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin templates list --help   \n\nspin-templates-list \nList the installed templates\n\nUSAGE:\n    spin templates list [OPTIONS]\n\nOPTIONS:\n    -h, --help          Print help information\n        --tag <TAGS>    Filter templates matching all provided tags\n        --verbose       Whether to show additional template details in the list{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-templates-list"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin templates uninstall","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin templates uninstall --help\n\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin templates uninstall --help\n\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin templates uninstall --help\n\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin templates uninstall --help\n\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin templates uninstall --help\n\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin templates uninstall --help\n\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin templates uninstall --help\n\nspin-templates-uninstall \nRemove a template from your installation\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-templates-uninstall"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin templates upgrade","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin templates upgrade --help\nspin-templates-upgrade \nUpgrade templates to match your current version of Spin.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates upgrade [OPTIONS]\n\nOPTIONS:\n        --all\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade all repositories without prompting\n\n        --branch <BRANCH>\n            The optional branch of the git repository, if a specific repository is given\n\n    -h, --help\n            Print help information\n\n        --repo <GIT_URL>\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade only the specified repository without\n            prompting{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin templates upgrade --help\nspin-templates-upgrade \nUpgrade templates to match your current version of Spin.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates upgrade [OPTIONS]\n\nOPTIONS:\n        --all\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade all repositories without prompting\n\n        --branch <BRANCH>\n            The optional branch of the git repository, if a specific repository is given\n\n    -h, --help\n            Print help information\n\n        --repo <GIT_URL>\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade only the specified repository without\n            prompting{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin templates upgrade --help\nspin-templates-upgrade \nUpgrade templates to match your current version of Spin.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates upgrade [OPTIONS]\n\nOPTIONS:\n        --all\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade all repositories without prompting\n\n        --branch <BRANCH>\n            The optional branch of the git repository, if a specific repository is given\n\n    -h, --help\n            Print help information\n\n        --repo <GIT_URL>\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade only the specified repository without\n            prompting{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin templates upgrade --help\nspin-templates-upgrade \nUpgrade templates to match your current version of Spin.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates upgrade [OPTIONS]\n\nOPTIONS:\n        --all\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade all repositories without prompting\n\n        --branch <BRANCH>\n            The optional branch of the git repository, if a specific repository is given\n\n    -h, --help\n            Print help information\n\n        --repo <GIT_URL>\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade only the specified repository without\n            prompting{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin templates upgrade --help\nspin-templates-upgrade \nUpgrade templates to match your current version of Spin.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates upgrade [OPTIONS]\n\nOPTIONS:\n        --all\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade all repositories without prompting\n\n        --branch <BRANCH>\n            The optional branch of the git repository, if a specific repository is given\n\n    -h, --help\n            Print help information\n\n        --repo <GIT_URL>\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade only the specified repository without\n            prompting{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin templates upgrade --help\nspin-templates-upgrade \nUpgrade templates to match your current version of Spin.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates upgrade [OPTIONS]\n\nOPTIONS:\n        --all\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade all repositories without prompting\n\n        --branch <BRANCH>\n            The optional branch of the git repository, if a specific repository is given\n\n    -h, --help\n            Print help information\n\n        --repo <GIT_URL>\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade only the specified repository without\n            prompting{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin templates upgrade --help\nspin-templates-upgrade \nUpgrade templates to match your current version of Spin.\n\nThe files of the templates are copied to the local template store: a directory in your data or home\ndirectory.\n\nUSAGE:\n    spin templates upgrade [OPTIONS]\n\nOPTIONS:\n        --all\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade all repositories without prompting\n\n        --branch <BRANCH>\n            The optional branch of the git repository, if a specific repository is given\n\n    -h, --help\n            Print help information\n\n        --repo <GIT_URL>\n            By default, Spin displays the list of installed repositories and prompts you to choose\n            which to upgrade.  Pass this flag to upgrade only the specified repository without\n            prompting{{ blockEnd }}{{ blockEnd }}undefined For additional information, please see the undefined and/or undefined sections of the documentation.","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-templates-upgrade"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin test","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.5\"}}$ spin test --help\n\nBy default `spin-test` will invoke the `run` subcommand.\n\nUsage: test [COMMAND]\n\nCommands:\n  run   Run a test suite against a Spin application\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help\n          Print help (see a summary with '-h')\n\n  -V, --version\n          Print version{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin test --help\n\nBy default `spin-test` will invoke the `run` subcommand.\n\nUsage: test [COMMAND]\n\nCommands:\n  run   Run a test suite against a Spin application\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help\n          Print help (see a summary with '-h')\n\n  -V, --version\n          Print version{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin test --help\n\nBy default `spin-test` will invoke the `run` subcommand.\n\nUsage: test [COMMAND]\n\nCommands:\n  run   Run a test suite against a Spin application\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help\n          Print help (see a summary with '-h')\n\n  -V, --version\n          Print version{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-test"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin up","content":"The following options are available in relation to running your Spin application.Note: There are three trigger options which only applies to the undefined (--listen, --tls-cert and --tls-key).{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin up --help\n\nspin-up \nStart the Spin application\n\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n        --build                 For local apps, specifies to perform `spin build` before running the\n                                application [env: SPIN_ALWAYS_BUILD=]\n        --direct-mounts         For local apps with directory mounts and no excluded files, mount\n                                them directly instead of using a temporary directory\n    -e, --env <ENV>             Pass an environment variable (key=value) to all components of the\n                                application\n    -f, --from <APPLICATION>    The application to run. This may be a manifest (spin.toml) file, a\n                                directory containing a spin.toml file, or a remote registry\n                                reference. If omitted, it defaults to \"spin.toml\"\n    -h, --help                  \n    -k, --insecure              Ignore server certificate errors from a registry\n        --temp <TMP>            Temporary directory for the static assets of the components\n\nTRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --disable-pooling\n            Enable Wasmtime's pooling instance allocator\n\n        --follow <FOLLOW_ID>\n            Print output to stdout/stderr only for given component(s)\n\n        --key-value <KEY_VALUES>\n            Set a key/value pair (key=value) in the application's default store. Any existing value\n            will be overwritten. Can be used multiple times\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components\n\n    -q, --quiet\n            Silence all component output to stdout/stderr\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]\n\n        --sqlite <SQLITE_STATEMENTS>\n            Run a SQLite statement such as a migration against the default database. To run from a\n            file, prefix the filename with @ e.g. spin up --sqlite @migration.sql\n\n        --state-dir <STATE_DIR>\n            Set the application state directory path. This is used in the default locations for\n            logs, key value stores, etc.\n            \n            For local apps, this defaults to `.spin/` relative to the `spin.toml` file. For remote\n            apps, this has no default (unset). Passing an empty value forces the value to be unset.{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin up --help\n\nspin-up \nStart the Spin application\n\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n        --build                 For local apps, specifies to perform `spin build` before running the\n                                application [env: SPIN_ALWAYS_BUILD=]\n        --direct-mounts         For local apps with directory mounts and no excluded files, mount\n                                them directly instead of using a temporary directory\n    -e, --env <ENV>             Pass an environment variable (key=value) to all components of the\n                                application\n    -f, --from <APPLICATION>    The application to run. This may be a manifest (spin.toml) file, a\n                                directory containing a spin.toml file, or a remote registry\n                                reference. If omitted, it defaults to \"spin.toml\"\n    -h, --help                  \n    -k, --insecure              Ignore server certificate errors from a registry\n        --temp <TMP>            Temporary directory for the static assets of the components\n\nTRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --disable-pooling\n            Enable Wasmtime's pooling instance allocator\n\n        --follow <FOLLOW_ID>\n            Print output to stdout/stderr only for given component(s)\n\n        --key-value <KEY_VALUES>\n            Set a key/value pair (key=value) in the application's default store. Any existing value\n            will be overwritten. Can be used multiple times\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components\n\n    -q, --quiet\n            Silence all component output to stdout/stderr\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]\n\n        --sqlite <SQLITE_STATEMENTS>\n            Run a SQLite statement such as a migration against the default database. To run from a\n            file, prefix the filename with @ e.g. spin up --sqlite @migration.sql\n\n        --state-dir <STATE_DIR>\n            Set the application state directory path. This is used in the default locations for\n            logs, key value stores, etc.\n            \n            For local apps, this defaults to `.spin/` relative to the `spin.toml` file. For remote\n            apps, this has no default (unset). Passing an empty value forces the value to be unset.{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin up --help\n\nspin-up \nStart the Spin application\n\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n        --build                 For local apps, specifies to perform `spin build` before running the\n                                application [env: SPIN_ALWAYS_BUILD=]\n        --direct-mounts         For local apps with directory mounts and no excluded files, mount\n                                them directly instead of using a temporary directory\n    -e, --env <ENV>             Pass an environment variable (key=value) to all components of the\n                                application\n    -f, --from <APPLICATION>    The application to run. This may be a manifest (spin.toml) file, a\n                                directory containing a spin.toml file, or a remote registry\n                                reference. If omitted, it defaults to \"spin.toml\"\n    -h, --help                  \n    -k, --insecure              Ignore server certificate errors from a registry\n        --temp <TMP>            Temporary directory for the static assets of the components\n\nHTTP TRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --disable-pooling\n            Disable Wasmtime's pooling instance allocator\n\n        --follow <FOLLOW_ID>\n            Print output to stdout/stderr only for given component(s)\n\n        --key-value <KEY_VALUES>\n            Set a key/value pair (key=value) in the application's default store. Any existing value\n            will be overwritten. Can be used multiple times\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components. Setting to the empty string\n            disables logging to disk\n            \n            [env: SPIN_LOG_DIR=]\n\n    -q, --quiet\n            Silence all component output to stdout/stderr\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]\n\n        --sqlite <SQLITE_STATEMENTS>\n            Run a SQLite statement such as a migration against the default database. To run from a\n            file, prefix the filename with @ e.g. spin up --sqlite @migration.sql\n\n        --state-dir <STATE_DIR>\n            Set the application state directory path. This is used in the default locations for\n            logs, key value stores, etc.\n            \n            For local apps, this defaults to `.spin/` relative to the `spin.toml` file. For remote\n            apps, this has no default (unset). Passing an empty value forces the value to be unset.{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin up --help\n\nspin-up \nStart the Spin application\n\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n        --build                 For local apps, specifies to perform `spin build` before running the\n                                application [env: SPIN_ALWAYS_BUILD=]\n        --cache-dir <CACHE_DIR>    Cache directory for downloaded components and assets\n        --direct-mounts         For local apps with directory mounts and no excluded files, mount\n                                them directly instead of using a temporary directory\n    -e, --env <ENV>             Pass an environment variable (key=value) to all components of the\n                                application\n    -f, --from <APPLICATION>    The application to run. This may be a manifest (spin.toml) file, a\n                                directory containing a spin.toml file, or a remote registry\n                                reference. If omitted, it defaults to \"spin.toml\"\n    -h, --help                  \n    -k, --insecure              Ignore server certificate errors from a registry\n        --temp <TMP>            Temporary directory for the static assets of the components\n\nHTTP TRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --disable-pooling\n            Disable Wasmtime's pooling instance allocator\n\n        --follow <FOLLOW_ID>\n            Print output to stdout/stderr only for given component(s)\n\n        --key-value <KEY_VALUES>\n            Set a key/value pair (key=value) in the application's default store. Any existing value\n            will be overwritten. Can be used multiple times\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components. Setting to the empty string\n            disables logging to disk\n            \n            [env: SPIN_LOG_DIR=]\n\n    -q, --quiet\n            Silence all component output to stdout/stderr\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]\n\n        --sqlite <SQLITE_STATEMENTS>\n            Run a SQLite statement such as a migration against the default database. To run from a\n            file, prefix the filename with @ e.g. spin up --sqlite @migration.sql\n\n        --state-dir <STATE_DIR>\n            Set the application state directory path. This is used in the default locations for\n            logs, key value stores, etc.\n            \n            For local apps, this defaults to `.spin/` relative to the `spin.toml` file. For remote\n            apps, this has no default (unset). Passing an empty value forces the value to be unset.{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin up --help\n\nspin-up \nStart the Spin application\n\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n        --build                    For local apps, specifies to perform `spin build` before running\n                                   the application [env: SPIN_ALWAYS_BUILD=]\n        --cache-dir <CACHE_DIR>    Cache directory for downloaded components and assets\n        --direct-mounts            For local apps with directory mounts and no excluded files, mount\n                                   them directly instead of using a temporary directory\n    -e, --env <ENV>                Pass an environment variable (key=value) to all components of the\n                                   application\n    -f, --from <APPLICATION>       The application to run. This may be a manifest (spin.toml) file,\n                                   a directory containing a spin.toml file, or a remote registry\n                                   reference. If omitted, it defaults to \"spin.toml\"\n    -h, --help                     \n    -k, --insecure                 Ignore server certificate errors from a registry\n        --temp <TMP>               Temporary directory for the static assets of the components\n\nHTTP TRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --disable-pooling\n            Disable Wasmtime's pooling instance allocator\n\n        --follow <FOLLOW_ID>\n            Print output to stdout/stderr only for given component(s)\n\n        --key-value <KEY_VALUES>\n            Set a key/value pair (key=value) in the application's default store. Any existing value\n            will be overwritten. Can be used multiple times\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components. Setting to the empty string\n            disables logging to disk\n            \n            [env: SPIN_LOG_DIR=]\n\n    -q, --quiet\n            Silence all component output to stdout/stderr\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]\n\n        --sqlite <SQLITE_STATEMENTS>\n            Run a SQLite statement such as a migration against the default database. To run from a\n            file, prefix the filename with @ e.g. spin up --sqlite @migration.sql\n\n        --state-dir <STATE_DIR>\n            Set the application state directory path. This is used in the default locations for\n            logs, key value stores, etc.\n            \n            For local apps, this defaults to `.spin/` relative to the `spin.toml` file. For remote\n            apps, this has no default (unset). Passing an empty value forces the value to be unset.{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin up --help\n\nspin-up \nStart the Spin application\n\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n        --build                    For local apps, specifies to perform `spin build` before running\n                                   the application [env: SPIN_ALWAYS_BUILD=]\n        --cache-dir <CACHE_DIR>    Cache directory for downloaded components and assets\n        --direct-mounts            For local apps with directory mounts and no excluded files, mount\n                                   them directly instead of using a temporary directory\n    -e, --env <ENV>                Pass an environment variable (key=value) to all components of the\n                                   application\n    -f, --from <APPLICATION>       The application to run. This may be a manifest (spin.toml) file,\n                                   a directory containing a spin.toml file, or a remote registry\n                                   reference. If omitted, it defaults to \"spin.toml\"\n    -h, --help                     \n    -k, --insecure                 Ignore server certificate errors from a registry\n        --temp <TMP>               Temporary directory for the static assets of the components\n\nHTTP TRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --disable-pooling\n            Disable Wasmtime's pooling instance allocator\n\n        --follow <FOLLOW_ID>\n            Print output to stdout/stderr only for given component(s)\n\n        --key-value <KEY_VALUES>\n            Set a key/value pair (key=value) in the application's default store. Any existing value\n            will be overwritten. Can be used multiple times\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components. Setting to the empty string\n            disables logging to disk\n            \n            [env: SPIN_LOG_DIR=]\n\n    -q, --quiet\n            Silence all component output to stdout/stderr\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]\n\n        --sqlite <SQLITE_STATEMENTS>\n            Run a SQLite statement such as a migration against the default database. To run from a\n            file, prefix the filename with @ e.g. spin up --sqlite @migration.sql\n\n        --state-dir <STATE_DIR>\n            Set the application state directory path. This is used in the default locations for\n            logs, key value stores, etc.\n            \n            For local apps, this defaults to `.spin/` relative to the `spin.toml` file. For remote\n            apps, this has no default (unset). Passing an empty value forces the value to be unset.{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin up --help\n\nspin-up \nStart the Spin application\n\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n        --build                    For local apps, specifies to perform `spin build` before running\n                                   the application [env: SPIN_ALWAYS_BUILD=]\n        --cache-dir <CACHE_DIR>    Cache directory for downloaded components and assets\n        --direct-mounts            For local apps with directory mounts and no excluded files, mount\n                                   them directly instead of using a temporary directory\n    -e, --env <ENV>                Pass an environment variable (key=value) to all components of the\n                                   application\n    -f, --from <APPLICATION>       The application to run. This may be a manifest (spin.toml) file,\n                                   a directory containing a spin.toml file, or a remote registry\n                                   reference. If omitted, it defaults to \"spin.toml\"\n    -h, --help                     \n    -k, --insecure                 Ignore server certificate errors from a registry\n        --temp <TMP>               Temporary directory for the static assets of the components\n\nHTTP TRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --disable-pooling\n            Disable Wasmtime's pooling instance allocator\n\n        --follow <FOLLOW_ID>\n            Print output to stdout/stderr only for given component(s)\n\n        --key-value <KEY_VALUES>\n            Set a key/value pair (key=value) in the application's default store. Any existing value\n            will be overwritten. Can be used multiple times\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components. Setting to the empty string\n            disables logging to disk\n            \n            [env: SPIN_LOG_DIR=]\n\n    -q, --quiet\n            Silence all component output to stdout/stderr\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]\n\n        --sqlite <SQLITE_STATEMENTS>\n            Run a SQLite statement such as a migration against the default database. To run from a\n            file, prefix the filename with @ e.g. spin up --sqlite @migration.sql\n\n        --state-dir <STATE_DIR>\n            Set the application state directory path. This is used in the default locations for\n            logs, key value stores, etc.\n            \n            For local apps, this defaults to `.spin/` relative to the `spin.toml` file. For remote\n            apps, this has no default (unset). Passing an empty value forces the value to be unset.{{ blockEnd }}{{ blockEnd }}undefined","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-up"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin up (HTTP Trigger)","content":"The following additional trigger options are available for the undefined command, when using the HTTP trigger. E.g. spin up --listen{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}--listen <ADDRESS>\n    IP address and port to listen on\n\n    [default: 127.0.0.1:3000]\n\n--tls-cert <TLS_CERT>\n    The path to the certificate to use for https, if this is not set, normal http will be\n    used. The cert should be in PEM format\n\n    [env: SPIN_TLS_CERT=]\n\n--tls-key <TLS_KEY>\n    The path to the certificate key to use for https, if this is not set, normal http will\n    be used. The key should be in PKCS#8 format\n\n    [env: SPIN_TLS_KEY=]{{ blockEnd }}{{ startTab \"v2.1\"}}--listen <ADDRESS>\n    IP address and port to listen on\n\n    [default: 127.0.0.1:3000]\n\n--tls-cert <TLS_CERT>\n    The path to the certificate to use for https, if this is not set, normal http will be\n    used. The cert should be in PEM format\n\n    [env: SPIN_TLS_CERT=]\n\n--tls-key <TLS_KEY>\n    The path to the certificate key to use for https, if this is not set, normal http will\n    be used. The key should be in PKCS#8 format\n\n    [env: SPIN_TLS_KEY=]{{ blockEnd }}{{ startTab \"v2.3\"}}--listen <ADDRESS>\n    IP address and port to listen on\n    \n    [default: 127.0.0.1:3000]\n\n--tls-cert <TLS_CERT>\n    The path to the certificate to use for https, if this is not set, normal http will be\n    used. The cert should be in PEM format\n    \n    [env: SPIN_TLS_CERT=]\n\n--tls-key <TLS_KEY>\n    The path to the certificate key to use for https, if this is not set, normal http will\n    be used. The key should be in PKCS#8 format\n    \n    [env: SPIN_TLS_KEY=]{{ blockEnd }}{{ startTab \"v2.4\"}}--listen <ADDRESS>\n    IP address and port to listen on\n    \n    [default: 127.0.0.1:3000]\n\n--tls-cert <TLS_CERT>\n    The path to the certificate to use for https, if this is not set, normal http will be\n    used. The cert should be in PEM format\n    \n    [env: SPIN_TLS_CERT=]\n\n--tls-key <TLS_KEY>\n    The path to the certificate key to use for https, if this is not set, normal http will\n    be used. The key should be in PKCS#8 format\n    \n    [env: SPIN_TLS_KEY=]{{ blockEnd }}{{ startTab \"v2.5\"}}--listen <ADDRESS>\n    IP address and port to listen on\n    \n    [default: 127.0.0.1:3000]\n\n--tls-cert <TLS_CERT>\n    The path to the certificate to use for https, if this is not set, normal http will be\n    used. The cert should be in PEM format\n    \n    [env: SPIN_TLS_CERT=]\n\n--tls-key <TLS_KEY>\n    The path to the certificate key to use for https, if this is not set, normal http will\n    be used. The key should be in PKCS#8 format\n    \n    [env: SPIN_TLS_KEY=]{{ blockEnd }}{{ startTab \"v2.6\"}}--listen <ADDRESS>\n    IP address and port to listen on\n\n    [env: SPIN_HTTP_LISTEN_ADDR=]\n    [default: 127.0.0.1:3000]\n\n--tls-cert <TLS_CERT>\n    The path to the certificate to use for https, if this is not set, normal http will be\n    used. The cert should be in PEM format\n    \n    [env: SPIN_TLS_CERT=]\n\n--tls-key <TLS_KEY>\n    The path to the certificate key to use for https, if this is not set, normal http will\n    be used. The key should be in PKCS#8 format\n    \n    [env: SPIN_TLS_KEY=]{{ blockEnd }}{{ startTab \"v2.7\"}}--listen <ADDRESS>\n    IP address and port to listen on\n\n    [env: SPIN_HTTP_LISTEN_ADDR=]\n    [default: 127.0.0.1:3000]\n\n--tls-cert <TLS_CERT>\n    The path to the certificate to use for https, if this is not set, normal http will be\n    used. The cert should be in PEM format\n    \n    [env: SPIN_TLS_CERT=]\n\n--tls-key <TLS_KEY>\n    The path to the certificate key to use for https, if this is not set, normal http will\n    be used. The key should be in PKCS#8 format\n    \n    [env: SPIN_TLS_KEY=]{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-up-http-trigger"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"spin watch","content":"{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}$ spin watch --help\nspin-watch \nBuild and run the Spin application, rebuilding and restarting it when files change\n\nUSAGE:\n    spin watch [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    Arguments to be passed through to spin up\n\nOPTIONS:\n    -c, --clear                       Clear the screen before each run\n    -d, --debounce <DEBOUNCE>         Set the timeout between detected change and re-execution, in\n                                      milliseconds [default: 100]\n    -f, --from <APP_MANIFEST_FILE>    The application to watch. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n        --skip-build                  Only run the Spin application, restarting it when build\n                                      artifacts change{{ blockEnd }}{{ startTab \"v2.1\"}}$ spin watch --help\nspin-watch \nBuild and run the Spin application, rebuilding and restarting it when files change\n\nUSAGE:\n    spin watch [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    Arguments to be passed through to spin up\n\nOPTIONS:\n    -c, --clear                       Clear the screen before each run\n    -d, --debounce <DEBOUNCE>         Set the timeout between detected change and re-execution, in\n                                      milliseconds [default: 100]\n    -f, --from <APP_MANIFEST_FILE>    The application to watch. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n        --skip-build                  Only run the Spin application, restarting it when build\n                                      artifacts change{{ blockEnd }}{{ startTab \"v2.3\"}}$ spin watch --help\nspin-watch \nBuild and run the Spin application, rebuilding and restarting it when files change\n\nUSAGE:\n    spin watch [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    Arguments to be passed through to spin up\n\nOPTIONS:\n    -c, --clear                       Clear the screen before each run\n    -d, --debounce <DEBOUNCE>         Set the timeout between detected change and re-execution, in\n                                      milliseconds [default: 100]\n    -f, --from <APP_MANIFEST_FILE>    The application to watch. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n        --skip-build                  Only run the Spin application, restarting it when build\n                                      artifacts change{{ blockEnd }}{{ startTab \"v2.4\"}}$ spin watch --help\nspin-watch \nBuild and run the Spin application, rebuilding and restarting it when files change\n\nUSAGE:\n    spin watch [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    Arguments to be passed through to spin up\n\nOPTIONS:\n    -c, --clear                       Clear the screen before each run\n    -d, --debounce <DEBOUNCE>         Set the timeout between detected change and re-execution, in\n                                      milliseconds [default: 100]\n    -f, --from <APP_MANIFEST_FILE>    The application to watch. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n        --skip-build                  Only run the Spin application, restarting it when build\n                                      artifacts change{{ blockEnd }}{{ startTab \"v2.5\"}}$ spin watch --help\nspin-watch \nBuild and run the Spin application, rebuilding and restarting it when files change\n\nUSAGE:\n    spin watch [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    Arguments to be passed through to spin up\n\nOPTIONS:\n    -c, --clear                       Clear the screen before each run\n    -d, --debounce <DEBOUNCE>         Set the timeout between detected change and re-execution, in\n                                      milliseconds [default: 100]\n    -f, --from <APP_MANIFEST_FILE>    The application to watch. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n        --skip-build                  Only run the Spin application, restarting it when build\n                                      artifacts change{{ blockEnd }}{{ startTab \"v2.6\"}}$ spin watch --help\nspin-watch \nBuild and run the Spin application, rebuilding and restarting it when files change\n\nUSAGE:\n    spin watch [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    Arguments to be passed through to spin up\n\nOPTIONS:\n    -c, --clear                       Clear the screen before each run\n    -d, --debounce <DEBOUNCE>         Set the timeout between detected change and re-execution, in\n                                      milliseconds [default: 100]\n    -f, --from <APP_MANIFEST_FILE>    The application to watch. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n        --skip-build                  Only run the Spin application, restarting it when build\n                                      artifacts change{{ blockEnd }}{{ startTab \"v2.7\"}}$ spin watch --help\nspin-watch \nBuild and run the Spin application, rebuilding and restarting it when files change\n\nUSAGE:\n    spin watch [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    Arguments to be passed through to spin up\n\nOPTIONS:\n    -c, --clear                       Clear the screen before each run\n    -d, --debounce <DEBOUNCE>         Set the timeout between detected change and re-execution, in\n                                      milliseconds [default: 100]\n    -f, --from <APP_MANIFEST_FILE>    The application to watch. This may be a manifest (spin.toml)\n                                      file, or a directory containing a spin.toml file. If omitted,\n                                      it defaults to \"spin.toml\" [default: spin.toml]\n    -h, --help                        Print help information\n        --skip-build                  Only run the Spin application, restarting it when build\n                                      artifacts change{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#spin-watch"},{"project":"v2","title":"Spin Command Line Interface (CLI) Reference","subheading":"Stability Table","content":"CLI commands have four phases that indicate levels of stability:undefinedundefinedundefinedundefined{{ tabs \"spin-version\" }}{{ startTab \"v2.0\"}}| Command                                                                               | Stability    |\n| ------------------------------------------------------------------------------------- | ------------ |\n| <code>spin add</code>                                                                 | Stable       |\n| <code>spin build</code>                                                               | Stable       |\n| <code>spin new</code>                                                                 | Stable       |\n| <code>spin plugins</code>                                                             | Stable       |\n| <code>spin templates</code>                                                           | Stable       |\n| <code>spin up</code>                                                                  | Stable       |\n| <code>spin cloud</code>                                                               | Stabilizing  |\n| <code>spin registry</code>                                                            | Stabilizing  |\n| <code>spin doctor</code>                                                              | Experimental |\n| <code>spin watch</code>                                                               | Experimental |{{ blockEnd }}{{ startTab \"v2.1\"}}| Command                                                                               | Stability    |\n| ------------------------------------------------------------------------------------- | ------------ |\n| <code>spin add</code>                                                                 | Stable       |\n| <code>spin build</code>                                                               | Stable       |\n| <code>spin new</code>                                                                 | Stable       |\n| <code>spin plugins</code>                                                             | Stable       |\n| <code>spin templates</code>                                                           | Stable       |\n| <code>spin up</code>                                                                  | Stable       |\n| <code>spin cloud</code>                                                               | Stabilizing  |\n| <code>spin registry</code>                                                            | Stabilizing  |\n| <code>spin doctor</code>                                                              | Experimental |\n| <code>spin watch</code>                                                               | Experimental |{{ blockEnd }}{{ startTab \"v2.3\"}}| Command                                                                               | Stability    |\n| ------------------------------------------------------------------------------------- | ------------ |\n| <code>spin add</code>                                                                 | Stable       |\n| <code>spin build</code>                                                               | Stable       |\n| <code>spin new</code>                                                                 | Stable       |\n| <code>spin plugins</code>                                                             | Stable       |\n| <code>spin templates</code>                                                           | Stable       |\n| <code>spin up</code>                                                                  | Stable       |\n| <code>spin cloud</code>                                                               | Stabilizing  |\n| <code>spin registry</code>                                                            | Stabilizing  |\n| <code>spin doctor</code>                                                              | Experimental |\n| <code>spin watch</code>                                                               | Experimental |{{ blockEnd }}{{ startTab \"v2.4\"}}| Command                                                                               | Stability    |\n| ------------------------------------------------------------------------------------- | ------------ |\n| <code>spin add</code>                                                                 | Stable       |\n| <code>spin build</code>                                                               | Stable       |\n| <code>spin new</code>                                                                 | Stable       |\n| <code>spin plugins</code>                                                             | Stable       |\n| <code>spin templates</code>                                                           | Stable       |\n| <code>spin up</code>                                                                  | Stable       |\n| <code>spin cloud</code>                                                               | Stabilizing  |\n| <code>spin registry</code>                                                            | Stabilizing  |\n| <code>spin doctor</code>                                                              | Experimental |\n| <code>spin watch</code>                                                               | Experimental |{{ blockEnd }}{{ startTab \"v2.5\"}}| Command                                                                               | Stability    |\n| ------------------------------------------------------------------------------------- | ------------ |\n| <code>spin add</code>                                                                 | Stable       |\n| <code>spin build</code>                                                               | Stable       |\n| <code>spin new</code>                                                                 | Stable       |\n| <code>spin plugins</code>                                                             | Stable       |\n| <code>spin templates</code>                                                           | Stable       |\n| <code>spin up</code>                                                                  | Stable       |\n| <code>spin cloud</code>                                                               | Stabilizing  |\n| <code>spin registry</code>                                                            | Stabilizing  |\n| <code>spin doctor</code>                                                              | Experimental |\n| <code>spin watch</code>                                                               | Experimental |\n| <code>spin test</code>                                                                | Experimental |\n{{ blockEnd }}{{ startTab \"v2.6\"}}| Command                                                                               | Stability    |\n| ------------------------------------------------------------------------------------- | ------------ |\n| <code>spin add</code>                                                                 | Stable       |\n| <code>spin build</code>                                                               | Stable       |\n| <code>spin new</code>                                                                 | Stable       |\n| <code>spin plugins</code>                                                             | Stable       |\n| <code>spin templates</code>                                                           | Stable       |\n| <code>spin up</code>                                                                  | Stable       |\n| <code>spin cloud</code>                                                               | Stabilizing  |\n| <code>spin registry</code>                                                            | Stabilizing  |\n| <code>spin doctor</code>                                                              | Experimental |\n| <code>spin watch</code>                                                               | Experimental |\n| <code>spin test</code>                                                                | Experimental |\n{{ blockEnd }}{{ startTab \"v2.7\"}}| Command                                                                               | Stability    |\n| ------------------------------------------------------------------------------------- | ------------ |\n| <code>spin add</code>                                                                 | Stable       |\n| <code>spin build</code>                                                               | Stable       |\n| <code>spin new</code>                                                                 | Stable       |\n| <code>spin plugins</code>                                                             | Stable       |\n| <code>spin templates</code>                                                           | Stable       |\n| <code>spin up</code>                                                                  | Stable       |\n| <code>spin cloud</code>                                                               | Stabilizing  |\n| <code>spin registry</code>                                                            | Stabilizing  |\n| <code>spin doctor</code>                                                              | Experimental |\n| <code>spin watch</code>                                                               | Experimental |\n| <code>spin test</code>                                                                | Experimental |\n{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/cli-reference#stability-table"},{"project":"v2","title":"Contributing to Docs","subheading":"","content":"undefinedundefinedundefinedundefinedWe are delighted that you are interested in making our developer documentation better. Thank you! We welcome and appreciate contributions of all types — opening issues, fixing typos, adding examples, one-liner code fixes, tests, or complete features.Any contribution and interaction on any Fermyon project MUST follow our undefined. Thank you for being part of an inclusive and open community!Below are a few pointers designed to help you contribute.","keywords":"contribute contributing","subsectionKeywords":"","url":"/v2/contributing-docs"},{"project":"v2","title":"Contributing to Docs","subheading":"Technical Documentation Types","content":"The following points will help guide your contribution from a resource-type perspective; essentially we would really appreciate you creating and contributing any of the following 4 resource types.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#technical-documentation-types"},{"project":"v2","title":"Contributing to Docs","subheading":"1. Tutorials","content":"Tutorials are oriented toward learning. Tutorials are designed to get a user started on something new (that they have not tried before). You can think of a tutorial as a lesson i.e. teaching a Spin user undefined. The tutorial may contain many logically ordered steps i.e. installing Spin, installing Redis, using Spin templates, configuring a Spin application and so forth. The desired outcome for a tutorial is for the user to have a working deployment or application. Think of it as a lesson in how to bake a cake.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#1-tutorials"},{"project":"v2","title":"Contributing to Docs","subheading":"2. How-To Guides","content":"How-to guides are oriented towards showing a user how to solve a problem, which leads them to be able to achieve their own goal. The how-to guide will follow a series of logical steps. Think of it as providing a recipe for the user's creativity. For example, you can show a user how to undefined without telling them what the application must do; that is up to the user's imagination.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#2-how-to-guides"},{"project":"v2","title":"Contributing to Docs","subheading":"3. Reference","content":"Reference resources are merely a dry description; describing the feature in its simplest form. A great example of a reference resource is the undefined. You will notice that the CLI Reference page simply lists all of the commands and available options.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#3-reference"},{"project":"v2","title":"Contributing to Docs","subheading":"4. Explanation","content":"An explanation resource is written using a deep-dive approach i.e. providing a deep explanation with the view to impart a deep understanding of a particular concept, feature or product. You may find your contribution is so in-depth that it becomes a long form article like a blog post. If that is the case, please get in touch and we can discuss options around getting your content published on another platform; like the undefined.undefinedYou will notice that the menu system is organized in terms of \"Tutorial\", \"How-To\", \"Reference\" and so forth. When you write your contribution please decide which product (Cloud, Spin, Bartholomew) category it falls into and also which resource type it aligns with. Armed with that information you can go ahead and create your new file. For example, your \"how-to\" resource on \"developing a Spin application\" in Fermyon cloud would be saved to the content/cloud/ folder; specifically, content/cloud/develop.md and the menu item (for the left-hand-side menu) would be added to the templates/cloud_sidebar.hbs file, as shown below.undefinedThe resulting output would be as follows.undefined","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#4-explanation"},{"project":"v2","title":"Contributing to Docs","subheading":"Documents Relevant to Two or More Projects","content":"If a document is relevant to two or more projects, the dynamic body feature of bartholomew is to be used. Create the document in one of the projects with the content. In the other project(s) create a file with only the frontmatter. Then add the following field to the frontmatter:.\n.\nbody_source = \"<path to the content>\"\n\n[extra]\nThe value for the body_source key, should be the path from which the content is being shared (relative to the repository's content folder). For example if the Spin project's developer/content/spin/v2/contributing-docs.md holds the sharable content (as the single source of truth), then the Cloud project can display that same content by using the following frontmatter:title = \"Contributing to Docs\"\ntemplate = \"cloud_main\"\ndate = \"2023-11-04T00:00:01Z\"\nbody_source = \"/spin/contributing-docs\"\n\n[extra]\nurl = \"https://github.com/spinframework/spin-docs/blob/main/content/cloud/contributing-docs.md\"\nkeywords = \"contribute contributing\"\n\n---undefined","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#documents-relevant-to-two-or-more-projects"},{"project":"v2","title":"Contributing to Docs","subheading":"Technical Documentation Procedure (Video)","content":"","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#technical-documentation-procedure-video"},{"project":"v2","title":"Contributing to Docs","subheading":"Technical Documentation Procedure (Text)","content":"","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#technical-documentation-procedure-text"},{"project":"v2","title":"Contributing to Docs","subheading":"1. Fork the Repository","content":"The first step is to fork the undefined, from Fermyon's GitHub, to your own GitHub account.undefinedEnsure that you are forking the developer repository undefined GitHub account; where you have full editing privileges.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#1-fork-the-repository"},{"project":"v2","title":"Contributing to Docs","subheading":"2. Clone the Fork","content":"Copy the URL from the UI in readiness for running the git clone command.undefinedGo ahead and clone the new fork that you just created (the one which resides in your own GitHub account):$ cd ~\n$ git clone git@github.com:yourusername/developer.git\n$ cd developer","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#2-clone-the-fork"},{"project":"v2","title":"Contributing to Docs","subheading":"3. Create New Branch","content":"Create a new branch that will house all of your changes for this specific contribution:$ git checkout -b my_new_branch","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#3-create-new-branch"},{"project":"v2","title":"Contributing to Docs","subheading":"4. Add Upstream","content":"Create a new remote for the upstream (a pointer to the original repository to which you are contributing):$ git remote add upstream https://github.com/fermyon/developer","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#4-add-upstream"},{"project":"v2","title":"Contributing to Docs","subheading":"5. Code Blocks, Annotations and Table of Contents (ToC)","content":"It is highly recommended that you use either the <!-- @selectiveCpy --> or the <!-- @nocpy --> annotation before each of your code blocks, and that each code block defines the appropriate undefined. The annotation can be skipped for code blocks with example code snippets i.e. non-terminal or generic output examples.undefinedThe selective copy annotation (<!-- @selectiveCpy -->) is intended for use when communicating code and/or CLI commands for the reader to copy and paste. The selective copy annotation allows the reader to see the entire code block (both commands and results) but only copies the lines that start with $ into the reader's clipboard (minus the $) when the user clicks the copy button. For example, copying the following code block will only copy echo \"hello\" into your clipboard, for pasting.$ echo \"hello\"\nhelloundefinedundefinedThe no copy annotation (<!-- @nocpy -->) precedes a code block where no copy and pasting of code is intended. If using the no copy attribute please still be sure to add the appropriate syntax highlighting to your code block (for display purposes). For example:undefinedPlease find copyable snippet below, for your convenience:<!-- @nocpy -->\n\n```text\nSome generic code not intended for copying/pasting\n```The above markdown will render the following code block on the web page:Some generic code not intended for copying/pastingundefined - just a straight copy without any additional features.If you want the code in a code block to be copyable with no \"smarts\" to remove the $ then you can just simply leave out the annotation altogether. A code block in markdown will be copyable without smarts just as is.undefinedMulti-tab code blocks undefined. Examples can be seen in the undefined and undefined. The above examples demonstrate how tabs can either represent platforms i.e. Windows, Linux and macOS or represent specific programming languages i.e. Rust, JavaScript and Golang etc. Here is a brief example of how to implement multi-tab code blocks when writing technical documentation for this site, using markdown.The first step to implementing multi-tab code blocks is placing the enable_shortcodes = true configuration at the start of the .md file. Specifically, in the .md file's frontmatter.The markup to create tabs in markdown is as follows{{ tabs \"os\" }}\n\n{{ startTab \"Windows\"}}\n\nTo list files on windows use `dir`\n\n<!-- @selectiveCpy -->\n\n\\`\\`\\`bash\n$ dir hello_fermyon\n\\`\\`\\`\nand script in windows have the extension `.bat`\n\n<!-- @nocpy -->\n\n\\`\\`\\`bash\nhello.bat\ntest.bat\n\\`\\`\\`\n\n{{ blockEnd }}\n\n{{ startTab \"Linux\"}}\n\nTo list files on linux use `ls`\n\n<!-- @selectiveCpy -->\n\n\\`\\`\\`bash\n$ ls\n\\`\\`\\`\n\nand script in linux have the extension `.sh`\n\n<!-- @nocpy -->\n\n\\`\\`\\`bash\nhello.sh\ntest.sh\n\\`\\`\\`\n\n{{ blockEnd }}\n{{ blockEnd }}undefined: Existing documentation will already be using class names for code block tabs and startTab i.e. {{ tabs \"os\" }} and {{ startTab \"Windows\"}} respectively. Please consult the following tabs and startTab class names that are already in use (before creating your own). If you need to create a new class name (because one does not already exist) please add it to the list below as part of the pull request that contains your code block contribution.undefined:undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedThe next section covers the highly recommended use of ToCs.undefinedIf you create content with many headings it is highly recommended to place a ToC in your markdown file. There are excellent extensions (such as this Visual Studio Code Extension called undefined which will automatically generate your ToC).","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#5-code-blocks-annotations-and-table-of-contents-toc"},{"project":"v2","title":"Contributing to Docs","subheading":"6.1 Checking Your Content - Using NPM","content":"Once you are satisfied with your contribution, you can programmatically check your content.If you have not done so already, please go ahead and perform the npm ci (npm clean install) command; to enable Node dependencies such as markdownlint-cli2. Simply run the following command, from the root of the developer repository:$ npm ciOn top of the Node dependencies the timeout executable must be installed on your system and added to the PATH environment variable. The timeout executable is included in the undefined which should be present in most Linux distributions.On macOS you can install the timeout binary using the Homebrew package manager as shown below:$ brew install coreutilsHaving all dependencies installed, you can now check for broken links (which takes several minutes) and also lint your markdown files. Simply run the following command, from the root of the developer repository:$ npm run testundefined Optionally you can run only the linter with the following command:# Example of how to lint all Markdown files in a local folder (in this case the spin folder) \nnpx markdownlint-cli2 content/spin/*.md \\\"#node_modules\\\"\n# Example of how to lint a local Markdown file\nnpx markdownlint-cli2 content/spin/install.md \\\"#node_modules\\\"undefined Whilst the npm run test command (which lints and also programmatically checks all URLs) does take extra time to complete it undefined be utilized before you undefined; preventing the potential pushing of broken URLs to the developer documentation site.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#61-checking-your-content---using-npm"},{"project":"v2","title":"Contributing to Docs","subheading":"6.2 Indexing Your Content","content":"The developer documentation site implements in-house search. A new index is automatically generated for you when your contribution is merged into the developer documentation repository. This is done via a GitHub action. The following section explains how to alter content to increase search visibility for your content.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#62-indexing-your-content"},{"project":"v2","title":"Contributing to Docs","subheading":"6.3 Increasing Search Visibility For Your Content","content":"The built-in search functionality is based on the indexing of individual words in each markdown file, which works well most of the time. However, there are a couple of scenarios where you undefined want to deliberately increase search visibility for your content.undefinedWords in a documentation markdown file may not be words that are searched for by a user. For example, you may write about \"different HTTP listening options\" whereas a user may only ever try to find that specific content using a search phrase like \"alternate port\". If you are aware of typical user search phrases it is always recommended to craft your content to include any predictable user search phrases. However, in the rare case of a mismatch between words in your content and the words a user searches for, you can utilize use the keywords string in the [extra] section of your document's frontmatter to increase visibility. For example, the following code block shows frontmatter that helps a user find your documentation page (when the user searches for port):[extra]\nkeywords = \"port ports\"Adding a word to the keywords string of a page overrides the built-in search functionality by at least one order of magnitude. Adding a word to the keywords string may displace other content, so please use it only if necessary.undefinedThe keywords string takes users to the start of a page. In some cases, this is not ideal. You may want to home in on specific content to resolve a search query.If a search term relates to a specific part of a page, you may use the following syntax anywhere in the body of your markdown file, and the user's search action will direct them straight to the previous heading (nearest heading above the @searchTerm syntax).<!-- @searchTerm \"homing\" -->When using the above @searchTerm feature, please note the following:undefinedundefinedExample: If you search for the word \"homing\", the results will point you to the previous heading in this specific section of the developer documentation.undefined","keywords":"","subsectionKeywords":"  homing ","url":"/v2/contributing-docs#63-increasing-search-visibility-for-your-content"},{"project":"v2","title":"Contributing to Docs","subheading":"6.4 The Edit On GitHub Button","content":"Each markdown file in the developer documentation requires a link to its GitHub page for the site to correctly render the \"Edit on GitHub\" button for that page.undefinedIf you create a new markdown file and/or you notice a file without the explicit GitHub URL, please add a URL entry to the [extra] section. For example, the following url is required for this page that you are reading (you can check the raw markdown contents of this page to see this example):[extra]\nurl = \"https://github.com/spinframework/spin-docs/blob/main/content/spin/v2/contributing-docs.md\"","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#64-the-edit-on-github-button"},{"project":"v2","title":"Contributing to Docs","subheading":"6.5 How To Properly Edit CSS Styles","content":"undefinedDirectly editing .css files is not recommended, because .css files are overwritten. Instead, if you would like to make and test a new/different style please go ahead and update the appropriate .scss file. The following command will automatically update the .css file that is relevant to the .scss file that you are editing:$ npm run stylesThe above command is designed to be run in the background; enabling you to view your design changes (that are reflected in the .css) while you are editing the .scss in real-time. If you are not running this command in the background (i.e. just deliberately regenerating the .css files once), then the above command can be stopped by pressing Ctrl + C.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#65-how-to-properly-edit-css-styles"},{"project":"v2","title":"Contributing to Docs","subheading":"6.6 Checking Your Content - Using Bartholomew's CLI","content":"The Bartholomew Command Line Interface (CLI) Tool is called bart. The bart CLI is a tool that simplifies working with Bartholomew projects (by now you probably already know that undefined is our in-house WebAssembly (Wasm) content management system (CMS) that powers undefined). And this (our official documentation) site. The bart CLI is handy to ensure quality assurance of new and existing content. Installing the CLI is a cinch, so please go ahead and use it when contributing.To build the Bartholomew CLI from source perform the following commands:$ cd ~\n$ git clone https://github.com/fermyon/bartholomew.git\n$ cd ~/bartholomew\n$ make bartOnce built, you will find the bart CLI executable in the ~/bartholomew/target/release directory. However, for convenience it would be a great idea to go ahead and add the bart executable to your system path, for example:$ sudo mv ~/bartholomew/target/release/bart /usr/local/bin/Once installed, you can use the CLI's --help flag to learn more. For example:$ bart --help\nbart 0.6.0\nThe Bartholomew CLI\n\nUSAGE:\n    bart <SUBCOMMAND>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nSUBCOMMANDS:\n    calendar    Print the content calendar for a Bartholomew website\n    check       Check content and identify errors or warnings\n    help        Prints this message or the help of the given subcommand(s)\n    new         Create a new page or website from a templateLet's take a quick look at how you can use the bart CLI to check any content that you are wanting to contribute.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#66-checking-your-content---using-bartholomews-cli"},{"project":"v2","title":"Contributing to Docs","subheading":"6.7 Checking Your Content - Preview a Documentation Page on Localhost","content":"You can host your changes to the developer documentation on your own machine (localhost) by using the following spin commands:$ npm ci\n$ cd spin-up-hub\n$ npm ci\n$ cd ..\n$ spin build\n$ spin up -e \"PREVIEW_MODE=1\"undefined","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#67-checking-your-content---preview-a-documentation-page-on-localhost"},{"project":"v2","title":"Contributing to Docs","subheading":"6.8 Scheduling Menu Items for Timed Release","content":"As mentioned above, all pages (.md files) in the documentation have a UTC date i.e. date = \"2023-07-25T17:26:00Z\". The date is a page scheduling mechanism whereby each page is only displayed if the date has elapsed. Menu items (found in the /developer/templates/*.hbs files) that relate to a scheduled page can also be scheduled (so the specific menu item and its associated page appear at the same time). Simply envelope the menu item with the following if syntax to synchronize the appearance of the menu item with the related page:{{#if (timed_publish \"2023-07-25T17:26:00Z\" env.PREVIEW_MODE)}}\n    // Scheduled menu item for timed release\n{{/if}}undefined","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#68-scheduling-menu-items-for-timed-release"},{"project":"v2","title":"Contributing to Docs","subheading":"7. Checking Web Pages","content":"The bart check command can be used to check the content. Simply pass in the content as a parameter. The developer documentation undefined, so always pass --shortcodes ./shortcodes as shown below:$ bart check --shortcodes ./shortcodes content/spin/variables.md\nshortcodes: registering alert\nshortcodes: registering details\nshortcodes: registering tabs\nshortcodes: registering startTab\nshortcodes: registering blockEnd\n✅ content/spin/variables.mdundefined","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#7-checking-web-pages"},{"project":"v2","title":"Contributing to Docs","subheading":"8. Add Changes","content":"Once your changes have been checked, go ahead and add your changes by moving to a top-level directory, under which your changes exist i.e. cd ~/developer.Add your changes by running the following command, from the root of the developer repository:$ git add","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#8-add-changes"},{"project":"v2","title":"Contributing to Docs","subheading":"9. Commit Changes","content":"Before committing, please ensure that your GitHub installation is configured sufficiently so that you can --signoff as part of the git commit command. For example, please ensure that the user.name and user.email are configured in your terminal. You can check if these are set by typing git config --list.If you need to set these values please use the following commands:$ git config user.name \"yourusername\"$ git config user.email \"youremail@somemail.com\"More information can be found at this GitHub documentation page called undefined.Type the following commit command to ensure that you sign off (--signoff), sign the data (-S) - recommended, and also leave a short message (-m):$ git commit -S --signoff -m \"Updating documentation\"undefined","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#9-commit-changes"},{"project":"v2","title":"Contributing to Docs","subheading":"10. Push Changes","content":"At this stage, it is a good idea to just quickly check what GitHub thinks the origin is. For example, if we type git remote -v we can see that the origin is our repo; which we a) forked the original repo into and b) which we then cloned to our local disk so that we could edit:$ git remote -vThe above command will return output similar to the following:origin\tgit@github.com:yourusername/developer.git (fetch)\norigin\tgit@github.com:yourusername/developer.git (push)\nupstream\thttps://github.com/fermyon/developer (fetch)\nupstream\thttps://github.com/fermyon/developer (push)Once you are satisfied go ahead and push your changes:$ git push -u origin my_new_branch","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#10-push-changes"},{"project":"v2","title":"Contributing to Docs","subheading":"11. Create a Pull Request","content":"If you return to your GitHub repository in your browser, you will notice that a PR has automatically been generated for you.Clicking on the green “Compare and pull request” button will allow you to add a title and description as part of the PR.undefinedYou can also add any information in the textbox provided below the title. For example, screen captures and/or code/console/terminal snippets of your contribution working correctly and/or tests passing etc.Once you have finished creating your PR, please keep an eye on the PR; answering any questions as part of the collaboration process.undefinedThanks for contributing.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-docs#11-create-a-pull-request"},{"project":"v2","title":"Contributing to Spin","subheading":"","content":"undefinedundefinedundefinedWe are delighted that you are interested in making Spin better! Thank you!This document will guide you through making your first contribution to the project.\nWe welcome and appreciate contributions of all types — opening issues, fixing\ntypos, adding examples, one-liner code fixes, tests, or complete features.","subsectionKeywords":"","url":"/v2/contributing-spin"},{"project":"v2","title":"Contributing to Spin","subheading":"Developer Community Calls","content":"undefined<strong>Each Monday</strong> at 2:30pm UTC and 9:00pm UTC (alternating), we meet to discuss Spin issues, roadmap, and ideas in our Spin Project Meetings. The Spin Project follows an undefined - anyone who is interested is welcome to join the discussion. undefined for meeting dates.The undefined. The document contains a rolling agenda with the date and time of each meeting, the Zoom link, and topics of discussion for the day. You will also find the meeting minutes for each meeting and the link to the recording. If you have something you would like to demo or discuss at the project meeting, we encourage you to add it to the agenda.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-spin#developer-community-calls"},{"project":"v2","title":"Contributing to Spin","subheading":"Code of Conduct","content":"First, any contribution and interaction on any Fermyon project MUST follow our\nundefined. Thank you for being\npart of an inclusive and open community!If you plan on contributing anything complex, please go through the issue and PR\nqueues first to make sure someone else has not started working on it. If it\ndoesn't exist already, please open an issue so you have a chance to get feedback\nfrom the community and the maintainers before you start working on your feature.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-spin#code-of-conduct"},{"project":"v2","title":"Contributing to Spin","subheading":"Making Code Contributions to Spin","content":"The following guide is intended to make sure your contribution can get merged as\nsoon as possible. First, make sure you have Rust installed.undefinedAfter undefined please ensure the wasm32-wasi and\nwasm32-unknown-unknown targets are configured. For example:rustup target add wasm32-wasi && rustup target add wasm32-unknown-unknownIn addition, make sure you have the following prerequisites configured:undefinedundefinedundefinedundefinedundefinedOnce you have set up the prerequisites and identified the contribution you want to make to Spin, make sure you can correctly build the project:# clone the repository\n$ git clone https://github.com/spinframework/spin && cd spin\n# add a new remote pointing to your fork of the project\n$ git remote add fork https://github.com/<your-username>/spin\n# create a new branch for your work\n$ git checkout -b <your-branch>\n\n# build the Spin CLI\n$ cargo build\n\n# make sure compilation is successful\n$ ./target/debug/spin --help\n\n# run the tests and make sure they pass\n$ make testNow you should be ready to start making your contribution. To familiarize\nyourself with the Spin project, please read the\nundefined. Since most of Spin is implemented in\nRust, we try to follow the common Rust coding conventions (keep an eye on the\nrecommendations from Clippy!). If applicable, add unit or integration tests to\nensure your contribution is correct.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-spin#making-code-contributions-to-spin"},{"project":"v2","title":"Contributing to Spin","subheading":"Before You Commit","content":"undefinedundefinedundefinedundefinedSpin enforces lints and tests as part of continuous integration - running them locally will save you a round-trip to your pull request!If everything works locally, you're ready to commit your changes.","keywords":"","subsectionKeywords":"","url":"/v2/contributing-spin#before-you-commit"},{"project":"v2","title":"Contributing to Spin","subheading":"Committing and Pushing Your Changes","content":"We require commits to be signed both with an email address and with a GPG signature.undefined$ git commit -S -s -m \"<your commit message>\"undefinedWe try to only keep useful changes as separate commits — if you prefer to commit\noften, please\nundefined\nbefore opening a pull request.Once you are happy with your changes you can push the branch to your fork:# \"fork\" is the name of the git remote pointing to your fork\n$ git push forkNow you are ready to create a pull request. Thank you for your contribution!","keywords":"","subsectionKeywords":"","url":"/v2/contributing-spin#committing-and-pushing-your-changes"},{"project":"v2","title":"Deploying Spin Applications to Fermyon","subheading":"","content":"undefinedundefined","subsectionKeywords":"","url":"/v2/deploying-to-fermyon"},{"project":"v2","title":"Deploying Spin Applications to Fermyon","subheading":"Fermyon Cloud","content":"undefined is a self-service application platform for WebAssembly-based serverless functions and microservices. It enables you to run Spin applications, at scale, in the cloud, without any infrastructure setup or maintenance required.","keywords":"","subsectionKeywords":"","url":"/v2/deploying-to-fermyon#fermyon-cloud"},{"project":"v2","title":"Deploying Spin Applications to Fermyon","subheading":"Fermyon Platform","content":"undefined is a self-hosted platform for Spin applications. With Fermyon, you can deploy your spin applications onto a server in moments.undefined","keywords":"","subsectionKeywords":"","url":"/v2/deploying-to-fermyon#fermyon-platform"},{"project":"v2","title":"Deploying Spin Applications to Fermyon","subheading":"Running on Your Workstation","content":"For instructions guiding you through running the Fermyon platform on your development workstation,\nfollow undefined.","keywords":"","subsectionKeywords":"","url":"/v2/deploying-to-fermyon#running-on-your-workstation"},{"project":"v2","title":"Deploying Spin Applications to Fermyon","subheading":"Running on AWS","content":"For instructions guiding you through running the Fermyon platform on AWS, follow\nundefined.","keywords":"","subsectionKeywords":"","url":"/v2/deploying-to-fermyon#running-on-aws"},{"project":"v2","title":"Publishing and Distribution","subheading":"","content":"undefinedundefinedundefinedundefinedIf you would like to publish a Spin application, so that other users can run it, you can do so using a undefined.{{ details \"What's all this about containers?\" \"The registry protocol was originally created to publish and distribute Docker containers. Over time, registries have evolved to host other kinds of artifact - see undefined for more information. However, the term remains, in services such as GitHub Container Registry or AWS Elastic Container Registry, and in the generic description undefined. When you use a 'container' registry to publish and distribute Spin applications, there are no actual containers involved at all!\" }}Many cloud services offer public registries.  Examples include GitHub Container Registry, Docker Hub, or Amazon Elastic Container Registry.  These support both public and private distribution.  You can also run your own registry using open source software.","subsectionKeywords":"","url":"/v2/distributing-apps"},{"project":"v2","title":"Publishing and Distribution","subheading":"Logging Into a Registry","content":"Before you can publish to a registry, or run applications whose registry artifacts are private, you must log in to the registry.  This example shows logging into the GitHub Container Registry, ghcr.io:$ spin registry login ghcr.ioIf you don't provide any options to spin registry login, it prompts you for a username and password.","keywords":"","subsectionKeywords":"","url":"/v2/distributing-apps#logging-into-a-registry"},{"project":"v2","title":"Publishing and Distribution","subheading":"Logging In Using a Token","content":"In a non-interactive environment such as GitHub Actions, you will typically log in using a token configured in the environment settings, rather than a password.  To do this, use the --password-stdin flag, and echo the token value to the login command's standard input.  This example shows logging into GHCR from a GitHub action:$ echo \"$\\{{ secrets.GITHUB_TOKEN }}\" | spin registry login ghcr.io --username $\\{{ github.actor }} --password-stdinOther environments will have different ways of referring to the token and user but the pattern remains the same.","keywords":"","subsectionKeywords":"","url":"/v2/distributing-apps#logging-in-using-a-token"},{"project":"v2","title":"Publishing and Distribution","subheading":"Fallback Credentials","content":"If you have logged into a registry using docker login, but not using spin registry login, Spin will fall back to your Docker credentials.","keywords":"","subsectionKeywords":"","url":"/v2/distributing-apps#fallback-credentials"},{"project":"v2","title":"Publishing and Distribution","subheading":"Publishing a Spin Application to a Registry","content":"To publish an application to a registry, use the spin registry push command.  You must provide a undefined for the published application.  This is a string whose format is defined by the registry standard, and generally consists of <registry>/<username>/<application-name>:<version>.  (In specific circumstances you may be able to omit the username and/or the version.  If you want more detail on references, see the OCI documentation.)undefinedHere is an example of pushing an application to GHCR:$ spin registry push ghcr.io/alyssa-p-hacker/hello-world:v1\nPushed with digest sha256:06b19Notice that the username is part of the reference; the registry does not infer it from the login.  Also notice that the version is specified explicitly; Spin does not infer it from the spin.toml file.undefined","keywords":"","subsectionKeywords":"","url":"/v2/distributing-apps#publishing-a-spin-application-to-a-registry"},{"project":"v2","title":"Publishing and Distribution","subheading":"Running Published Applications","content":"To run a published application from a registry, use spin up -f and pass the registry reference:$ spin up -f ghcr.io/alyssa-p-hacker/hello-world:v1undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/distributing-apps#running-published-applications"},{"project":"v2","title":"Publishing and Distribution","subheading":"Running Published Applications by Digest","content":"Registry versions are mutable; that is, the owner of an application can change which build the :v1 label points to at any time.  If you want to run a specific build of the package, you can refer to it by undefined.  This is similar to a Git commit hash: it is immutable, meaning the same digest always gets the exact same data, no matter what the package owner does.  To do this, use the @sha256:... syntax instead of the :v... syntax:$ spin up -f ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19","keywords":"","subsectionKeywords":"","url":"/v2/distributing-apps#running-published-applications-by-digest"},{"project":"v2","title":"Publishing and Distribution","subheading":"Pulling a Published Application","content":"spin up automatically downloads the application from the registry. If you want to manually download the application, without running it, use the spin registry pull command:$ spin registry pull ghcr.io/alyssa-p-hacker/hello-world:v1\n$ spin registry pull ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19undefined","keywords":"","subsectionKeywords":"","url":"/v2/distributing-apps#pulling-a-published-application"},{"project":"v2","title":"Publishing and Distribution","subheading":"Signing Spin Applications and Verifying Signatures","content":"Because Spin uses the container registry standards to distribute applications, it can also take advantage of tooling built around those standards.  Here is an example of using undefined to sign and verify a Spin application:# Push your Spin application to any registry that supports the OCI registry artifacts,\n# such as the GitHub Container Registry, Docker Hub, Azure ACR, or AWS ECR.\n$ spin registry push ghcr.io/alyssa-p-hacker/hello-world:v1\n\n# You can now sign your Spin app using Cosign (or any other tool that can sign\n# OCI registry objects).\n$ cosign sign ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19\nGenerating ephemeral keys...\nRetrieving signed certificate...\ntlog entry created with index: 12519542\nPushing signature to: ghcr.io/alyssa-p-hacker/hello-world\n\n# Someone interested in your application can now use Cosign to verify the signature\n# before running the application.\n$ cosign verify ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19\nVerification for ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19 --\nThe following checks were performed on each of these signatures:\n  - The cosign claims were validated\n  - Existence of the claims in the transparency log was verified offline\n  - Any certificates were verified against the Fulcio roots.\n\n# The consumer of your app can now run it from the registry.\n$ spin up -f ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19undefined","keywords":"","subsectionKeywords":"","url":"/v2/distributing-apps#signing-spin-applications-and-verifying-signatures"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"","content":"undefinedundefinedundefinedundefinedConfiguration for Spin application features such as undefined,\nundefined, undefined\nand undefined can be supplied dynamically, i.e. during the application runtime,\nrequiring no changes to the application code itself.This runtime configuration data is stored in the runtime-config.toml file and passed in via the --runtime-config-file flag\nwhen invoking the spin up command.Let's look at each configuration category in-depth below.","subsectionKeywords":"","url":"/v2/dynamic-configuration"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"Application Variables Runtime Configuration","content":"undefined values may be set at runtime by providers. Currently,\nthere are three application variable providers: the undefined,\nthe undefined and the undefined.Multiple application variable providers can be configured in Spin. Providers are\nprioritized top-down in the runtime configuration file, with higher-listed providers\ntaking precedence. The environment variable provider always has the highest\npriority.The provider examples below show how to use or configure each\nprovider. For examples on how to access these variables values within your application, see\nundefined.","keywords":"","subsectionKeywords":"","url":"/v2/dynamic-configuration#application-variables-runtime-configuration"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"Environment Variable Provider","content":"The environment variable provider gets variable values from the spin process's\nenvironment (undefined the component environment). Variable keys are translated\nto environment variables by upper-casing and prepending with SPIN_VARIABLE_:$ export SPIN_VARIABLE_API_KEY=\"1234\"  # Sets the `api_key` value.\n$ spin up","keywords":"","subsectionKeywords":"","url":"/v2/dynamic-configuration#environment-variable-provider"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"Vault Application Variable Provider","content":"The Vault application variable provider gets secret values from undefined.\nCurrently, only the undefined is supported.\nYou can set up the v2 kv secret engine at any mount point and provide Vault information in\nthe undefined file:[[config_provider]]\ntype = \"vault\"\nurl = \"http://127.0.0.1:8200\"\ntoken = \"root\"\nmount = \"secret\"","keywords":"","subsectionKeywords":"","url":"/v2/dynamic-configuration#vault-application-variable-provider"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"Vault Application Variable Provider Example","content":"undefinedundefined$ vault server -dev -dev-root-token-id rootundefined$ export VAULT_TOKEN=root\n$ export VAULT_ADDR=http://127.0.0.1:8200\n$ vault kv put secret/secret value=\"test_password\"\n$ vault kv get secret/secretundefinedundefined$ spin build\n$ spin up --runtime-config-file runtime_config.tomlundefined$ curl localhost:3000 --data \"test_password\"\n{\"authentication\": \"accepted\"}$ curl localhost:3000 --data \"wrong_password\"\n{\"authentication\": \"denied\"}","keywords":"","subsectionKeywords":"","url":"/v2/dynamic-configuration#vault-application-variable-provider-example"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"Azure Key Vault Application Variable Provider","content":"The Azure Key Vault application variable provider gets secret values from undefined.Currently, only receiving the latest version of a secret is supported.For authenticating against Azure Key Vault, you must use the client credentials flow. To do so, create a Service Principal (SP) within your Microsoft Entra ID (previously known as Azure Active Directory) and assign the Key Vault Secrets User role to the SP on the scope of your Azure Key Vault instance.You can set up Azure Key Vault application variable provider in\nthe undefined file:[[config_provider]]\ntype = \"azure_key_vault\"\nvault_url = \"https://spin.vault.azure.net/\"\nclient_id = \"12345678-1234-1234-1234-123456789012\"\nclient_secret = \"some.generated.password\"\ntenant_id = \"12345678-1234-1234-1234-123456789012\"\nauthority_host = \"AzurePublicCloud\"","keywords":"","subsectionKeywords":"","url":"/v2/dynamic-configuration#azure-key-vault-application-variable-provider"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"Azure Key Vault Application Variable Provider Example","content":"undefined# Variable Definition\n$ KV_NAME=spin123\n$ LOCATION=germanywestcentral\n$ RG_NAME=rg-spin-azure-key-vault\n\n# Create an Azure Resource Group and an Azure Key Vault\n$ az group create -n $RG_NAME -l $LOCATION\n$ az keyvault create -n $KV_NAME \\\n  -g $RG_NAME \\\n  -l $LOCATION \\\n  --enable-rbac-authorization true\n\n# Grab the Azure Resource Identifier of the Azure Key Vault instance\n$ KV_SCOPE=$(az keyvault show -n $KV_NAME -g $RG_NAME -otsv --query \"id\")undefined# Grab the ID of the currently signed in user in Azure CLI\n$ CURRENT_USER_ID=$(az ad signed-in-user show -otsv --query \"id\")\n\n# Make the currently signed in user a \"Key Vault Secrets Officer\"\n# on the scope of the new Azure Key Vault instance\n$ az role assignment create --assignee $CURRENT_USER_ID \\\n  --role \"Key Vault Secrets Officer\" \\\n  --scope $KV_SCOPE\n\n# Create a test secret called `secret` in the Azure Key Vault instance\n$ az keyvault secret set -n secret --vault-name $KV_NAME --value secret_value --ononeundefined$ export SP_NAME=sp-spin\n\n# Create the SP\n$ SP=$(az ad sp create-for-rbac -n $SP_NAME -ojson)\n\n# Populate local shell variables from the SP JSON\n$ CLIENT_ID=$(echo $SP | jq -r '.appId')\n$ CLIENT_SECRET=$(echo $SP | jq -r '.password')\n$ TENANT_ID=$(echo $SP | jq -r '.tenant')\n\n# Assign the \"Key Vault Secrets User\" role to the SP\n# allowing it to read secrets from the Azure Key Vault instance\n$ az role assignment create --assignee $CLIENT_ID \\\n  --role \"Key Vault Secrets User\" \\\n  --scope $KV_SCOPEundefinedundefinedThe azure-key-vault-provider application contains a runtime_config.toml file. Replace all tokens (e.g. $KV_NAME$) with the corresponding shell variables you created in the previous steps.undefined$ spin build\n$ spin up --runtime-config-file runtime_config.tomlundefined$ curl localhost:3000\nLoaded Secret from Azure Key Vault: secret_value","keywords":"","subsectionKeywords":"","url":"/v2/dynamic-configuration#azure-key-vault-application-variable-provider-example"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"Key Value Store Runtime Configuration","content":"Spin provides built-in key-value storage. This storage is backed by an SQLite database embedded in Spin by default. However, the Spin runtime configuration file (runtime-config.toml) can be updated to not only modify the SQLite configuration but also choose to use a different backing store. The available store options are the embedded SQLite database, an external Redis database or Azure CosmosDB.","keywords":"","subsectionKeywords":"","url":"/v2/dynamic-configuration#key-value-store-runtime-configuration"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"Redis Key Value Store Provider","content":"The following is an example of how an application's runtime-config.toml file can be configured to use Redis instead. Note the type and url values, which are set to redis and the URL of the Redis host, respectively:[key_value_store.default]\ntype = \"redis\"\nurl = \"redis://localhost\"","keywords":"","subsectionKeywords":"","url":"/v2/dynamic-configuration#redis-key-value-store-provider"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"Azure CosmosDB Key Value Store Provider","content":"Similarly, to implement Azure CosmosDB as a backend for Spin's key/value store, change the type to azure_cosmos and specify your database account details:[key_value_store.default]\ntype = \"azure_cosmos\"\nkey = \"<key>\"\naccount = \"<cosmos-account>\"\ndatabase = \"<cosmos-database>\"\ncontainer = \"<cosmos-container>\"undefinedWhilst a single default store may be sufficient for certain application use cases, each Spin application can be configured to support multiple stores of any type, as shown in the runtime-config.toml file below:undefined# This defines a new store named user_data\n[key_value_store.user_data]\ntype = \"spin\" \npath = \".spin/user_data.db\"\n\n# This defines a new store named other_data backed by a Redis database\n[key_value_store.other_data]\ntype = \"redis\"\nurl = \"redis://localhost\"You must individually grant each component access to the stores that it needs to use. To do this, use the component.key_value_stores entry in the component manifest within spin.toml. See undefined for more details.","keywords":"","subsectionKeywords":"","url":"/v2/dynamic-configuration#azure-cosmosdb-key-value-store-provider"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"SQLite Storage Runtime Configuration","content":"Spin provides built-in SQLite storage. By default, this is backed by a database that Spin creates for you underneath your application directory (in the .spin subdirectory). However, you can use the Spin runtime configuration file (runtime-config.toml) to add and customize SQLite databases.The following example runtime-config.toml tells Spin to map the default database to an SQLite database elsewhere in the file system:[sqlite_database.default]\ntype = \"spin\"\npath = \"/planning/todo.db\"If you need more than one database, you can configure multiple databases, each with its own name:# This defines a new store named todo\n[sqlite_database.todo]\ntype = \"spin\"\npath = \"/planning/todo.db\"\n\n# This defines a new store named finance\n[sqlite_database.finance]\ntype = \"spin\"\npath = \"/super/secret/monies.db\"Spin creates any database files that don't exist.  However, it is up to you to delete them when you no longer need them.","keywords":"","subsectionKeywords":"","url":"/v2/dynamic-configuration#sqlite-storage-runtime-configuration"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"LibSQL Storage Provider","content":"Spin can also use undefined databases accessed over HTTPS.  libSQL is fully compatible with SQLite but provides additional features including remote, distributed databases.undefinedTo use libSQL, set type = \"libsql\" in your runtime-config.toml entry.  You must then provide a url and authentication token instead of a file path.  For example, this entry tells Spin to map the default database to a libSQL service running on libsql.example.com:# This tells Spin to use the remote host as its default database\n[sqlite_database.default]\ntype = \"libsql\"\nurl = \"https://sensational-penguin-ahacker.libsql.example.com\"\ntoken = \"a secret\"Spin does undefined create libSQL databases.  Use your hosting service's tools to create them (or sqld if you are self-hosting) .  You can still set up tables and data in a libSQL database via spin up --sqlite.undefinedThe default database will still be defined, even if you add other databases.By default, components will not have access to any of these databases (even the default one). You must grant each component access to the databases that it needs to use. To do this, use the component.sqlite_databases entry in the component manifest within spin.toml. See undefined for more details.","keywords":"","subsectionKeywords":"","url":"/v2/dynamic-configuration#libsql-storage-provider"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"LLM Runtime Configuration","content":"Spin provides a Large Language Model interface for interacting with LLMs for inferencing and embedding. The default host implementation is to use local CPU/GPU compute. However, the Spin runtime configuration file (runtime-config.toml) can be updated to enable Spin to use remote compute using HTTP requests.","keywords":"","subsectionKeywords":"","url":"/v2/dynamic-configuration#llm-runtime-configuration"},{"project":"v2","title":"Dynamic and Runtime Application Configuration","subheading":"Remote Compute Provider","content":"The following is an example of how an application's runtime-config.toml file can be configured to use the remote compute option. Note the type, url and auth_token are set to remote_http, URL of the server and the auth token for the server.[llm_compute]\ntype = \"remote_http\"\nurl = \"http://example.com\"\nauth_token = \"<auth_token>\"Currently, the remote compute option requires an user to deploy their own LLM proxy service. Fermyon Cloud users can do this using the undefined.  If you prefer to create and deploy your own proxy service, you can find a reference implementation of the proxy protocol in the undefined.By default, components will not have access to the LLM models unless granted explicit access through the component.ai_models entry in the component manifest within spin.toml. See undefined for more details.","keywords":"","subsectionKeywords":"","url":"/v2/dynamic-configuration#remote-compute-provider"},{"project":"v2","title":"Extending and Embedding Spin","subheading":"","content":"undefinedundefined","subsectionKeywords":"","url":"/v2/extending-and-embedding"},{"project":"v2","title":"Extending and Embedding Spin","subheading":"Extending Spin with a Custom Trigger","content":"undefinedSpin currently implements triggers and application models for:undefinedundefinedThe Spin internals and execution context (the part of Spin executing\ncomponents) are agnostic of the event source and application model.\nIn this document, we will explore how to extend Spin with custom event sources\n(triggers) and application models built on top of the WebAssembly component\nmodel, as well as how to embed Spin in your application.In this article, we will build a Spin trigger to run the applications based on a\ntimer, executing Spin components at a configured time interval.undefinedApplication entry points are defined using\nundefined. Here's the entry point for HTTP triggers:interface incoming-handler {\n  use types.{incoming-request, response-outparam}\n\n  handle: func(\n    request: incoming-request,\n    response-out: response-outparam\n  )\n}The entry point we want to execute for our timer trigger takes no input and doesn't return anything. This is purposefully chosen\nto be a simple function signature. For simplicity, we allow guest code to use Spin's undefined but not other Spin APIs.undefinedHere is the resulting timer WIT:// examples/spin-timer/spin-timer.wit\npackage fermyon:example\n\nworld spin-timer {\n  import fermyon:spin/variables@2.0.0\n  export handle-timer-request: func()\n}handle-timer-request is the function that all components executed by the timer trigger must\nimplement, and which is used by the timer executor when instantiating and\ninvoking the component.The timer trigger itself is a Spin plugin whose name is trigger-timer. The first part must be trigger and the second part is the trigger type.You can see the full timer trigger code at the link above but here are some key features.","keywords":"","subsectionKeywords":"","url":"/v2/extending-and-embedding#extending-spin-with-a-custom-trigger"},{"project":"v2","title":"Extending and Embedding Spin","subheading":"Implement the Trigger World","content":"The timer trigger implements the WIT world described in spin-timer.wit. To do that, it uses the undefined — this generates code that allows the trigger to invoke the guest's entry point, and allows the guest to invoke the Spin APIs available in the world.// examples/spin-timer/src/main.rs\nwasmtime::component::bindgen!({\n    path: \".\",\n    world: \"spin-timer\",\n    async: true\n});","keywords":"","subsectionKeywords":"","url":"/v2/extending-and-embedding#implement-the-trigger-world"},{"project":"v2","title":"Extending and Embedding Spin","subheading":"The Trigger Implements the  TriggerExecutor  Trait","content":"Using TriggerExecutor allows the trigger to offload a great deal of boilerplate loader work to spin_trigger::TriggerExecutorCommand.struct TimerTrigger {\n    engine: TriggerAppEngine<Self>,\n    speedup: u64,\n    component_timings: HashMap<String, u64>,\n}\n\n#[async_trait]\nimpl TriggerExecutor for TimerTrigger {\n    // ...\n}","keywords":"","subsectionKeywords":"","url":"/v2/extending-and-embedding#the-trigger-implements-the-triggerexecutor-trait"},{"project":"v2","title":"Extending and Embedding Spin","subheading":"The Trigger is an Executable","content":"A trigger is a separate program, so that it can be installed as a plugin. So it is a Rust bin project and has a main function. It can be useful to also provide a library crate, so that projects that embed Spin can load it in process if desired, but the timer sample doesn't currently show that.type Command = TriggerExecutorCommand<TimerTrigger>;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let t = Command::parse();\n    t.run().await\n}","keywords":"","subsectionKeywords":"","url":"/v2/extending-and-embedding#the-trigger-is-an-executable"},{"project":"v2","title":"Extending and Embedding Spin","subheading":"The Trigger Detects Events...","content":"In this case the trigger \"detects\" events by running a timer. In most cases, the trigger detects events by listening on a socket, completion port, or other mechanism, or by polling a resource such as a directory or an HTTP endpoint.for (c, d) in &self.component_timings {\n    scope.spawn(async {\n        let duration = tokio::time::Duration::from_millis(*d * 1000 / speedup);\n        loop {\n            tokio::time::sleep(duration).await;\n            self.handle_timer_event(c).await.unwrap();\n        }\n    });\n}","keywords":"","subsectionKeywords":"","url":"/v2/extending-and-embedding#the-trigger-detects-events"},{"project":"v2","title":"Extending and Embedding Spin","subheading":"...and Invokes the Guest","content":"The TriggerExecutorCommand infrastructure equips the trigger object with a TriggerAppEngine specialized to the entry point described in the WIT, and already initialized with the guest Wasm. When an event occurs, the trigger invokes the guest via this engine.async fn handle_timer_event(&self, component_id: &str) -> anyhow::Result<()> {\n    // Load the guest...\n    let (instance, mut store) = self.engine.prepare_instance(component_id).await?;\n    let EitherInstance::Component(instance) = instance else {\n        unreachable!()\n    };\n    let instance = SpinTimer::new(&mut store, &instance)?;\n    // ...and call the entry point\n    instance.call_handle_timer_request(&mut store).await\n}","keywords":"","subsectionKeywords":"","url":"/v2/extending-and-embedding#and-invokes-the-guest"},{"project":"v2","title":"Extending and Embedding Spin","subheading":"Other Ways to Extend and Use Spin","content":"Besides building custom triggers, the internals of Spin could also be used independently:undefined","keywords":"","subsectionKeywords":"","url":"/v2/extending-and-embedding#other-ways-to-extend-and-use-spin"},{"project":"v2","title":"Building Spin components in Go","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v2/go-components"},{"project":"v2","title":"Building Spin components in Go","subheading":"Versions","content":"TinyGo 0.30.0 is recommended, which requires Go v1.19+.","keywords":"","subsectionKeywords":"","url":"/v2/go-components#versions"},{"project":"v2","title":"Building Spin components in Go","subheading":"HTTP Components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, and Go has improved support for\nwriting applications, through its SDK.Building a Spin HTTP component using the Go SDK means writing a single function,\ninit — below is a complete implementation for such a component:// A Spin component written in Go that returns \"Hello, Fermyon!\"\npackage main\n\nimport (\n \"fmt\"\n \"net/http\"\n\n spinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n)\n\nfunc init() {\n spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n  w.Header().Set(\"Content-Type\", \"text/plain\")\n  fmt.Fprintln(w, \"Hello Fermyon!\")\n })\n}\n\nfunc main() {}The Spin HTTP component (written in Go) can be built using the tingygo toolchain:$ tinygo build -o main.wasm -target=wasi main.goOnce built, we can run our Spin HTTP component using the Spin up command:$ spin upThe Spin HTTP component can now receive and process incoming requests:$ curl -i localhost:3000\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 15\n\nHello Fermyon!The important things to note in the implementation above:undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/go-components#http-components"},{"project":"v2","title":"Building Spin components in Go","subheading":"Sending Outbound HTTP Requests","content":"If allowed, Spin components can send outbound requests to HTTP endpoints. Let's\nsee an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:// A Spin component written in Go that sends a request to an API\n// with random animal facts.\n\npackage main\n\nimport (\n \"fmt\"\n \"net/http\"\n \"os\"\n\n spinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n)\n\nfunc init() {\n spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n    resp, _ := spinhttp.Get(\"https://random-data-api.fermyon.app/animals/json\")\n\n  fmt.Fprintln(w, resp.Body)\n  fmt.Fprintln(w, resp.Header.Get(\"content-type\"))\n\n  // `spin.toml` is not configured to allow outbound HTTP requests to this host,\n  // so this request will fail.\n  if _, err := spinhttp.Get(\"https://fermyon.com\"); err != nil {\n   fmt.Fprintf(os.Stderr, \"Cannot send HTTP request: %v\", err)\n  }\n })\n}\n\nfunc main() {}The Outbound HTTP Request example above can be built using the tingygo toolchain:$ tinygo build -o main.wasm -target=wasi main.goBefore we can execute this component, we need to add the\nrandom-data-api.fermyon.app domain to the application manifest allowed_outbound_hosts\nlist containing the list of domains the component is allowed to make HTTP\nrequests to:# spin.toml\nspin_manifest_version = 2\n\n[application]\nname = \"spin-hello-tinygo\"\nversion = \"1.0.0\"\n\n[[trigger.http]]\nroute = \"/hello\"\ncomponent = \"tinygo-hello\"\n\n[component.tinygo-hello]\nsource = \"main.wasm\"\nallowed_outbound_hosts = [ \"https://random-data-api.fermyon.app\" ]Running the application using spin up will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /hello:$ curl -i localhost:3000/hello\nHTTP/1.1 200 OK\ncontent-length: 93\n\n{\"timestamp\":1684299253331,\"fact\":\"Reindeer grow new antlers every year\"}undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/go-components#sending-outbound-http-requests"},{"project":"v2","title":"Building Spin components in Go","subheading":"Redis Components","content":"Besides the HTTP trigger, Spin has built-in support for a Redis trigger, which\nwill connect to a Redis instance and will execute components for new messages\non the configured channels.undefinedWriting a Redis component in Go also takes advantage of the SDK:package main\n\nimport (\n \"fmt\"\n\n \"github.com/fermyon/spin/sdk/go/v2/redis\"\n)\n\nfunc init() {\n // redis.Handle() must be called in the init() function.\n redis.Handle(func(payload []byte) error {\n  fmt.Println(\"Payload::::\")\n  fmt.Println(string(payload))\n  return nil\n })\n}\n\n// main function must be included for the compiler but is not executed.\nfunc main() {}The manifest for a Redis application must contain the address of the Redis instance. This is set at the application level:spin_manifest_version = 2\n\n[application]\nname = \"spin-redis\"\ntrigger = { type = \"redis\",  }\nversion = \"0.1.0\"\n\n[application.trigger.redis]\naddress = \"redis://localhost:6379\"\n\n[[trigger.redis]]\nchannel = \"messages\"\ncomponent = \"echo-message\"\n\n[component.echo-message]\nsource = \"main.wasm\"\n[component.echo-message.build]\ncommand = \"tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"The application will connect to redis://localhost:6379, and for every new message\non the messages channel, the echo-message component will be executed:# first, start redis-server on the default port 6379\n$ redis-server --port 6379\n# then, start the Spin application\n$ spin build --up\nINFO spin_redis_engine: Connecting to Redis server at redis://localhost:6379\nINFO spin_redis_engine: Subscribed component 0 (echo-message) to channel: messagesFor every new message on the messages channel:$ redis-cli\n127.0.0.1:6379> publish messages \"Hello, there!\"Spin will instantiate and execute the component:INFO spin_redis_engine: Received message on channel \"messages\"\nPayload::::\nHello, there!","keywords":"","subsectionKeywords":"","url":"/v2/go-components#redis-components"},{"project":"v2","title":"Building Spin components in Go","subheading":"Storing Data in Redis From Go Components","content":"Using the Spin's Go SDK, you can use the Redis key/value store to publish\nmessages to Redis channels. This can be used from both HTTP and Redis triggered\ncomponents.Let's see how we can use the Go SDK to connect to Redis. This HTTP component demonstrates fetching a value from Redis by key, setting a\nkey with a value, and publishing a message to a Redis channel:package main\n\nimport (\n \"net/http\"\n \"os\"\n\n spin_http \"github.com/fermyon/spin/sdk/go/v2/http\"\n \"github.com/fermyon/spin/sdk/go/v2/redis\"\n)\n\nfunc init() {\n // handler for the http trigger\n spin_http.Handle(func(w http.ResponseWriter, r *http.Request) {\n\n  // addr is the environment variable set in `spin.toml` that points to the\n  // address of the Redis server.\n  addr := os.Getenv(\"REDIS_ADDRESS\")\n\n  // channel is the environment variable set in `spin.toml` that specifies\n  // the Redis channel that the component will publish to.\n  channel := os.Getenv(\"REDIS_CHANNEL\")\n\n  // payload is the data publish to the redis channel.\n  payload := []byte(`Hello redis from tinygo!`)\n\n  // create a new redis client.\n  rdb := redis.NewClient(addr)\n\n  if err := rdb.Publish(channel, payload); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n   return\n  }\n\n  // set redis `mykey` = `myvalue`\n  if err := rdb.Set(\"mykey\", []byte(\"myvalue\")); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n   return\n  }\n\n  // get redis payload for `mykey`\n  if payload, err := rdb.Get(\"mykey\"); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n  } else {\n   w.Write([]byte(\"mykey value was: \"))\n   w.Write(payload)\n  }\n })\n}\n\nfunc main() {}As with all networking APIs, you must grant access to Redis hosts via the allowed_outbound_hosts field in the application manifest:[component.storage-demo]\nenvironment = { REDIS_ADDRESS = \"redis://127.0.0.1:6379\", REDIS_CHANNEL = \"messages\" }\nallowed_outbound_hosts = [\"redis://127.0.0.1:6379\"]This HTTP component can be paired with a Redis component, triggered on new messages on the messages Redis channel, to build an asynchronous messaging application, where the HTTP front-end queues work for a Redis-triggered back-end to execute as capacity is available.undefined","keywords":"","subsectionKeywords":"","url":"/v2/go-components#storing-data-in-redis-from-go-components"},{"project":"v2","title":"Building Spin components in Go","subheading":"Using Go Packages in Spin Components","content":"Any undefined that can be imported in TinyGo and that compiles to\nWASI can be used when implementing a Spin component.undefined","keywords":"","subsectionKeywords":"","url":"/v2/go-components#using-go-packages-in-spin-components"},{"project":"v2","title":"Building Spin components in Go","subheading":"Storing Data in the Spin Key-Value Store","content":"Spin has a key-value store built in. For information about using it from TinyGo, see undefined.","keywords":"","subsectionKeywords":"","url":"/v2/go-components#storing-data-in-the-spin-key-value-store"},{"project":"v2","title":"Building Spin components in Go","subheading":"Storing Data in SQLite","content":"For more information about using SQLite from TinyGo, see undefined.","keywords":"","subsectionKeywords":"","url":"/v2/go-components#storing-data-in-sqlite"},{"project":"v2","title":"Building Spin components in Go","subheading":"AI Inferencing From Go Components","content":"For more information about using Serverless AI from TinyGo, see the undefined API guide.","keywords":"","subsectionKeywords":"","url":"/v2/go-components#ai-inferencing-from-go-components"},{"project":"v2","title":"Making HTTP Requests","subheading":"","content":"undefinedundefinedundefinedSpin provides an interface for you to make outgoing HTTP requests.{{ details \"Why do I need a Spin interface? Why can't I just use my language's HTTP library?\" \"The current version of the WebAssembly System Interface (WASI) doesn't provide a sockets interface, so HTTP libraries can't be built to Wasm. The Spin interface means Wasm modules can bypass this limitation by asking Spin to perform the HTTP request on their behalf.\" }}","subsectionKeywords":"","url":"/v2/http-outbound"},{"project":"v2","title":"Making HTTP Requests","subheading":"Using HTTP From Applications","content":"The outbound HTTP interface depends on your language.undefinedundefined When using Spin v2.6.0 or newer, Spin app guest modules can no longer set the Host header on outbound requests. (The Wasmtime runtime, that underpins Spin, has recently updated how headers are handled).{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedTo send requests, use the undefined function. This takes a request argument and returns a response (or error). It is async, so within an async inbound handler you can have multiple outbound sends running concurrently.undefinedsend is quite flexible in its request and response types. The request may be:undefinedundefinedundefinedundefinedGenerally, you should use OutgoingRequest when you need to stream the outbound request body; otherwise, the Request types are usually simpler.The response may be:undefinedundefinedundefinedundefinedGenerally, you should use IncomingResponse when you need to stream the response body; otherwise, the Response types are usually simpler.Here is an example of doing outbound HTTP in a simple request-response style:use spin_sdk::{\n    http::{IntoResponse, Request, Method, Response},\n    http_component,\n};\n\n#[http_component]\n// The trigger handler (in this case an HTTP handler) has to be async\n// so we can `await` the outbound send.\nasync fn handle_request(_req: Request) -> anyhow::Result<impl IntoResponse> {\n\n    // Create the outbound request object\n    let request = Request::builder()\n        .method(Method::Get)\n        .uri(\"https://www.fermyon.com/\")\n        .build();\n\n    // Send the request and await the response\n    let response: Response = spin_sdk::http::send(request).await?;\n\n    // Use the outbound response body\n    let response_len = response.body().len();\n\n    // Return the response to the inbound request\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(format!(\"The test page was {response_len} bytes\"))\n        .build())\n}For an example of receiving the response in a streaming style, undefined.{{ blockEnd }}{{ startTab \"TypeScript\"}}HTTP operations are available via the standard JavaScript fetch function. The Spin runtime maps this to the underlying Wasm interface. For example:const response = await fetch(\"https://example.com/users\");undefinedYou can find a complete example of using outbound HTTP in the JavaScript SDK repository on undefinedundefined: fetch currently only works when building for the HTTP trigger.{{ blockEnd }}{{ startTab \"Python\"}}undefinedHTTP functions and classes are available in the http module. The function name is undefined. The undefined is Request, and the undefined is Response. For example:from spin_sdk.http import Request, Response, send\nresponse = send(Request(\"GET\", \"https://random-data-api.fermyon.app/animals/json\", {}, None))undefinedundefinedundefinedundefinedundefinedYou can find a complete example for using outbound HTTP in the undefined.{{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedHTTP functions are available in the github.com/fermyon/spin/sdk/go/v2/http package. undefined The general function is named Send, but the Go SDK also surfaces individual functions, with request-specific parameters, for the Get and Post operations. For example:import (\n\tspinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n)\n\nres1, err1 := spinhttp.Get(\"https://random-data-api.fermyon.app/animals/json\")\nres2, err2 := spinhttp.Post(\"https://example.com/users\", \"application/json\", json)\n\nrequest, err := http.NewRequest(\"PUT\", \"https://example.com/users/1\", bytes.NewBufferString(user1))\nrequest.Header.Add(\"content-type\", \"application/json\")\nres3, err3 := spinhttp.Send(req)\nundefinedundefinedundefinedundefinedYou can find a complete example for using outbound HTTP in the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/http-outbound#using-http-from-applications"},{"project":"v2","title":"Making HTTP Requests","subheading":"Granting HTTP Permissions to Components","content":"By default, Spin components are not allowed to make outgoing HTTP requests. This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing. To grant a component permission to make HTTP requests to a particular host, use the allowed_outbound_hosts field in the component manifest:[component.example]\nallowed_outbound_hosts = [ \"https://random-data-api.fermyon.app\", \"http://api.example.com:8080\" ]The Wasm module can make HTTP requests undefined to the specified hosts. If a port is specified, the module can make requests only to that port; otherwise, the module can make requests only on the default port for the scheme. Requests to other hosts (or ports) will fail with an error.You can use a wildcard to allow requests to any subdomain of a domain:[component.example]\nallowed_outbound_hosts = [ \"https://*.example.com\" ]You can also pass an IPv4 CIDR address:[component.example]\nallowed_outbound_hosts = [ \"https://192.168.1.0/24\" ]For development-time convenience, you can also pass the string \"https://*:*\" in the allowed_outbound_hosts collection. This allows the Wasm module to make HTTP requests to undefined host and on any port. However, once you've determined which hosts your code needs, you should remove this string and list the hosts instead.  Other Spin implementations may restrict host access and disallow components that ask to connect to anything and everything!","keywords":"","subsectionKeywords":"","url":"/v2/http-outbound#granting-http-permissions-to-components"},{"project":"v2","title":"Making HTTP Requests","subheading":"Configuration-Based Permissions","content":"You can use undefined in the allowed_outbound_hosts field. However, this feature is not yet available on Fermyon Cloud.","keywords":"","subsectionKeywords":"","url":"/v2/http-outbound#configuration-based-permissions"},{"project":"v2","title":"Making HTTP Requests","subheading":"Making HTTP Requests Within an Application","content":"If your Spin application functions as a set of microservices, you'll often want to make requests directly from one component to another within the same application. It's best not to use a full URL for this, because that's not portable across different deployment environments - the URL in the cloud is different from the one in your development environment. Instead, Spin provides two ways to make inter-component requests:undefinedundefinedBoth of these work only from HTTP components. That is, if you want to make an intra-application request from, say, a Redis trigger, you must use a full URL.","keywords":"","subsectionKeywords":"","url":"/v2/http-outbound#making-http-requests-within-an-application"},{"project":"v2","title":"Making HTTP Requests","subheading":"Local Service Chaining","content":"To make an HTTP request to another component in your application, use the special <component-id>.spin.internal host name. For example, an outbound HTTP request to authz.spin.internal will be handled by the authz component.In this way of doing self-requests, the request is passed in memory without ever leaving the Spin host process. This is extremely fast, as the two components are wired almost directly together, but may reduce deployment flexibility depending on the nature of the microservices. Also, public components that are the target of service chaining requests may see URLs in both routed and chained forms: therefore, if they parse the URL (for example, extracting a resource identifier from the path), they must ensure both forms are correctly handled.undefinedYou must still grant permission by including the relevant spin.internal hosts in allowed_outbound_hosts:allowed_outbound_hosts = [\"http://authz.spin.internal\", \"https://reporting.spin.internal\"]To allow local chaining to undefined component in your application, use a subdomain wildcard:allowed_outbound_hosts = [\"http://*.spin.internal\"]undefined","keywords":"","subsectionKeywords":"","url":"/v2/http-outbound#local-service-chaining"},{"project":"v2","title":"Making HTTP Requests","subheading":"Intra-Application HTTP Requests by Route","content":"To make an HTTP request to another route with your application, you can pass just the route as the URL. For example, if you make an outbound HTTP request to /api/customers/, Spin prepends the route with whatever host the application is running on. It also replaces the URL scheme (http or https) with the scheme of the current HTTP request. For example, if the application is running in the cloud, Spin changes /api to https://.../api.In this way of doing self-requests, the request undergoes normal HTTP processing once Spin has prepended the host. For example, in a cloud deployment, the request passes through the network, and potentially back in through a load balancer or other gateway. The benefit of this is that it allows load to be distributed across the environment, but it may count against your use of bandwidth.You must still grant permission by including self in allowed_outbound_hosts:allowed_outbound_hosts = [\"http://self\", \"https://self\"]","keywords":"","subsectionKeywords":"","url":"/v2/http-outbound#intra-application-http-requests-by-route"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedHTTP applications are an important workload in event-driven environments,\nand Spin has built-in support for creating and running HTTP\ncomponents. This page covers Spin options that are specific to HTTP.The HTTP trigger type in Spin is a web server. When an application has HTTP triggers, Spin listens for incoming requests and,\nbased on the undefined, it routes them to a\ncomponent, which provides an HTTP response.","subsectionKeywords":"","url":"/v2/http-trigger"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Specifying an HTTP Trigger","content":"An HTTP trigger maps an HTTP route to a component.  For example:[[trigger.http]]\nroute = \"/...\"                # the route that the trigger matches\ncomponent = \"my-application\"  # the name of the component to handle this routeSuch a trigger says that HTTP requests matching the specified undefined should be handled by the specified undefined. The component field works the same way across all triggers - see undefined for the details.","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#specifying-an-http-trigger"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"HTTP Trigger Routes","content":"An HTTP route may be undefined or undefined.An undefined route matches only the given route.  This is the default behavior.  For example, /cart matches only /cart, and not /cart/checkout:# Run the `shopping-cart` component when the application receives a request to `/cart`...\n[[trigger.http]]\nroute = \"/cart\"\ncomponent = \"shopping-cart\"\n\n# ...and the `checkout` component for `/cart/checkout`\n[[trigger.http]]\nroute = \"/cart/checkout\"\ncomponent = \"checkout\"You can use wildcards to match 'patterns' of routes. Spin supports two kinds of wildcards: single-segment wildcards and trailing wildcards.A single-segment wildcard uses the syntax :name, where name is a name that identifies the wildcard. Such a wildcard will match only a single segment of a path, and allows further matching on segments beyond it. For example, /users/:userid/edit matches /users/1/edit and /users/alice/edit, but does not match /users, /users/1, or /users/1/edit/cart.A trailing wildcard uses the syntax /... and matches the given route and any route under it.  For example, /users/... matches /users, /users/1, /users/1/edit, and so on. Any of these routes will run the mapped component.undefinedundefined[[trigger.http]]\n# Run the `user-manager` component when the application receives a request to `/users`\n# or any path beginning with `/users/`\nroute = \"/users/...\"\ncomponent = \"user-manager\"","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#http-trigger-routes"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Routing with an Application  base","content":"You can set a base path for the entire application using the optional [application.trigger.http] section:[application.trigger.http]\nbase = \"/shop\"If the application base is omitted, or is \"/\", then all trigger routes are matched exactly as given.If base contains a non-root path, this is prefixed to all trigger routes,\nexact or wildcard.For example, suppose the application base path is base = \"/shop\".  Then a trigger with route = \"/cart\" will be executed for requests to /shop/cart.  Similarly, a trigger with route = \"/users/...\" will be executed for requests to /shop/users, /shop/users/1, /shop/users/1/edit and so on.","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#routing-with-an-application-base"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Resolving Overlapping Routes","content":"If multiple triggers could potentially handle the same request based on their\ndefined routes, the trigger whose route has the longest matching prefix\ntakes precedence.  This also means that exact matches take precedence over wildcard matches.In the following example, requests starting with the  /users/ prefix (e.g. /users/1)\nwill be handled by user-manager, even though it is also matched by the shop route, because the /users prefix is longer than /.\nBut requests to /users/admin will be handled by the admin component, not user-manager, because that is a more exact match still:# spin.toml\n\n[[trigger.http]]\nroute = \"/users/...\"\ncomponent = \"user-manager\"\n\n[[trigger.http]]\nroute = \"/users/admin\"\ncomponent = \"admin\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"shop\"","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#resolving-overlapping-routes"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Private Endpoints","content":"Private endpoints are where an internal microservice is not exposed to the network (does not have an HTTP route) and so is accessible only from within the application.[[trigger.http]]\nroute = { private = true }\ncomponent = \"internal\"To access a private endpoint, use undefined (where the request is passed in memory without ever leaving the Spin host process). Such calls still require the internal endpoint to be included in allowed_outbound_hosts.","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#private-endpoints"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Health Check Route","content":"Every HTTP application automatically has a special route always configured at /.well-known/spin/health, which\nreturns OK 200 when the Spin instance is healthy.","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#health-check-route"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Authoring HTTP Components","content":"undefinedBy default, Spin runs components using the undefined.  In this model, the Wasm module exports a well-known interface that Spin calls to handle the HTTP request.","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#authoring-http-components"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"The Request Handler","content":"The exact signature of the HTTP handler, and how a function is identified to be exported as the handler, will depend on your language.{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedIn Rust, the handler is identified by the undefined attribute.  The handler function can have one of two forms: undefined or undefined.undefinedThis form of handler function receives the request as an argument, and returns the response as the return value of the function. For example:#[http_component]\nasync fn handle(request: http::Request) -> anyhow::Result<http::Response> { ... }In this form, nothing is sent to the client until the entire response is ready. It is convenient for many use cases, but is not suitable for streaming responses.undefinedYou have some flexibility in choosing the types of the request and response.  The request may be:undefinedundefinedundefinedundefinedThe response may be:undefinedundefinedundefinedundefinedFor example:use http::{Request, Response};\nuse spin_sdk::http::IntoResponse;\nuse spin_sdk::http_component;\n\n/// A simple Spin HTTP component.\n#[http_component]\nasync fn handle_hello_rust(_req: Request<()>) -> anyhow::Result<impl IntoResponse> {\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, Fermyon\")?)\n}undefinedTo extract data from the request, specify a body type as the generic parameter for the Request type. You can use raw content types such as Vec<u8> and String, or automatically deserialize a JSON body by using the spin_sdk::http::Json<T> type.undefinedIn this form, the handler function receives the request as an argument of type undefined. It also receives an argument of type undefined, through which is sends the response. The function does not return a value. This form is recommended for streaming responses.To send a response:undefinedundefinedundefinedundefinedundefineduse futures::SinkExt;\nuse spin_sdk::http::{Headers, IncomingRequest, OutgoingResponse, ResponseOutparam};\nuse spin_sdk::http_component;\n\n/// A streaming Spin HTTP component.\n#[http_component]\nasync fn handle_hello_rust(_req: IncomingRequest, response_out: ResponseOutparam) {\n    // Status code and headers must be supplied before calling take_body\n    let response = OutgoingResponse::new(\n        200,\n        &Headers::new(&[(\"content-type\".to_string(), b\"text/plain\".to_vec())]),\n    );\n    // Get the sink for writing the body into. This must be mutable!\n    let mut body = response.take_body();\n\n    // Connect the OutgoingResponse to the ResponseOutparam.\n    response_out.set(response);\n\n    // Write to the body sink over a period of time. (In this case we simulate a\n    // long-running operation by manually calling `thread::sleep`.)\n    for i in 1..20 {\n        let payload = format!(\"Hello {i}\\n\");\n        if let Err(e) = body.send(payload.into()).await {\n            eprintln!(\"Error sending payload: {e:#}\");\n            return;\n        }\n        std::thread::sleep(std::time::Duration::from_millis(100));\n    }\n}For a full Rust SDK reference, see the undefined.{{ blockEnd }}{{ startTab \"TypeScript\"}}undefinedThe user must a define a function named handler which the SDK attaches to the undefined. Note that the incoming HTTP event is translated to a FetchEvent.The handler function takes in two arguments a undefined and a undefinedimport { ResponseBuilder } from \"@fermyon/spin-sdk\";\n\nexport async function handler(req: Request, res: ResponseBuilder) {\n    console.log(req);\n    res.send(\"hello universe\");\n}{{ blockEnd }}{{ startTab \"Python\"}}undefinedIn Python, the application must define a top-level class named IncomingHandler which inherits from undefined, overriding the handle_request method.from spin_sdk import http\nfrom spin_sdk.http import Request, Response\n\nclass IncomingHandler(http.IncomingHandler):\n      def handle_request(self, request: Request) -> Response:\n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(\"Hello from Python!\", \"utf-8\")\n        ){{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedIn Go, you register the handler as a callback in your program's init function.  Call spinhttp.Handle, passing your handler as the sole argument.  Your handler takes a http.Request record, from the standard net/http package, and a ResponseWriter to construct the response.undefinedpackage main\n\nimport (\n        \"fmt\"\n        \"net/http\"\n\n        spinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n)\n\nfunc init() {\n        spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n                w.Header().Set(\"Content-Type\", \"text/plain\")\n                fmt.Fprintln(w, \"Hello Fermyon!\")\n        })\n}\n\nfunc main() {}undefined{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#the-request-handler"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Getting Request and Response Information","content":"Exactly how the Spin SDK surfaces the request and response types varies from language to language; this section calls out general features.undefined","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#getting-request-and-response-information"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Additional Request Information","content":"As well as any headers passed by the client, Spin sets several headers on the request passed to your component, which you can use to access additional information about the HTTP request.undefinedundefined| Header Name                  | Value                | Example |\n|------------------------------|----------------------|---------|\n| spin-full-url              | The full URL of the request. This includes full host and scheme information. | https://example.com:8080/shop/users/1/cart/items/3/edit?theme=pink |\n| spin-path-info             | The request path relative to the component route (including any base) | /items/3 |\n| spin-path-match-n          | Where n is the pattern for our single-segment wildcard value (e.g. spin-path-match-userid will access the value in the URL that represents :userid)  | 1 |\n| spin-matched-route         | The part of the trigger route that was matched by the route (including the base and wildcard indicator if present) | /shop/users/:userid/cart/... |\n| spin-raw-component-route   | The component route pattern matched, as written in the component manifest (that is, undefined the base, but including the wildcard indicator if present) | /users/:userid/cart/... |\n| spin-component-route       | The component route pattern matched, undefined any wildcard indicator | /users/:userid/cart |\n| spin-base-path             | The application base path | /shop |\n| spin-client-addr           | The IP address and port of the client | 127.0.0.1:53152 |","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#additional-request-information"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Inside HTTP Components","content":"For the most part, you'll build HTTP component modules using a language SDK (see the Language Guides section), such as a JavaScript module or a Rust crate.  If you're interested in what happens inside the SDK, or want to implement HTTP components in another language, read on!The HTTP component interface is defined using a WebAssembly Interface (WIT) file.  (undefined).  You can find the latest WITs for Spin HTTP components at undefined.The HTTP types and interfaces are defined in undefined, which tracks undefined.In particular, the entry point for Spin HTTP components is defined in undefined:// incoming-handler.wit\n\ninterface incoming-handler {\n  use types.{incoming-request, response-outparam}\n\n  handle: func(\n    request: incoming-request,\n    response-out: response-outparam\n  )\n}This is the interface that all HTTP components must implement, and which is used by the Spin HTTP executor when instantiating and invoking the component.However, this is not necessarily the interface you, the component author, work with. It may not even be the interface of the component you build!In many cases, you will use a more idiomatic wrapper provided by the Spin SDK, which implements the \"true\" interface internally. In some cases, you will build a Wasm \"core module\" which implements an earlier version of the Spin HTTP interface, which Spin internally adapts to the \"true\" interface as it loads your module.But if you wish, and if your language supports it, you can implement the incoming-handler interface directly, using tools such as the\nundefined. Spin will happily load and run such a component. This is exactly how Spin SDKs, such as the undefined SDK, are built; as component authoring tools roll out for Go, JavaScript, Python, and other languages, you'll be able to use those tools to build wasi-http handlers and therefore Spin HTTP components.undefined","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#inside-http-components"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"HTTP With Wagi (WebAssembly Gateway Interface)","content":"A number of languages support WASI Preview 1 but not the component model. To enable developers to use these languages, Spin supports an\nHTTP executor based on undefined, or the\nWebAssembly Gateway Interface, a project that implements the\nundefined\nspecification for WebAssembly.Wagi allows a module built in any programming language that compiles to undefined\nto handle an HTTP request by passing the HTTP request information to the module's\nstandard input, environment variables, and arguments, and expecting the HTTP\nresponses through the module's standard output.\nThis means that if a language has support for the WebAssembly System Interface,\nit can be used to build Spin HTTP components.\nThe Wagi model is only used to parse the HTTP request and response. Everything\nelse — defining the application, running it, or undefined\nis done the same way as a component that uses the Spin executor.","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#http-with-wagi-webassembly-gateway-interface"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Wagi Component Requirements","content":"Spin uses the component model by default, and cannot detect from the Wasm module alone whether it was built with component model support.  For Wagi components, therefore, you must tell Spin in the component manifest to run them using Wagi instead of 'default' Spin.  To do this, use the executor field in the trigger table:[[trigger.http]]\nroute = \"/\"\ncomponent = \"wagi-test\"\nexecutor = { type = \"wagi\" }undefinedWagi supports non-default entry points, and allows you to pass an arguments string that a program can receive as if it had been passed on the command line. If you need these you can specify them in the executor table. For details, see the undefined.","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#wagi-component-requirements"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Request Handling in Wagi","content":"Building a Wagi component in a particular programming language that can compile\nto wasm32-wasi does not require any special libraries — instead,\nundefined can\nbe done by reading the HTTP request from the standard input and environment\nvariables, and sending the HTTP response to the module's standard output.In pseudo-code, this is the minimum required in a Wagi component:undefinedundefinedundefinedprint(\"content-type: text/html; charset=UTF-8\\n\\n\");\nprint(\"hello world\\n\");Here is a working example, written in undefined,\na programming language that natively targets WebAssembly and WASI but\ndoes not yet support the component model:import Process from \"sys/process\";\nimport Array from \"array\";\n\nprint(\"content-type: text/plain\\n\");\n\n// This will print all the Wagi env variables\nprint(\"==== Environment: ====\");\nArray.forEach(print, Process.env());\n\n// This will print the route path followed by each query\n// param. So /foo?bar=baz will be [\"/foo\", \"bar=baz\"].\nprint(\"==== Args: ====\");\nArray.forEach(print, Process.argv());undefined","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#request-handling-in-wagi"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Wagi HTTP Environment Variables","content":"Wagi passes request metadata to the program through well-known environment variables. The key path-related request variables are:undefinedundefinedundefinedundefinedundefinedundefinedFor details, and for a full list of all Wagi environment variables, see\nundefined.","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#wagi-http-environment-variables"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Exposing HTTP Triggers Using HTTPS","content":"When exposing HTTP triggers using HTTPS you must provide spin up with a TLS certificate and a private key. This can be achieved by either using trigger options (--tls-cert and --tls-key) when running the spin up command, or by setting environment variables (SPIN_TLS_CERT and SPIN_TLS_KEY) before running the spin up command.","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#exposing-http-triggers-using-https"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Trigger Options","content":"The spin up command's --tls-cert and --tls-key trigger options provide a way for you to specify both a TLS certificate and a private key (whilst running the spin up command).The --tls-cert option specifies the path to the TLS certificate to use for HTTPS, if this is not set, normal HTTP will be used. The certificate should be in PEM format.The --tls-key option specifies the path to the private key to use for HTTPS, if this is not set, normal HTTP will be used. The key should be in PKCS#8 format. For more information, please see the undefined.","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#trigger-options"},{"project":"v2","title":"The Spin HTTP Trigger","subheading":"Environment Variables","content":"The spin up command can also automatically use the SPIN_TLS_CERT and SPIN_TLS_KEY environment variables instead of the respective flags (--tls-cert and --tls-key):SPIN_TLS_CERT=<path/to/cert>\nSPIN_TLS_KEY=<path/to/key>Once set, spin up will automatically use these explicitly set environment variables. For example, if using a Linux-based system, you can go ahead and use the export command to set the variables in your session (before you run the spin up command):export SPIN_TLS_CERT=<path/to/cert>\nexport SPIN_TLS_KEY=<path/to/key>","keywords":"","subsectionKeywords":"","url":"/v2/http-trigger#environment-variables"},{"project":"v2","title":"Introducing Spin","subheading":"","content":"{{suh_cards}}\n{{card_element \"sample\" \"Checklist Sample App\" \"A checklist app that persists data in a key value store\" \"https://developer.fermyon.com/hub/preview/sample_checklist\" \"Typescript,Http,Kv\" true }}\n{{card_element \"template\" \"Zola SSG Template\" \"A template for using Zola framework to create a static webpage\" \"https://developer.fermyon.com/hub/preview/template_zola_ssg\" \"rust\" true }}\n{{card_element \"sample\" \"AI-assisted News Summarizer\" \"Read an RSS newsfeed and have AI summarize it for you\" \"https://developer.fermyon.com/hub/preview/sample_newsreader_ai\" \"Typescript,Javascript,Ai\" true }}\n{{blockEnd}}Spin is a framework for building and running event-driven microservice applications with WebAssembly (Wasm) components.Spin uses Wasm because it is undefined.  Millisecond cold start times mean no need to keep applications \"warm\".Many languages have Wasm implementations, so undefined.Spin is undefined and undefined, meaning you can take your Spin applications anywhere.  There are Spin implementations for local development, for self-hosted servers, for Kubernetes, and for cloud-hosted services.undefined  Check out what's undefined!Or dive into the documentation and get started:undefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v2/index"},{"project":"v2","title":"Install Spin","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefined","keywords":"install","subsectionKeywords":"","url":"/v2/install"},{"project":"v2","title":"Install Spin","subheading":"Installing Spin","content":"Spin runs on Linux (amd64 and arm64), macOS (Intel and Apple Silicon), and Windows (amd64):{{ tabs \"os\" }}{{ startTab \"Linux\"}}undefinedYou can manage your Spin installation via undefined. Homebrew automatically installs Spin templates and Spin plugins, and on uninstall, will prompt you to delete the directory where the templates and plugins were downloaded:Install the Fermyon tap, which Homebrew tracks, updates, and installs Spin from:$ brew tap fermyon/tapInstall Spin:$ brew install fermyon/tap/spinundefinedundefinedAnother option (other than brew) is to use our installer script. The installer script installs Spin along with a starter set of language templates and plugins:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bashOnce you have run the installer script, it is highly recommended to add Spin to a folder, which is on your path, e.g.:$ sudo mv spin /usr/local/bin/undefinedTo install a specific version (v1.2.3 is just an example), you can pass arguments to the install script this way:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v v1.2.3To install the canary version of spin, you should pass the argument -v canary. The canary version is always the latest commit to the main branch of Spin:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v canary{{ blockEnd }}{{ startTab \"macOS\"}}undefinedYou can manage your Spin installation via undefined. Homebrew automatically installs Spin templates and Spin plugins, and on uninstall, will prompt you to delete the directory where the templates and plugins were downloaded:Install the Fermyon tap, which Homebrew tracks, updates, and installs Spin from:$ brew tap fermyon/tapInstall Spin:$ brew install fermyon/tap/spinundefinedundefinedAnother option (other than brew) is to use our installer script. The installer script installs Spin along with a starter set of language templates and plugins:The installer script also installs Spin along with a starter set of language templates and plugins:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bashOnce you have run the installer script, it is highly recommended to add Spin to a folder, which is on your path, e.g.:$ sudo mv spin /usr/local/bin/undefinedTo install a specific version (v1.2.3 is just an example), you can pass arguments to the install script this way:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v v1.2.3To install the canary version of spin, you should pass the argument -v canary. The canary version is always the latest commit to the main branch of Spin:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v canary{{ blockEnd }}{{ startTab \"Windows\"}}If using Windows (PowerShell / cmd.exe), you can download <a href=\"https://github.com/spinframework/spin/releases/latest\" class=\"spin-install\" id=\"spin-install-windows\">the Windows binary release of Spin</a>.Simply unzip the binary release and place the spin.exe in your system path.This does not install any Spin templates or plugins. For a starter list, see the undefined.If you want to use WSL2 (Windows Subsystem for Linux 2), please follow the instructions for using Linux.{{ blockEnd }}\n{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/install#installing-spin"},{"project":"v2","title":"Install Spin","subheading":"Verifying the Release Signature","content":"The Spin project undefined using undefined, a project that helps with signing software and undefined. Consumers of Spin releases can validate the integrity of the package they downloaded by performing a validation of the artifact against the signature present in the public log. Specifically, users get two main guarantees by verifying the signature: 1) that the author of the artifact is indeed the one expected (i.e. the build infrastructure associated with the Spin project, at a given revision that can be inspected), and 2) that the content generated by the build infrastructure has not been tampered with.To verify the release signature, first undefined. This is the CLI tool that we will use validate the signature.\nThe same directory where the installation script was run should also contain a signature of the Spin binary and the certificate used to perform the signature. The following command will perform the signature verification using the cosign CLI:$ cosign verify-blob \\\n    --signature spin.sig \\\n    --certificate crt.pem \\\n    --certificate-identity https://github.com/spinframework/spin/.github/workflows/release.yml@refs/tags/<version> \\\n    --certificate-oidc-issuer https://token.actions.githubusercontent.com \\\n    # --certificate-github-workflow-sha <optionally, pass the commit SHA associated with the tag> \\\n    ./spin\nVerified OKYou can now move the Spin binary to the path knowing that it was indeed built by the infrastructure associated with the Spin project, and that it has not been tampered with since the build.","keywords":"","subsectionKeywords":"","url":"/v2/install#verifying-the-release-signature"},{"project":"v2","title":"Install Spin","subheading":"Building Spin From Source","content":"undefined for a detailed guide on building Spin from source:$ git clone https://github.com/spinframework/spin\n$ cd spin && make build\n$ ./target/release/spin --helpundefined$ sudo apt-get install build-essential libssl-dev pkg-configThis does not install any Spin templates or plugins. For a starter list, see the undefined.","keywords":"","subsectionKeywords":"","url":"/v2/install#building-spin-from-source"},{"project":"v2","title":"Install Spin","subheading":"Using Cargo to Install Spin","content":"If you have undefined, you can clone the repo and install it to your path.undefined$ git clone https://github.com/spinframework/spin\n$ cd spin\n$ # Check out the latest tagged release\n$ # git checkout <latest release>\n$ rustup target add wasm32-wasi\n$ rustup target add wasm32-unknown-unknown\n$ cargo install --locked --path .\n$ spin --helpundefined$ rustup updateThis does not install any Spin templates or plugins. For a starter list, see the undefined.","keywords":"","subsectionKeywords":"","url":"/v2/install#using-cargo-to-install-spin"},{"project":"v2","title":"Install Spin","subheading":"Installing Templates and Plugins","content":"Spin has a variety of templates and plugins to make it easier to create Spin applications in your favorite programming language. undefined automatically installs a starter set of templates and plugins, namely templates from the Spin repository and JavaScript and Python toolchain plugins and the Fermyon Cloud plugin.If you used a different installation method, we recommend you install these templates and plugins manually, as follows.","keywords":"","subsectionKeywords":"","url":"/v2/install#installing-templates-and-plugins"},{"project":"v2","title":"Install Spin","subheading":"Templates","content":"Spin:$ spin templates install --git https://github.com/spinframework/spin --upgradeSpin Python SDK$ spin templates install --git https://github.com/spinframework/spin-python-sdk --upgradeSpin JS SDK:$ spin templates install --git https://github.com/spinframework/spin-js-sdk --upgrade --branch sdk-v2To list installed templates, run:$ spin templates listFor more information please read the undefined section of the documentation.","keywords":"","subsectionKeywords":"","url":"/v2/install#templates"},{"project":"v2","title":"Install Spin","subheading":"Plugins","content":"First update the local cache by running the spin plugins update command:$ spin plugins updateThen install plugins by name.Python:undefinedJavascript:$ spin plugins install js2wasm --yesFermyon Cloud:$ spin plugins install cloud --yesTo list available plugins, run:$ spin plugins searchFor more information, please visit the undefined section of the documentation.","keywords":"","subsectionKeywords":"","url":"/v2/install#plugins"},{"project":"v2","title":"Install Spin","subheading":"Next Steps","content":"{{suh_cards}}\n{{card_element \"sample\" \"Checklist Sample App\" \"A checklist app that persists data in a key value store\" \"https://developer.fermyon.com/hub/preview/sample_checklist\" \"Typescript,Http,Kv\" true }}\n{{card_element \"template\" \"Zola SSG Template\" \"A template for using Zola framework to create a static webpage\" \"https://developer.fermyon.com/hub/preview/template_zola_ssg\" \"rust\" true }}\n{{card_element \"sample\" \"AI-assisted News Summarizer\" \"Read an RSS newsfeed and have AI summarize it for you\" \"https://developer.fermyon.com/hub/preview/sample_newsreader_ai\" \"Typescript,Javascript,Ai\" true }}\n{{blockEnd}}","keywords":"","subsectionKeywords":"","url":"/v2/install#next-steps"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedWith JavaScript being a very popular language, Spin provides an SDK to support building components. The development of the JavaScript SDK is continually being worked on to improve user experience and add features. The SDK is based on undefined.undefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v2/javascript-components"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"Installing Templates","content":"The JavaScript/TypeScript templates can be installed from undefined using the following command:$ spin templates install --git https://github.com/spinframework/spin-js-sdk --update --branch sdk-v2which will install the http-js and http-ts templates:Copying remote template source\nInstalling template http-ts...\nInstalling template http-js...\nInstalled 2 template(s)\n\n+-------------------------------------------------+\n| Name      Description                           |\n+=================================================+\n| http-js   HTTP request handler using Javascript |\n| http-ts   HTTP request handler using Typescript |\n+-------------------------------------------------+","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#installing-templates"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"Structure of a JS/TS Component","content":"A new JS/TS component can be created using the following command:$ spin new -t http-ts hello-world --accept-defaultsThis creates a directory of the following structure:hello-world/\n├── knitwit.json\n├── package.json\n├── spin.toml\n├── src\n│   ├── index.ts\n│   └── spin.ts\n├── tsconfig.json\n└── webpack.config.jsThe source for the component is present in src/index.ts. undefined is used to bundle the component into a single .js file which will then be compiled to a .wasm module.{{ details \"Going from JavaScript to Wasm\" \"The JS source is compiled to a wasm module using the j2w node executable provided by the @fermyon/spin-sdk which is a wrapper around ComponentizeJS. The knitwit.json is the configuration file used by undefined to manage the WebAssembly dependencies of each package.\"}}","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#structure-of-a-jsts-component"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"Building and Running the Template","content":"First, the dependencies for the template need to be installed using the following commands:$ cd hello-world\n$ npm installNext step is to use the spin build command to run the build script for the component. Once a Spin compatible module is created, it can be run using spin up:$ spin build\n$ spin upspin build will execute the command in the command key under the [component.<component-name>.build] section from spin.toml for each component in your application. In this case an npm script will be run. The command in the package.json will looks something like:\"scripts\": {\n    \"build\": \"npx webpack --mode=production && npx mkdirp target && npx j2w -i dist.js -d combined-wit -n combined -o target/hello-world.wasm\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  }","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#building-and-running-the-template"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"HTTP Components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, and Javascript/TypeScript has improved support\nfor writing Spin components with the Spin JS/TS SDK.undefinedBuilding a Spin HTTP component using the JS/TS SDK means writing a single function\nthat takes an HTTP request and a Response Builder which can be used to return an HTTP response as a parameter.Below is a complete implementation for such a component in TypeScript:import { ResponseBuilder } from \"@fermyon/spin-sdk\";\n\nexport async function handler(req: Request, res: ResponseBuilder) {\n    console.log(req);\n    res.send(\"hello universe\");\n}The important things to note in the implementation above:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#http-components"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"Sending Outbound HTTP Requests","content":"If allowed, Spin components can send outbound HTTP requests.\nLet's see an example of a component that makes a request to undefinedimport { ResponseBuilder } from \"@fermyon/spin-sdk\";\n\ninterface AnimalFact {\n   timestamp: number;\n   fact: string;\n}\n\nexport async function handler(req: Request, res: ResponseBuilder) {\n    const animalFactResponse = await fetch(\"https://random-data-api.fermyon.app/animals/json\")\n    const animalFact = await animalFactResponse.json() as AnimalFact\n\n    const body = `Here's an animal fact: ${animalFact.fact}\\n`\n\n    res.set({\"content-type\": \"text/plain\"})\n    res.send(body)\n}Before we can execute this component, we need to add the random-data-api.fermyon.app\ndomain to the application manifest allowed_outbound_hosts list containing the list of\ndomains the component is allowed to make HTTP requests to:spin_manifest_version = 2\n\n[application]\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\nname = \"hello-world\"\nversion = \"0.1.0\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nsource = \"target/hello-world.wasm\"\nexclude_files = [\"**/node_modules\"]\nallowed_outbound_hosts = [\"https://random-data-api.fermyon.app\"]\n[component.hello-world.build]\ncommand = \"npm run build\"The component can be built using the spin build command. Running the application using spin up will start the HTTP listener locally (by default on localhost:3000):$ curl -i localhost:3000\nHTTP/1.1 200 OK\ndate = \"2023-11-04T00:00:01Z\"\ncontent-type: application/json; charset=utf-8\ncontent-length: 185\nserver: spin/0.1.0\n\nHere's an animal fact: Reindeer grow new antlers every yearundefinedundefinedWe just built a WebAssembly component that sends an HTTP request to another\nservice, manipulates that result, then responds to the original request.\nThis can be the basis for building components that communicate with external\ndatabases or storage accounts, or even more specialized components like HTTP\nproxies or URL shorteners.","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#sending-outbound-http-requests"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"Storing Data in Redis From JS/TS Components","content":"undefinedUsing the Spin's JS SDK, you can use the Redis key/value store and to publish messages to Redis channels.Let's see how we can use the JS/TS SDK to connect to Redis:import { ResponseBuilder, Redis } from '@fermyon/spin-sdk';\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nconst redisAddress = 'redis://localhost:6379/';\n\nexport async function handler(_req: Request, res: ResponseBuilder) {\n  try {\n    let db = Redis.open(redisAddress);\n    db.set('test', encoder.encode('Hello world'));\n    let val = db.get('test');\n\n    if (!val) {\n      res.status(404);\n      res.send();\n      return;\n    }\n    // publish to a channel names \"message\"\n    db.publish(\"message\", val)\n    res.send(val);\n  } catch (e: any) {\n    res.status(500);\n    res.send(`Error: ${JSON.stringify(e.payload)}`);\n  }\n}This HTTP component demonstrates fetching a value from Redis by key, setting a key with a value, and publishing a message to a Redis channel.undefinedAs with all networking APIs, you must grant access to Redis hosts via the allowed_outbound_hosts field in the application manifest:[component.storage-demo]\nallowed_outbound_hosts = [\"redis://localhost:6379\"]","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#storing-data-in-redis-from-jsts-components"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"Routing in a Component","content":"The JavaScript/TypeScript SDK provides a router that makes it easier to handle routing within a component. The router is based on undefined. An additional function handleRequest has been implemented in the router to allow passing in the Spin HTTP request directly. An example usage of the router is given below:import { ResponseBuilder, Router } from '@fermyon/spin-sdk';\n\nlet router = Router();\n\nrouter.get(\"/\", (_, req, res) => { handleDefaultRoute(req, res) })\nrouter.get(\"/home/:id\", (metadata, req, res) => { handleHomeRoute(req, res, metadata.params.id) })\n\nasync function handleDefaultRoute(_req: Request, res: ResponseBuilder) {\n  res.set({ \"content-type\": \"text/plain\" });\n  res.send(\"Hello from default route\");\n}\n\nasync function handleHomeRoute(_req: Request, res: ResponseBuilder, id: string) {\n  res.set({ \"content-type\": \"text/plain\" });\n  res.send(`Hello from home route with id: ${id}`);\n}\n\nexport async function handler(req: Request, res: ResponseBuilder) {\n  await router.handleRequest(req, res);\n}","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#routing-in-a-component"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"Storing Data in the Spin Key-Value Store","content":"Spin has a key-value store built in. For information about using it from TypeScript/JavaScript, see undefined.","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#storing-data-in-the-spin-key-value-store"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"Storing Data in SQLite","content":"For more information about using SQLite from TypeScript/Javascript, see undefined.","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#storing-data-in-sqlite"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"Storing Data in MySQL and PostgreSQL Relational Databases","content":"For more information about using relational databases from TypeScript/JavaScript, see undefined.","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#storing-data-in-mysql-and-postgresql-relational-databases"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"AI Inferencing From JS/TS Components","content":"For more information about using Serverless AI from JS/TS, see the undefined API guide.","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#ai-inferencing-from-jsts-components"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"Node.js Compatibility","content":"The SDK does not support the full specification of Node.js. A limited set of APIs can be polyfilled using the undefined library which provides a webpack plugin. It can be used by installing the  library first using:$ npm install @fermyon/wasi-extOnce installed, the plugin provided by it can be added to the webpack config:const WasiExtPlugin = require(\"wasi-ext/plugin\")\n\nmodule.exports = {\n    ...\n    plugins: [\n        new WasiExtPlugin()\n    ],\n    ...\n};This library only currently supports the following polyfills:undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#nodejs-compatibility"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"Using External NPM Libraries","content":"undefinedSome NPM packages can be installed and used in the component. If a popular library does not work, please open an issue/feature request in the undefined.","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#using-external-npm-libraries"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"Suggested Libraries for Common Tasks","content":"These are some of the suggested libraries that have been tested and confirmed to work with the SDK for common tasks.{{ details \"HTML parsers\" \"- undefined\" }}{{ details \"Parsing formdata\" \"- undefined\" }}{{ details \"Runtime schema validation\" \"- undefined\" }}{{ details \"Unique ID generator\" \"- undefined\\n- undefined\\n- undefined\" }}","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#suggested-libraries-for-common-tasks"},{"project":"v2","title":"Building Spin Components in JavaScript","subheading":"Caveats","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/javascript-components#caveats"},{"project":"v2","title":"Spin Key-Value Store","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v2/key-value-store-tutorial"},{"project":"v2","title":"Spin Key-Value Store","subheading":"Key Value Store With Spin Applications","content":"Spin applications are best suited for event-driven, stateless workloads that have low-latency requirements. Keeping track of the application's state (storing information) is an integral part of any useful product or service. For example, users (and the business) will expect to store and load data/information at all times during an application’s execution. Spin has support for applications that need data in the form of key/value pairs and are satisfied by a Basically Available, Soft State, and Eventually Consistent (BASE) model. Workload examples include general value caching, session caching, counters, and serialized application state. In this tutorial, you will learn how to do the following:undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/key-value-store-tutorial#key-value-store-with-spin-applications"},{"project":"v2","title":"Spin Key-Value Store","subheading":"Tutorial Prerequisites","content":"First, follow undefined to install Spin. To ensure you have the correct version, you can check with this command:$ spin --versionundefined","keywords":"","subsectionKeywords":"","url":"/v2/key-value-store-tutorial#tutorial-prerequisites"},{"project":"v2","title":"Spin Key-Value Store","subheading":"Python","content":"If you are planning on using Python for this tutorial, please ensure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.","keywords":"","subsectionKeywords":"","url":"/v2/key-value-store-tutorial#python"},{"project":"v2","title":"Spin Key-Value Store","subheading":"Creating a New Spin Application","content":"Let's create a Spin application that will send and retrieve data from a key value store. To make things easy, we'll start from a template using the following commands (undefined):{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}$ spin new -t http-rust spin-key-value\n\n# Reference: https://github.com/spinframework/spin-rust-sdk/tree/stable/examples/rust-key-value{{ blockEnd }}{{ startTab \"TypeScript\" }}$ spin new -t http-ts spin-key-value\n\n# Reference: https://github.com/spinframework/spin-js-sdk/tree/sdk-v2/examples/spin-host-apis/spin-kv{{ blockEnd }}{{ startTab \"Python\" }}$ spin new -t http-py spin-key-value\n\n# Reference: https://github.com/spinframework/spin-python-sdk/tree/main/examples/spin-kv{{ blockEnd }}{{ startTab \"TinyGo\" }}$ spin new -t http-go spin-key-value\n\n# Reference: https://github.com/spinframework/spin-go-sdk/tree/stable/examples/key-value{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/key-value-store-tutorial#creating-a-new-spin-application"},{"project":"v2","title":"Spin Key-Value Store","subheading":"Configuration","content":"Good news - Spin will take care of setting up your Key Value store. However, in order to make sure your Spin application has permission to access the Key Value store, you must add the key_value_stores = [\"default\"] line in the [component.<component-name>] section of the spin.toml file, for each component which needs access to the Key Value store. This line is necessary to communicate to Spin that a given component has access to the default Key Value store. A newly scaffolded Spin application will not have this line; you will need to add it.undefined[component.spin_key_value]\n...\nkey_value_stores = [\"default\"]\n...undefinedEach Spin application's key_value_stores instances are implemented on a per-component basis across the entire Spin application. This means that within a multi-component Spin application (which has the same key_value_stores = [\"default\"] configuration line), each component will access that same data store. If one of your application's components creates a new key/value pair, another one of your application's components can update/overwrite that initial key/value after the fact.","keywords":"","subsectionKeywords":"","url":"/v2/key-value-store-tutorial#configuration"},{"project":"v2","title":"Spin Key-Value Store","subheading":"The Spin TOML File","content":"We will give our components access to the key value store by adding the key_value_stores = [\"default\"] in the `[component.<component-name>] section as shown below:spin_manifest_version = 2\n\n[application]\nname = \"spin-key-value\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"A simple application that exercises key-value storage.\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"spin-key-value\"\n\n[component.spin-key-value]\n...\nkey_value_stores = [\"default\"]\n...","keywords":"","subsectionKeywords":"","url":"/v2/key-value-store-tutorial#the-spin-toml-file"},{"project":"v2","title":"Spin Key-Value Store","subheading":"Write Code to Save and Load Data","content":"In this section, we use the Spin SDK to open and persist our application's data inside our default key/value store. This is a special store that every environment running Spin applications will make available for their application.","keywords":"","subsectionKeywords":"","url":"/v2/key-value-store-tutorial#write-code-to-save-and-load-data"},{"project":"v2","title":"Spin Key-Value Store","subheading":"The Spin SDK Version","content":"If you have an existing application and would like to try out the key/value feature, please check the Spin SDK reference in your existing application's configuration. It is highly recommended to upgrade Spin and the SDK versions to the latest version available.","keywords":"","subsectionKeywords":"","url":"/v2/key-value-store-tutorial#the-spin-sdk-version"},{"project":"v2","title":"Spin Key-Value Store","subheading":"Source Code","content":"Now let's use the Spin SDK to:undefinedundefinedundefinedundefinedundefined{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}use spin_sdk::{\n    http::{IntoResponse, Request, Response, Method},\n    http_component,\n    key_value::Store,\n};\n\n#[http_component]\nfn handle_request(req: Request) -> anyhow::Result<impl IntoResponse> {\n    // Open the default key-value store\n    let store = Store::open_default()?;\n\n    let (status, body) = match *req.method() {\n        Method::Post => {\n            // Add the request (URI, body) tuple to the store\n            store.set(req.path(), req.body())?;\n            println!(\n                \"Storing value in the KV store with {:?} as the key\",\n                req.path()\n            );\n            (200, None)\n        }\n        Method::Get => {\n            // Get the value associated with the request URI, or return a 404 if it's not present\n            match store.get(req.path())? {\n                Some(value) => {\n                    println!(\"Found value for the key {:?}\", req.path());\n                    (200, Some(value))\n                }\n                None => {\n                    println!(\"No value found for the key {:?}\", req.path());\n                    (404, None)\n                }\n            }\n        }\n        Method::Delete => {\n            // Delete the value associated with the request URI, if present\n            store.delete(req.path())?;\n            println!(\"Delete key {:?}\", req.path());\n            (200, None)\n        }\n        Method::Head => {\n            // Like GET, except do not return the value\n            let code = if store.exists(req.path())? {\n                println!(\"{:?} key found\", req.path());\n                200\n            } else {\n                println!(\"{:?} key not found\", req.path());\n                404\n            };\n            (code, None)\n        }\n        // No other methods are currently supported\n        _ => (405, None),\n    };\n    Ok(Response::new(status, body))\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}import { ResponseBuilder, Kv } from \"@fermyon/spin-sdk\";\n\nconst encoder = new TextEncoder()\nconst decoder = new TextDecoder()\n\nexport async function handler(req: Request, res: ResponseBuilder) {\n\n  let store = Kv.openDefault()\n  let status = 200\n  let body\n\n  switch (req.method) {\n    case \"POST\":\n      store.set(req.uri, await req.text() || (new Uint8Array()).buffer)\n      console.log(`Storing value in the KV store with ${req.uri} as the key`);\n      break;\n    case \"GET\":\n      let val\n      try {\n        val = store.get(req.uri)\n        body = decoder.decode(val)\n      \tconsole.log(`Found value for the key ${req.uri}`);\n      } catch (error) {\n      \tconsole.log(`Key ${req.uri} not found`);\n        status = 404\n      }\n      break;\n    case \"DELETE\":\n      store.delete(req.uri)\n      console.log(`Deleted Key ${req.uri}`);\n      break;\n    case \"HEAD\":\n      if (!store.exists(req.uri)) {\n        console.log(`Key ${req.uri} not found`);\n        status = 404\n      } else {\n        console.log(`Found Key ${req.uri}`);\n      }\n      break;\n    default:\n  }\n  res.status(status)\n  res.send(body)\n}{{ blockEnd }}{{ startTab \"Python\" }}from spin_sdk import http, key_value\nfrom spin_sdk.http import Request, Response\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        with key_value.open_default() as store:\n            match request.method:\n                case \"GET\":\n                    value = store.get(request.uri)\n                    if value:\n                        status = 200\n                        print(f\"Found key {request.uri}\")\n                    else:\n                        status = 404\n                        print(f\"Key {request.uri} not found\")\n                    return Response( status, {\"content-type\": \"text/plain\"}, value)\n                case \"POST\":\n                    store.set(request.uri, request.body)\n                    print(f\"Stored key {request.uri}\")\n                    return Response(200, {\"content-type\": \"text/plain\"})\n                case \"DELETE\":\n                    store.delete(request.uri)\n                    print(f\"Deleted key {request.uri}\")\n                    return Response(200, {\"content-type\": \"text/plain\"})\n                case \"HEAD\":\n                    if store.exists(request.uri):\n                        print(f\"Found key {request.uri}\")\n                        return Response(200, {\"content-type\": \"text/plain\"})\n                    print(f\"Key not found {request.uri}\")\n                    return Response(404, {\"content-type\": \"text/plain\"})\n                case default:\n                    return Response(405, {\"content-type\": \"text/plain\"})\n\n{{ blockEnd }}\n\n\n{{ startTab \"TinyGo\" }}\n\n```go\npackage main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"fmt\"\n\n\tspin_http \"github.com/fermyon/spin/sdk/go/v2/http\"\n\t\"github.com/fermyon/spin/sdk/go/v2/kv\"\n)\n\nfunc init() {\n\t// handler for the http trigger\n\tspin_http.Handle(func(w http.ResponseWriter, r *http.Request) {\n\t\tstore, err := kv.OpenStore(\"default\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer store.Close()\n\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tswitch r.Method {\n\t\tcase http.MethodPost:\n\t\t\terr := store.Set(r.URL.Path, body)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Println(\"Stored the key at:\", r.URL.Path)\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\tcase http.MethodGet:\n\t\t\tvalue, err := store.Get(r.URL.Path)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfmt.Println(\"Got the key:\", r.URL.Path)\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tw.Write(value)\n\t\tcase http.MethodDelete:\n\t\t\terr := store.Delete(r.URL.Path)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Println(\"Deleted the key:\", r.URL.Path)\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\tcase http.MethodHead:\n\t\t\texists, err := store.Exists(r.URL.Path)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif exists {\n\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t\tfmt.Println(\"Found key:\", r.URL.Path)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfmt.Println(\"Didn't find the key:\", r.URL.Path)\n\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\tdefault:\n\t\t\thttp.Error(w, \"method not allowed\", http.StatusMethodNotAllowed)\n\t\t}\n\t})\n}\n\nfunc main() {}\n{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/key-value-store-tutorial#source-code"},{"project":"v2","title":"Spin Key-Value Store","subheading":"Building and Running Your Spin Application","content":"Now, let's build and run our Spin Application locally. Run the following command to build your application:$ spin build\n$ spin upundefined","keywords":"","subsectionKeywords":"","url":"/v2/key-value-store-tutorial#building-and-running-your-spin-application"},{"project":"v2","title":"Spin Key-Value Store","subheading":"Storing and Retrieving Data From Your Default Key/Value Store","content":"Once you have completed this minimal configuration and deployed your application, data will be persisted across requests. Let's begin by creating a POST request that stores a JSON key/value object:# Create a new POST request and set the key/value pair of foo:bar\n$ curl localhost:3000/test -H 'Content-Type: application/json' -d '{\"foo\":\"bar\"}'We can now use a HEAD request to confirm that our component is holding data for us. Essentially, all we want to see here is a 200 OK response when calling our components endpoint (/test). Let's give it a try:$ curl -I localhost:3000/test\n\nHTTP/1.1 200 OKPerfect, 200 OK. Now, let's create a GET request that fetches the data from our component:# Create a GET request and fetch the key/value that we stored in the previous request\n$ curl localhost:3000/test\n\n{\"foo\": \"bar\"}Great! The above command successfully returned our data as intended.Lastly, we show how to create a DELETE request that removes the data for this specific component altogether:$ curl -X DELETE localhost:3000/testNote how all of the above commands returned 200 OK responses. In these examples, we were able to POST, HEAD (check to see if data exists), GET and also DELETE data from our component.Interestingly there is one more request we can re-run before wrapping up this tutorial. If no data exists in the component's endpoint of /test (which is technically the case now that we have sent the DELETE request) the HEAD request should correctly return 404 Not Found. You can consider this a type of litmus test; let's try it out:$ curl -I localhost:3000/test\n\nHTTP/1.1 404 Not FoundAs we can see above, there is currently no data found at the /test endpoint of our application.","keywords":"","subsectionKeywords":"","url":"/v2/key-value-store-tutorial#storing-and-retrieving-data-from-your-default-keyvalue-store"},{"project":"v2","title":"Spin Key-Value Store","subheading":"(Optional) Deploy Your App To Fermyon Cloud","content":"Optionally, if you'd like to deploy your application and key value store to Fermyon Cloud here are the required steps.First, login to your Fermyon Cloud account. If you do not have one already, this will take you through the signup process for a free account.$ spin login\n\nCopy your one-time code:\n\nXXXXXXXX\n\n...and open the authorization page in your browser:\n\nhttps://cloud.fermyon.com/device-authorization\n\nWaiting for device authorization...\nDevice authorized!Now that we have our dependencies squared away, let's deploy our application to Fermyon Cloud. From your application root folder, run the following command and opt to allow Fermyon Cloud to create a key value store on your behalf:$ spin cloud deploy\nspin deploy\nUploading spin-key-value version 0.1.0-r234fe5a4 to Fermyon Cloud...\nDeploying...\nApp \"spin-key-value\" accesses a key value store labeled \"default\"\nWould you like to link an existing key value store or create a new key value store?:\n> Use an existing key value store and link app to it\n  Create a new key value store and link the app to itundefinedCongratulations, you have a Spin application and associated Key Value store running up in Fermyon Cloud! You can visit it by clicking on the Spin application's domain name generated in the CLI output, which has the following pattern: spin-key-value-<RANDOM>.fermyon.app.","keywords":"","subsectionKeywords":"","url":"/v2/key-value-store-tutorial#optional-deploy-your-app-to-fermyon-cloud"},{"project":"v2","title":"Spin Key-Value Store","subheading":"Next Steps","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/key-value-store-tutorial#next-steps"},{"project":"v2","title":"Spin on Kubernetes","subheading":"","content":"","subsectionKeywords":"","url":"/v2/kubernetes"},{"project":"v2","title":"Spin on Kubernetes","subheading":"Why Use Spin With Kubernetes?","content":"In addition to spin up Fermyon also offers Fermyon Cloud to deploy spin apps into production, so why use Spin with Kubernetes? For users that have made existing investments into Kubernetes or have requirements that their applications stay within certain clouds, not be on shared infrastructure, or run on-premise, Kubernetes provides a robust solution.There are a few options for running Spin on Kubernetes:undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/kubernetes#why-use-spin-with-kubernetes"},{"project":"v2","title":"Key Value Store","subheading":"","content":"undefinedundefinedundefinedSpin provides an interface for you to persist data in a key value store managed by Spin. This key value store allows Spin developers to persist non-relational data across application invocations. To learn more about key value store use cases and how to enable your Spin application to use a key value store, check out our undefined.{{ details \"Why do I need a Spin interface? Why can't I just use my own external store?\" \"You can absolutely still use your own external store either with the Redis or Postgres APIs, or outbound HTTP. However, if you're interested in quick, non-relational local storage without any infrastructure set-up then Spin's key value store is a great option.\" }}","subsectionKeywords":"","url":"/v2/kv-store-api-guide"},{"project":"v2","title":"Key Value Store","subheading":"Using Key Value Store From Applications","content":"The Spin SDK surfaces the Spin key value store interface to your language. The following characteristics are true of keys and values:undefinedundefinedundefinedThe set of operations is common across all SDKs:| Operation  | Parameters | Returns | Behavior |\n|------------|------------|---------|----------|\n| open  | name | store  | Open the store with the specified name. If name is the string \"default\", the default store is opened, provided that the component that was granted access in the component manifest from spin.toml. Otherwise, name must refer to a store defined and configured in a undefined supplied with the application.|\n| get | store, key | value | Get the value associated with the specified key from the specified store. |\n| set | store, key, value | - | Set the value associated with the specified key in the specified store, overwriting any existing value. |\n| delete | store, key | - | Delete the tuple with the specified key from the specified store. error::invalid-store will be raised if store is not a valid handle to an open store.  No error is raised if a tuple did not previously exist for key.|\n| exists | store, key | boolean | Return whether a tuple exists for the specified key in the specified store.|\n| get-keys | store | list<keys> | Return a list of all the keys in the specified store. |\n| close | store | - | Close the specified store. |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedKey value functions are available in the spin_sdk::key_value module. The function names match the operations above. For example:use anyhow::Result;\nuse spin_sdk::{\n    http::{IntoResponse, Request, Response},\n    http_component,\n    key_value::{Store},\n};\n#[http_component]\nfn handle_request(_req: Request) -> Result<impl IntoResponse> {\n    let store = Store::open_default()?;\n    store.set(\"mykey\", b\"myvalue\")?;\n    let value = store.get(\"mykey\")?;\n    let response = value.unwrap_or_else(|| \"not found\".into());\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(response)\n        .build())\n}undefinedset undefinedundefinedget undefinedundefinedopen and close undefinedundefinedset_json and get_json undefinedundefined{{ blockEnd }}{{ startTab \"Typescript\"}}undefinedThe key value functions can be accessed after opening a store using either undefined which returns a undefined. For example:import { ResponseBuilder , Kv} from \"@fermyon/spin-sdk\";\n\nexport async function handler(req: Request, res: ResponseBuilder) {\n    let store = Kv.openDefault()\n    store.set(\"mykey\", \"myvalue\")\n    res.status(200)\n    res.set({\"content-type\":\"text/plain\"})\n    res.send(store.get(\"mykey\") ?? \"Key not found\")\n}undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined and undefinedundefined{{ blockEnd }}{{ startTab \"Python\"}}undefinedThe key value functions are provided through the spin_key_value module in the Python SDK. For example:from spin_sdk import http, key_value\nfrom spin_sdk.http import Request, Response\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        with key_value.open_default() as store:\n            store.set(\"test\", bytes(\"hello world!\", \"utf-8\"))\n            val = store.get(\"test\")\n            \n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            val\n        )\nundefinedundefinedundefinedundefined{{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedKey value functions are provided by the github.com/fermyon/spin/sdk/go/v2/kv module. undefined For example:import \"github.com/fermyon/spin/sdk/go/v2/kv\"\n\nfunc example() error {\n    store, err := kv.OpenStore(\"default\")\n    if err != nil {\n        return err\n    }\n    defer store.Close()\n    previous, err := store.Get(\"mykey\")\n    return store.Set(\"mykey\", []byte(\"myvalue\"))\n}\n{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/kv-store-api-guide#using-key-value-store-from-applications"},{"project":"v2","title":"Key Value Store","subheading":"Custom Key Value Stores","content":"Spin defines a key-value store named \"default\" and provides automatic backing storage.  If you need to customize Spin with additional stores, or to change the backing storage for the default store, you can do so via the --runtime-config-file flag and the runtime-config.toml file.  See undefined for details.","keywords":"","subsectionKeywords":"","url":"/v2/kv-store-api-guide#custom-key-value-stores"},{"project":"v2","title":"Key Value Store","subheading":"Granting Key Value Store Permissions to Components","content":"By default, a given component of an app will not have access to any key value store. Access must be granted specifically to each component via the component manifest:[component.example]\n# Pass in 1 or more key value stores, based on how many you'd like your component to have access to\nkey_value_stores = [\"<store 1>\", \"<store 2>\"]For example, a component could be given access to the default store using key_value_stores = [\"default\"].","keywords":"","subsectionKeywords":"","url":"/v2/kv-store-api-guide#granting-key-value-store-permissions-to-components"},{"project":"v2","title":"Language Support Overview","subheading":"","content":"This page contains information about language support for Spin features:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefined| Feature | SDK Supported? |\n|-----|-----|\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| undefined | Supported |{{ blockEnd }}{{ startTab \"TypeScript\"}}undefined| Feature | SDK Supported? |\n|-----|-----|\n| undefined |\n| undefined | Supported |\n| Redis | Not Supported |\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| Authoring Custom Triggers | Not Supported |{{ blockEnd }}{{ startTab \"Python\"}}undefined| Feature | SDK Supported? |\n|-----|-----|\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| MySQL | Supported |\n| PostgreSQL |  Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Not Supported |\n| undefined |\n| Authoring Custom Triggers | Not Supported |{{ blockEnd }}{{ startTab \"TinyGo\"}}undefined| Feature | SDK Supported? |\n|-----|-----|\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Not Supported |\n| undefined |\n| Authoring Custom Triggers | Not Supported |{{ blockEnd }}{{ blockEnd }}","subsectionKeywords":"","url":"/v2/language-support-overview"},{"project":"v2","title":"Managing Plugins","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedPlugins are a way to extend the functionality of Spin. Spin provides commands for installing and removing them, so you don't need to use separate installation tools. When you have installed a plugin into Spin, you can call it as if it were a Spin subcommand. For example, the JavaScript SDK uses a tool called js2wasm to package JavaScript code into a Wasm module, and JavaScript applications run it via the spin js2wasm command.","subsectionKeywords":"","url":"/v2/managing-plugins"},{"project":"v2","title":"Managing Plugins","subheading":"Installing Plugins","content":"To install plugins, use the spin plugins install command. You can install plugins by name from a curated repository, or other plugins from a URL or file system.","keywords":"","subsectionKeywords":"","url":"/v2/managing-plugins#installing-plugins"},{"project":"v2","title":"Managing Plugins","subheading":"Installing Well Known Plugins","content":"The Spin maintainers curate a catalogue of \"known\" plugins. You can install plugins from this catalogue by name:$ spin plugins install js2wasmSpin checks that the plugin is available for your version of Spin and your operating system, and prompts you to confirm the installation. To skip the prompt, pass the --yes flag.undefined","keywords":"","subsectionKeywords":"","url":"/v2/managing-plugins#installing-well-known-plugins"},{"project":"v2","title":"Managing Plugins","subheading":"Installing a Specific Version of a Plugin","content":"To install a specific version of a plugin, pass the --version flag:$ spin plugins install js2wasm --version 0.4.0","keywords":"","subsectionKeywords":"","url":"/v2/managing-plugins#installing-a-specific-version-of-a-plugin"},{"project":"v2","title":"Managing Plugins","subheading":"Installing a Plugin From a URL","content":"If the plugin you want has been published on the Web but has not been added to the catalogue, you can install it from its manifest URL. The manifest is the JSON document that links to the binaries for different operating systems and processors. For example:$ spin plugins install --url https://github.com/spinframework/spin-befunge-sdk/releases/download/v1.4.0/befunge2wasm.json","keywords":"","subsectionKeywords":"","url":"/v2/managing-plugins#installing-a-plugin-from-a-url"},{"project":"v2","title":"Managing Plugins","subheading":"Installing a Plugin From a File","content":"If the plugin you want is in your local file system, you can install it from its manifest file path. The manifest is the JSON document that links to the binaries for different operating systems and processors. For example:$ spin plugins install --file ~/dev/spin-befunge-sdk/befunge2wasm.json","keywords":"","subsectionKeywords":"","url":"/v2/managing-plugins#installing-a-plugin-from-a-file"},{"project":"v2","title":"Managing Plugins","subheading":"Running a Plugin","content":"You run plugins in the same way as built-in Spin subcommands. For example:$ spin js2wasm --help","keywords":"","subsectionKeywords":"","url":"/v2/managing-plugins#running-a-plugin"},{"project":"v2","title":"Managing Plugins","subheading":"Viewing Available Plugins","content":"To see what plugins are available in the catalogue, run spin plugins search:$ spin plugins search\nbefunge2wasm 1.4.0 [incompatible]\njs2wasm 0.3.0 [installed]\njs2wasm 0.4.0\ntrigger-sqs 0.1.0The annotations by the plugins show their status and compatibility:| Annotation                      | Meaning |\n|---------------------------------|---------|\n| [incompatible]                | The plugin does not run on your operating system or processor. |\n| [installed]                   | You have the plugin already installed and available to run. |\n| [requires other Spin version] | The plugin can run on your operating system and processor, but is not compatible with the version of Spin you are running. The annotation indicates which versions of Spin it is compatible with. |","keywords":"","subsectionKeywords":"","url":"/v2/managing-plugins#viewing-available-plugins"},{"project":"v2","title":"Managing Plugins","subheading":"Viewing Installed Plugins","content":"To see only the plugins you have installed, run spin plugins list --installed.","keywords":"","subsectionKeywords":"","url":"/v2/managing-plugins#viewing-installed-plugins"},{"project":"v2","title":"Managing Plugins","subheading":"Uninstalling Plugins","content":"You can uninstall plugins using spin plugins uninstall with the plugin name:$ spin plugins uninstall befunge2wasm","keywords":"","subsectionKeywords":"","url":"/v2/managing-plugins#uninstalling-plugins"},{"project":"v2","title":"Managing Plugins","subheading":"Refreshing the Catalogue","content":"The first time you install a plugin from the catalogue, Spin creates a local cache of the catalogue. It continues to use this local cache for future install, list and upgrade commands; this is similar to OS package managers such as apt, and avoids rate limiting on the catalogue. However, this means that in order to see new catalogue entries - new plugins or new versions - you must first update the cache.To update your local cache of the catalogue, run spin plugins update.","keywords":"","subsectionKeywords":"","url":"/v2/managing-plugins#refreshing-the-catalogue"},{"project":"v2","title":"Managing Plugins","subheading":"Upgrading Plugins","content":"To upgrade a plugin to the latest version, first run spin plugins update (to refresh the catalogue), then spin plugins upgrade.The spin plugins upgrade command has the same options as the spin plugins install command (according to whether the plugin comes from the catalogue, a URL, or a file). For more information, see the plugins section of the undefined.undefinedThe following example shows how to upgrade one plugin at a time (i.e. the js2wasm plugin):$ spin plugins update\n$ spin plugins upgrade js2wasmThe following example shows how to upgrade all installed plugins at once:$ spin plugins update\n$ spin plugins upgrade --allundefinedThe following example shows additional upgrade options. Specifically, how to upgrade using the path to a remote plugin manifest and how to upgrade using the path to a local plugin manifest:$ spin plugins upgrade --url https://github.com/spinframework/spin-befunge-sdk/releases/download/v1.7.0/befunge2wasm.json\n$ spin plugins upgrade --file ~/dev/spin-befunge-sdk/befunge2wasm.json","keywords":"","subsectionKeywords":"","url":"/v2/managing-plugins#upgrading-plugins"},{"project":"v2","title":"Managing Plugins","subheading":"Downgrading Plugins","content":"By default, Spin will only undefined plugins. Pass the --downgrade flag and specify the --version if you want Spin to roll back to an earlier version. The following abridged example (which doesn't list the full console output for simplicity) lists the versions of plugins, downgrades the js2wasm to an older version (0.6.0) and then lists the versions again to show the results:$ spin plugins update\n$ spin plugins list\n// --snip--\njs2wasm 0.6.0\njs2wasm 0.6.1 [installed]\n$ spin plugins upgrade js2wasm --downgrade --version 0.6.0\n$ spin plugins list\n// --snip--\njs2wasm 0.6.0 [installed]\njs2wasm 0.6.1After downgrading, the [installed] indicator is aligned with the 0.6.0 version of js2wasm, as intended in the example.","keywords":"","subsectionKeywords":"","url":"/v2/managing-plugins#downgrading-plugins"},{"project":"v2","title":"Managing Plugins","subheading":"Next Steps","content":"undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/managing-plugins#next-steps"},{"project":"v2","title":"Managing Templates","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedTemplates are a Spin tool for scaffolding new applications and components. You can use them via the spin new and spin add commands. For more information about creating applications with templates, see undefined.","subsectionKeywords":"","url":"/v2/managing-templates"},{"project":"v2","title":"Managing Templates","subheading":"Installing Templates","content":"undefinedTo install templates, use the spin templates install command. You can install templates from a Git repository, or while undefined you can install them from a local directory.","keywords":"","subsectionKeywords":"","url":"/v2/managing-templates#installing-templates"},{"project":"v2","title":"Managing Templates","subheading":"Installing From the Spin Git Repository","content":"To install templates from the Spin Git repository, run spin templates install --git:$ spin templates install --git https://github.com/spinframework/spinIf you prefer a shorter command, you can just pass the repository id instead of the full URL:$ spin templates install --git fermyon/spinThe above command installs undefined templates in the repository.undefined","keywords":"","subsectionKeywords":"","url":"/v2/managing-templates#installing-from-the-spin-git-repository"},{"project":"v2","title":"Managing Templates","subheading":"Installing From a Specific Branch","content":"By default, if you install templates from a Git repository, Spin tries to find a repo tag that matches the version of Spin, and installs from that tag.  Failing this, it installs from HEAD.  If you would like to install from a specific tag or branch, pass the --branch option:$ spin templates install --git https://github.com/spinframework/spin --branch spin/templates/v0.8","keywords":"","subsectionKeywords":"","url":"/v2/managing-templates#installing-from-a-specific-branch"},{"project":"v2","title":"Managing Templates","subheading":"Installing From a Local Directory","content":"To install templates from your local file system, run spin templates install --dir.undefined# Expects to find a directory ~/dev/spin-befunge-sdk/templates\n$ spin templates install --dir ~/dev/spin-befunge-sdkSee undefined for more details on this layout.","keywords":"","subsectionKeywords":"","url":"/v2/managing-templates#installing-from-a-local-directory"},{"project":"v2","title":"Managing Templates","subheading":"Viewing Your Installed Templates","content":"To see what templates you have installed, run spin templates list.You can use the --verbose option to see additional information such as where they were installed from.","keywords":"","subsectionKeywords":"","url":"/v2/managing-templates#viewing-your-installed-templates"},{"project":"v2","title":"Managing Templates","subheading":"Uninstalling Templates","content":"You can uninstall templates using spin templates uninstall with the template name:$ spin templates uninstall redis-befungeundefined","keywords":"","subsectionKeywords":"","url":"/v2/managing-templates#uninstalling-templates"},{"project":"v2","title":"Managing Templates","subheading":"Upgrading Templates","content":"When you upgrade Spin, you will typically want to upgrade your templates to match.  This means new applications and components will get dependencies that match the Spin version you are using.  To do this, run spin templates upgrade:$ spin templates upgrade\nSelect repos to upgrade. Use Space to select/deselect and Enter to confirm selection.\n  [x] https://github.com/spinframework/spin-python-sdk\n  [ ] https://github.com/spinframework/spin (at spin/templates/v1.0)\n> [x] https://github.com/spinframework/spin-js-sdkUse the cursor keys and the space bar to select the repositories you want to upgrade, then hit Enter to upgrade the selected repositories.undefinedIf you want to upgrade undefined repositories without being prompted, run spin templates upgrade --all.As mentioned above, if you want to check which templates come from which repositories use --verbose i.e. spin templates list --verbose.","keywords":"","subsectionKeywords":"","url":"/v2/managing-templates#upgrading-templates"},{"project":"v2","title":"Managing Templates","subheading":"Upgrading Templates From a Local Directory","content":"spin templates upgrade only upgrades from Git repositories.  If you want to upgrade and your templates are in a local directory, run the spin templates install command with the --upgrade flag:$ spin templates install --dir ~/dev/spin-befunge-sdk --upgrade","keywords":"","subsectionKeywords":"","url":"/v2/managing-templates#upgrading-templates-from-a-local-directory"},{"project":"v2","title":"Managing Templates","subheading":"Next Steps","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/managing-templates#next-steps"},{"project":"v2","title":"Spin Application Manifest (Version 1) Reference","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedThis page describes version 1 of the Spin manifest file, typically called spin.toml.undefined","subsectionKeywords":"","url":"/v2/manifest-reference-v1"},{"project":"v2","title":"Spin Application Manifest (Version 1) Reference","subheading":"Format","content":"The manifest is a TOML file, and follows standard TOML syntax.  See the undefined for information about the TOML syntax.","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference-v1#format"},{"project":"v2","title":"Spin Application Manifest (Version 1) Reference","subheading":"Manifest Fields","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| spin_manifest_version | Required   | String      | The version of the file format that the rest of the manifest follows. Currently, this value must be \"1\". | \"1\" |\n| name                  | Required   | String      | The name of the application. This may be any string of alphanumeric characters, hyphens and underscores. | \"hello-world\" |\n| version               | Required   | String      | The version of the application. The must be a string of the form major.minor.patch, where each element is a number. | \"1.0.5\" |\n| description           | Optional   | String      | A human-readable description of the application. | \"The best app for all your world-greeting needs\" |\n| authors               | Optional   | Array of strings | The authors of the applications. If present, this must ba an array, even if it has only one entry. | [\"Jane Q Hacker (<dev@example.com>)\"] |\n| trigger               | Required   | Table       | The trigger for the application - that is, the kind of event that the application responds to. The table must contain the type field, and may contain others depending on the value of type. See undefined for details. | { type = \"http\", base = \"/\" } |\n| variables             | Optional   | Table       | Dynamic configuration variables which the user can set when they run the application. See undefined below. | [variables]<br />message = { default = \"hello\" } |\n| component             | Required   | Table array | A manifest must contain at least one component table. component is always an array, even if there is only one component, so always use double square brackets.  See undefined below. | [[component]]<br />id = \"hello\" |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference-v1#manifest-fields"},{"project":"v2","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  trigger  Table","content":"The trigger table specifies the events that the application responds to.  The type field is always required, but the other fields depend on the type.  This section describes the built-in http and redis trigger types.undefinedtrigger = { type = \"http\", base = \"/\" }","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference-v1#the-trigger-table"},{"project":"v2","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  trigger  Table for HTTP Applications","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| type                  | Required   | String      | Always \"http\" for HTTP applications. | \"http\" |\n| base                  | Required   | String      | The base path of the application. All component routes are relative to this. It allows multiple applications to be mounted under the same host. | \"/\" |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference-v1#the-trigger-table-for-http-applications"},{"project":"v2","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  trigger  Table for Redis Applications","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| type                  | Required   | String      | Always \"redis\" for Redis applications. | \"redis\" |\n| address               | Required   | String      | The address of the Redis instance the components are using the message subscriptions. Use the redis: URL scheme. | \"redis://localhost:6379\" |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference-v1#the-trigger-table-for-redis-applications"},{"project":"v2","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  variables  Table","content":"The keys of variables table are user-defined.  The value of each key is another table with the fields shown in the following table.undefined[variables]\nvessel = { default = \"teapot\" }\ntoken = { required = true, secret = true }| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| default               | Optional   | String      | The value of the variable if no value is supplied at runtime. If specified, the value must be a string. If not specified, required must be true. | \"teapot\" |\n| required              | Optional   | Boolean     | Whether a value must be supplied at runtime. If not specified, required defaults to false, and default must be provided | false |\n| secret                | Optional   | Boolean     | If set, this variable should be treated as sensitive. | false |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference-v1#the-variables-table"},{"project":"v2","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  component  Tables","content":"component is a table array, meaning each component is introduced with double-bracket syntax.  Subtables are written using single-bracket syntax or inline JSON syntax.  For example:[[component]]\nid = \"hello\"\nsource = \"hello.wasm\"\n[component.trigger]\nroute = \"/hello\"Each table in the component array contains the following fields:| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| id                    | Required   | String      | An identifier for this component, unique within the application. This may be any string of alphanumeric characters, hyphens and underscores. | \"cart-api\" |\n| description           | Optional   | String      | A human-readable description of the component. | \"The shopping cart API\" |\n| source                | Required   | String or table | The Wasm module which should handle the component. This must be built to work with the application trigger. It can be in one of the following formats: | |\n|                         |            | String      | * The path to a Wasm file (relative to the manifest file) | dist/cart.wasm |\n|                         |            | Table       | * The URL of a Wasm file downloadable over HTTP. This must be a table containing a url field for the Wasm file, and a digest field contains a SHA256 hex digest, used to check integrity. | { url = \"https://example.com/example.wasm\", digest = \"sha256:6503...2375\" } |\n| files                 | Optional   | Array of strings and/or tables | The undefined. This is an array, and each element of the array is either: | [ \"images/*.jpg\", { source = \"assets/images\", destination = \"/pictures\" } ] |\n|                         |            | String      | * A file path or glob pattern, relative to the manifest file. The matching file or files will be available in the Wasm module at the same relative paths. | \"images/*.jpg\" |\n|                         |            | Table       | * A directory to be made available to the Wasm module at a specific path. This must be a table containing a source field for the directory relative to the manifest file, and a destination field containing the absolute path at which to make it available. | { source = \"assets/images\", destination = \"/pictures\" } |\n| exclude_files         | Optional   | Array of strings | Any files or glob patterns that should undefined be available to the Wasm module at runtime, even though they match a files entry. | [assets/images/test/**/*.*] |\n| allowed_http_hosts    | Optional   | Array of strings | The host names or addresses to which the Wasm module is allowed to send HTTP requests. If the name includes a port, the Wasm module can send requests only to that port; otherwise, the Wasm module can send requests only to the default port for the scheme it uses. The special string insecure:allow-all permits the module to send HTTP requests to undefined host, but is intended for development use only; some deployment environments may decline to honour it. | [\"example.com\", \"localhost:8081\"] |\n| allowed_outbound_hosts | Optional  | Array of strings | The addresses to which the Wasm component is allowed to send network requests. This applies to the outbound HTTP, outbound Redis, MySQL and PostgreSQL APIs. (It does not apply to built-in storage services such as key-value and SQLite.) Each entry must contain both a scheme, a name (or IP address) and a port in scheme://name:port format. For known schemes, you may omit the port if it is the default for the scheme. Use * for wildcards. If this field is omitted, no outbound access is permitted, undefined that, for backward compatibility, a Spin 1 component may use Redis, MySQL or PostgreSQL to undefined host. If this field is present and empty, however, no outbound access if permitted, regardless of the component's Spin version. | [\"mysql://db.example.com\", \"*://example.com:4567\", \"http://127.0.0.1:*\"] |\n| key_value_stores      | Optional   | Array of strings | An array of key-value stores that the Wasm module is allowed to read or write. A store named default is provided by the Spin runtime, though modules must still be permitted to access it. In current versions of Spin, \"default\" is the only store allowed. | [\"default\"] |\n| environment           | Optional   | Table       | Environment variables to be set for the Wasm module. This is a table. The table keys are user-defined; the values must be strings. | { DB_URL = \"mysql://spin:spin@localhost/dev\" } |\n| trigger               | Required   | Table       | Specifies how this component is triggered. This is a table, whose contents of are trigger-specific; see below. | [component.trigger]<br />route = \"/...\" |\n| build                 | Optional   | Table       | The command that spin build uses to build this component. See undefined below. | [component.build]<br />command = \"npm run build\" |\n| config                | Optional   | Table       | Dynamic configuration values to be made available to this component. The table keys are user-defined; the values must be strings, and may use template notation as described under undefined. | [component.config]<br />api_base_url = \"https://{{ api_host }}/v1\" |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference-v1#the-component-tables"},{"project":"v2","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  component.trigger  Table for HTTP Applications","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| route                 | Required   | String      | The route which this component handles. Requests to the route will cause the component to execute. This may be an exact route (/example), which matches on the given path, or a wildcard route indicated by the suffix /... (/example/...), which matches any route under this prefix. If two routes overlap, requests are directed to the matching route with the longest prefix - see undefined for details and examples. | \"/api/cart/...\" |\n| executor              | Optional   | Table       | How Spin should invoke the component. If present, this is a table.  The type key is required and may have the values \"spin\" or \"wagi\". If omitted. the default is { type = \"spin\"}. See undefined for details. | { type = \"wagi\" } |\n|                         |            |             | If type = \"spin\" there are no other keys defined. In this case, Spin calls the component using a standard Wasm component interface. Components built using Spin SDKs or Spin interface files use this convention. | { type = \"spin\" } |\n|                         |            |             | If type = \"wagi\", Spin calls the component's \"main\" (_start) function using undefined. Components built using languages or toolchains that do not support Wasm interfaces will need to be called in this way. In this case, the following additional keys may be set:<br/><br/>* argv (optional): The string representation of the argv list that should be passed into the handler. ${SCRIPT_NAME} will be replaced with the script name, and ${ARGS} will be replaced with the query parameters of the request, formatted as arguments. The default is to follow the CGI specification, and pass ${SCRIPT_NAME} ${ARGS}<br/><br/>* entrypoint (optional): The name of the function to call as the entry point to this handler. By default, it is _start (which in most languages translates to main in the source code).<br/><br/>See undefined for details. | { type = \"wagi\" } |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference-v1#the-componenttrigger-table-for-http-applications"},{"project":"v2","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  component.trigger  Table for Redis Applications","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| channel               | Required   | String      | The Redis channel which this component handles. Messages on this channel will cause the component to execute. | \"purchases\" |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference-v1#the-componenttrigger-table-for-redis-applications"},{"project":"v2","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  component.build  Table","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| command               | Required   | String      | The command to execute on spin build. | \"cargo build --target wasm32-wasi --release\" |\n| workdir               | Optional   | String      | The directory in which to execute command, relative to the manifest file. The default is the directory containing the manifest file. An example of where this is needed is a multi-component application where each component is its own source tree in its own directory. | \"my-project\" |\n| watch                 | Optional   | Array of strings | The files or glob patterns which spin watch should monitor to determine if the component Wasm file needs to be rebuilt. These are relative to workdir, or to the directory containing the manifest file if workdir is not present. | [\"src/**/*.rs\", \"Cargo.toml\"] |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference-v1#the-componentbuild-table"},{"project":"v2","title":"Spin Application Manifest (Version 1) Reference","subheading":"Next Steps","content":"undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference-v1#next-steps"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedThis page describes the contents of the Spin manifest file, typically called spin.toml.undefined","subsectionKeywords":"","url":"/v2/manifest-reference"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"Manifest Format","content":"The manifest is a TOML file, and follows standard TOML syntax.  See the undefined for information about the TOML syntax. Here is an example Spin application manifest (spin.toml) that was generated using spin new -t http-rust spin-manifest-example-in-rust:spin_manifest_version = 2\n\n[application]\nname = \"spin-manifest-example-in-rust\"\nversion = \"0.1.0\"\nauthors = [\"Fermyon Engineering <engineering@fermyon.com>\"]\ndescription = \"An example application to generate a Spin manifest file, in this case, via the HTTP Rust template.\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"spin-manifest-example-in-rust\"\n\n[component.spin-manifest-example-in-rust]\nsource = \"target/wasm32-wasi/release/spin_manifest_example_in_rust.wasm\"\nallowed_outbound_hosts = []\n[component.spin-manifest-example-in-rust.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#manifest-format"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"Using Variables in the Manifest","content":"The following fields allow you to use undefined in their values:undefinedundefinedundefinedundefinedSpin resolves manifest expressions at application load time. Subsequent changes to variables do not update expression-based values.The only variables permitted in manifest expressions are application variables.undefined","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#using-variables-in-the-manifest"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"Manifest Fields","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| spin_manifest_version | Required   | Number      | The version of the file format that the rest of the manifest follows. For manifests using this format, this value must be 2. | 2 |\n| application           | Required   | Table       | Information about the application and application-global options. See undefined below. | [application]<br />name = \"greetings\"<br />version = \"1.0.0\" |\n| variables             | Optional   | Table       | Dynamic configuration variables which the user can set when they run the application. See undefined below. | [variables]<br />message = { default = \"hello\" } |\n| trigger               | Required   | Table       | Associates triggers and conditions to the components that handle them - for example, mapping a HTTP route to a handling component. See undefined below. | [[trigger.http]]<br />component = \"greeter\"<br />route = \"/greet\" |\n| component             | Required   | Table       | The WebAssembly components that make up the application, together with whatever configuration and resources they depend on, such as asset files or storage access. See undefined below. | [component.greeter]<br />source = \"greeting_manager.wasm\"<br />files = [\"confetti.jpg\"] |undefined","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#manifest-fields"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"The  application  Table","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| name                  | Required   | String      | The name of the application. This may be any string of alphanumeric characters, hyphens and underscores. | \"hello-world\" |\n| version               | Optional   | String      | The version of the application. The must be a string of the form major.minor.patch, where each element is a number. | \"1.0.5\" |\n| description           | Optional   | String      | A human-readable description of the application. | \"The best app for all your world-greeting needs\" |\n| authors               | Optional   | Array of strings | The authors of the applications. If present, this must ba an array, even if it has only one entry. | [\"Jane Q Hacker (<dev@example.com>)\"] |\n| trigger               | Optional   | Table       | Application-global trigger settings. See undefined below. | [application.trigger.http]<br />base = \"/\" |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#the-application-table"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"The  application.trigger  Table","content":"The application.trigger should contain only one key, the trigger type whose settings you want to override. This is usually written inline as part of the TOML table header, e.g. [application.trigger.http].undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#the-applicationtrigger-table"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"The  application.trigger.http  Table","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| base                  | Optional   | String      | The base path of the application. All component routes are relative to this. It allows multiple applications to be mounted under the same host. | \"/\" |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#the-applicationtriggerhttp-table"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"The  application.trigger.redis  Table","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| address               | Required   | String      | The address of the Redis instance to which the components subscribe for messages, for triggers that do not specify an address themselves. Use the redis: URL scheme. | \"redis://localhost:6379\" |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#the-applicationtriggerredis-table"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"The  variables  Table","content":"The keys of the variables table are user-defined.  The value of each key is another table with the fields shown in the following table.undefined[variables]\nvessel = { default = \"teapot\" }\ntoken = { required = true, secret = true }| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| default               | Optional   | String      | The value of the variable if no value is supplied at runtime. If specified, the value must be a string. If not specified, required must be true. | \"teapot\" |\n| required              | Optional   | Boolean     | Whether a value must be supplied at runtime. If not specified, required defaults to false, and default must be provided | false |\n| secret                | Optional   | Boolean     | If set, this variable should be treated as sensitive. | false |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#the-variables-table"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"The  trigger  Table","content":"The trigger table contains only one key, the trigger type to which your application responds. The value of this key is a table array. In practice, the trigger table is written using table array syntax with the trigger type inlined into each entry. For example:[[trigger.http]]\nroute = \"/users\"\ncomponent = \"user-manager\"\n\n[[trigger.http]]\nroute = \"/reports\"\ncomponent = \"report\"Each array entry contains a mix of common fields and trigger-specific fields.","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#the-trigger-table"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"Common Fields for All  trigger.(type)  Tables","content":"| Name                    | Required?  | Type            | Value    | Example   |\n|-------------------------|------------|-----------------|----------|-----------|\n| component             | Required   | String or table | The component to run when a trigger event matching the trigger setting occurs (for example, when Spin receives an HTTP request matching the trigger's route). It can be in one of the following formats: |  |\n|                         |            | String          | * A key in the component table | \"user-manager\" |\n|                         |            | Table           | * Specifies an unnamed component to be associated with the trigger setting. This allows simple components to be written inline instead of needing a separate section. Such a table follows undefined format. | { source = \"reports.wasm\" }` |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#common-fields-for-all-triggertype-tables"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"Additional Fields for  trigger.http  Tables","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| route                 | Required   | String or table     | The route which this component handles. Requests to the route will cause the component to execute. | |\n|                         |            | String     | This may be an exact route (/example), which matches only the given path, or may include wildcards (/example/:id or /example/...). If two routes overlap, requests are directed to the matching route with the longest prefix. See undefined for details and examples. | \"/api/cart/...\" |\n|                         |            | Table     | If the component is a private endpoint used for undefined then use the table value shown here.  | { private = true }|\n| executor              | Optional   | Table       | How Spin should invoke the component. If present, this is a table.  The type key is required and may have the values \"spin\" or \"wagi\". If omitted. the default is { type = \"spin\"}. See undefined for details. | { type = \"wagi\" } |\n|                         |            |             | If type = \"spin\" there are no other keys defined. In this case, Spin calls the component using a standard Wasm component interface. Components built using Spin SDKs or Spin interface files use this convention. | { type = \"spin\" } |\n|                         |            |             | If type = \"wagi\", Spin calls the component's \"main\" (_start) function using undefined. Components built using languages or toolchains that do not support Wasm interfaces will need to be called in this way. In this case, the following additional keys may be set:<br/><br/>* argv (optional): The string representation of the argv list that should be passed into the handler. ${SCRIPT_NAME} will be replaced with the script name, and ${ARGS} will be replaced with the query parameters of the request, formatted as arguments. The default is to follow the CGI specification, and pass ${SCRIPT_NAME} ${ARGS}<br/><br/>* entrypoint (optional): The name of the function to call as the entry point to this handler. By default, it is _start (which in most languages translates to main in the source code).<br/><br/>See undefined for details. | { type = \"wagi\" } |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#additional-fields-for-triggerhttp-tables"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"Additional Fields for  trigger.redis  Tables","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| address               | Optional   | String      | The address of the Redis instance to which the trigger subscribes. Use the redis: URL scheme. If omitted, defaults to application.trigger.redis.address. | \"redis://localhost:6379\" |\n| channel               | Required   | String      | The Redis channel which this component handles. Messages on this channel will cause the component to execute. | \"purchases\" |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#additional-fields-for-triggerredis-tables"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"The  component  Table","content":"The keys of the component table, usually written as part of the table syntax e.g. [component.my-component], are user-defined.  (In the preceding example, the key is my-component). Component names must be kebab-cased, i.e. the only permitted separator is a hyphen.The value of each key is a table with the following fields.| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| description           | Optional   | String      | A human-readable description of the component. | \"The shopping cart API\" |\n| source                | Required   | String or table | The Wasm module which should handle the component. This must be built to work with the application trigger. It can be in one of the following formats: | |\n|                         |            | String      | * The path to a Wasm file (relative to the manifest file) | dist/cart.wasm |\n|                         |            | Table       | * The URL of a Wasm file downloadable over HTTP. This must be a table containing a url field for the Wasm file, and a digest field contains a SHA256 hex digest, used to check integrity. | { url = \"https://example.com/example.wasm\", digest = \"sha256:6503...2375\" } |\n|                         |            | Table (Highly Experimental)       | * The registry, package and version of a component from a registry. This experimental source configuration must be a table containing a registry domain field, a package field and a version field. | { registry = \"registrytest-abcd.fermyon.app\", package = \"component:hello-world\", version=\"0.0.1\" } or { registry = \"ttl.sh\", package = \"user:registrytest\", version=\"1.0.0\" } |\n| files                 | Optional   | Array of strings and/or tables | The undefined. This is an array, and each element of the array is either: | [ \"images/*.jpg\", { source = \"assets/images\", destination = \"/pictures\" } ] |\n|                         |            | String      | * A file path or glob pattern, relative to the manifest file. The matching file or files will be available in the Wasm module at the same relative paths. | \"images/*.jpg\" |\n|                         |            | Table       | * A file or directory to be made available to the Wasm module at a specific path. This must be a table containing a source field for the file or directory relative to the manifest file, and a destination field containing the absolute path at which to make it available. | { source = \"assets/images\", destination = \"/pictures\" } |\n| exclude_files         | Optional   | Array of strings | Any files or glob patterns that should undefined be available to the Wasm module at runtime, even though they match a files entry. | [assets/images/test/**/*.*] |\n| allowed_http_hosts    | Optional   | Array of strings | The host names or addresses to which the Wasm component is allowed to send HTTP requests. This is retained to simplify transition from the undefined; new applications should use allow_outbound_hosts instead. | [\"example.com\", \"localhost:8081\"] |\n| allowed_outbound_hosts | Optional  | Array of strings | The addresses to which the Wasm component is allowed to send network requests. This applies to the outbound HTTP, outbound Redis, MySQL and PostgreSQL APIs. (It does not apply to built-in storage services such as key-value and SQLite.) Each entry must contain both a scheme, a name (or IP address) and a port in scheme://name:port format. For known schemes, you may omit the port if it is the default for the scheme. Use * for wildcards. If this field is omitted or an empty list, no outbound access is permitted. | [\"mysql://db.example.com\", \"*://example.com:4567\", \"http://127.0.0.1:*\"] |\n| key_value_stores      | Optional   | Array of strings | An array of key-value stores that the Wasm module is allowed to read or write. A store named default is provided by the Spin runtime, though modules must still be permitted to access it. In current versions of Spin, \"default\" is the only store allowed. | [\"default\"] |\n| environment           | Optional   | Table       | Environment variables to be set for the Wasm module. This is a table. The table keys are user-defined; the values must be strings. | { DB_URL = \"mysql://spin:spin@localhost/dev\" } |\n| build                 | Optional   | Table       | The command that spin build uses to build this component. See undefined below. | [component.cart.build]<br />command = \"npm run build\" |\n| variables             | Optional   | Table       | Dynamic configuration values to be made available to this component. The table keys are user-defined; the values must be strings, and may use template notation as described under undefined. | [component.cart.variables]<br />api_base_url = \"https://{{ api_host }}/v1\" |undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#the-component-table"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"The  component.(id).build  Table","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| command               | Required   | String      | The command to execute on spin build. | \"cargo build --target wasm32-wasi --release\" |\n| workdir               | Optional   | String      | The directory in which to execute command, relative to the manifest file. The default is the directory containing the manifest file. An example of where this is needed is a multi-component application where each component is its own source tree in its own directory. | \"my-project\" |\n| watch                 | Optional   | Array of strings | The files or glob patterns which spin watch should monitor to determine if the component Wasm file needs to be rebuilt. These are relative to workdir, or to the directory containing the manifest file if workdir is not present. | [\"src/**/*.rs\", \"Cargo.toml\"] |","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#the-componentidbuild-table"},{"project":"v2","title":"Spin Application Manifest Reference","subheading":"Next Steps","content":"undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/manifest-reference#next-steps"},{"project":"v2","title":"MQTT Messaging","subheading":"","content":"undefinedundefinedundefinedSpin provides an experimental interface for you to send messages using the MQTT protocol.{{ details \"Why do I need a Spin interface? Why can't I just use my language's MQTT library?\" \"Few MQTT libraries have been updated to work over the WASI 0.2 sockets interface. The Spin interface means Wasm modules can bypass this limitation by asking Spin to make the MQTT connection on their behalf.\" }}undefined","subsectionKeywords":"","url":"/v2/mqtt-outbound"},{"project":"v2","title":"MQTT Messaging","subheading":"Sending MQTT Messages From Applications","content":"The Spin SDK surfaces the Spin MQTT interface to your language. The set of operations defined in Spin's API is as follows:| Operation    | Parameters          | Returns | Behavior |\n|--------------|---------------------|---------|----------|\n| open       | address, username, password, keep-alive | connection resource | Opens a connection to the specified MQTT server. The host must be listed in allowed_outbound_hosts. Other operations must be called through a connection. |\n| publish    | topic, payload, QoS | -       | Publishes the payload (a binary blob) as a message to the specified topic. |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedMQTT functions are available in the spin_sdk::mqtt module.To access an MQTT server, use the Connection::open function.let connection = spin_sdk::mqtt::Connection::open(&address, &username, &password, keep_alive_secs)?;You can then call the Connection::publish function to send MQTT messages:let cat_picture: Vec<u8> = request.body().to_vec();\nconnection.publish(\"pets\", &cat_picture, spin_sdk::mqtt::Qos::AtLeastOnce)?;For full details of the MQTT API, see the undefined;You can find a complete Rust code example for using outbound MQTT from an HTTP component in the undefined.{{ blockEnd }}{{ startTab \"TypeScript\"}}undefinedTo access an MQTT server, use the Mqtt.open function.let connection = Mqtt.open(address, username, password, keepAliveSecs);You can then call the publish method on the connection to send MQTT messages:let catPicture = new Uint8Array(await req.arraybuffer());\nconnection.publish(\"pets\", catPicture, QoS.AtleastOnce);For full details of the MQTT API, see the undefinedYou can find a complete Rust code example for using outbound MQTT from an HTTP component in the undefined.{{ blockEnd }}{{ startTab \"Python\"}}MQTT is not available in the current version of the Python SDK.{{ blockEnd }}{{ startTab \"TinyGo\"}}MQTT is not available in the current version of the Go SDK.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/mqtt-outbound#sending-mqtt-messages-from-applications"},{"project":"v2","title":"MQTT Messaging","subheading":"Granting Network Permissions to Components","content":"By default, Spin components are not allowed to make outgoing network requests, including MQTT. This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing. To grant a component permission to make network requests to a particular host, use the allowed_outbound_hosts field in the component manifest, specifying the host and allowed port:[component.uses-mqtt]\nallowed_outbound_hosts = [\"mqtt://messaging.example.com:1883\"]","keywords":"","subsectionKeywords":"","url":"/v2/mqtt-outbound#granting-network-permissions-to-components"},{"project":"v2","title":"MQTT Messaging","subheading":"Configuration-Based Permissions","content":"You can use undefined in the allowed_outbound_hosts field. However, this feature is not yet available on Fermyon Cloud.","keywords":"","subsectionKeywords":"","url":"/v2/mqtt-outbound#configuration-based-permissions"},{"project":"v2","title":"MQTT Messaging","subheading":"Known Issues","content":"The MQTT API is experimental and subject to change.  The following issues are known:undefined","keywords":"","subsectionKeywords":"","url":"/v2/mqtt-outbound#known-issues"},{"project":"v2","title":"Observing Applications","subheading":"","content":"undefinedundefined","subsectionKeywords":"","url":"/v2/observing-apps"},{"project":"v2","title":"Observing Applications","subheading":"Application Logs","content":"Spin handles application logs by default, storing output and error messages from file system-run applications in the .spin/logs directory alongside the manifest file's location. Users have the option to direct logs to a specific folder using the --log-dir flag of the spin up command. Additionally, if users wish to prevent stdout and stderr from being written to disk, they can specify an empty string for the --log-dir flag, i.e. spin up --log-dir \"\" - effectively disabling log storage. See the undefined section for more details.","keywords":"","subsectionKeywords":"","url":"/v2/observing-apps#application-logs"},{"project":"v2","title":"Observing Applications","subheading":"OpenTelemetry (OTel)","content":"Spin now has support for the undefined observability standard. You can learn more about observability undefined. When configured, Spin will emit telemetry about your Spin App in the form of OTel undefined: traces, metrics, and logs.","keywords":"","subsectionKeywords":"","url":"/v2/observing-apps#opentelemetry-otel"},{"project":"v2","title":"Observing Applications","subheading":"Using the OTel Plugin","content":"We have a plugin that makes it easy to use OpenTelemetry with Spin. If you would like to examine the source code, you can visit the undefined. Otherwise, follow these instructions:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/observing-apps#using-the-otel-plugin"},{"project":"v2","title":"Observing Applications","subheading":"Configuring your own observability stack","content":"Follow this portion of the guide if you want to use Spin and OTel, but want to have more control than what the OTel plugin offers.","keywords":"","subsectionKeywords":"","url":"/v2/observing-apps#configuring-your-own-observability-stack"},{"project":"v2","title":"Observing Applications","subheading":"Configure the Docker compose stack","content":"In order to view the telemetry data you need to run an OTel compliant undefined and the proper backends for each signal type. If you have Docker on your system you can easily start all the observability tools you need with the following commands:cd  ~\ngit clone git@github.com:fermyon/spin.git\ncd spin/hack/o11y-stack\ndocker compose up -dThis will start the following services:undefinedundefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/observing-apps#configure-the-docker-compose-stack"},{"project":"v2","title":"Observing Applications","subheading":"Configuring Spin","content":"To have Spin export OTel telemetry to the collector you need to set the following environment variable:OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318 spin upThis will enable all OTel signals. If you only want to enable specific signals you can set the following environment variables individually:undefinedundefinedundefinedFor example this would enable exporting of traces and metrics:OTEL_EXPORTER_OTLP_TRACES_ENDPOINT=http://localhost:4318/v1/traces OTEL_EXPORTER_OTLP_METRICS_ENDPOINT=http://localhost:4318/v1/metrics spin upStoring lots of trace data can get expensive. You may want to sample traces to reduce the amount of data stored. You can set the following environment variable to control the sampling rate:OTEL_TRACES_SAMPLER=traceidratio OTEL_TRACES_SAMPLER_ARG={desired_ratio} OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318 spin upUnder high request loads Spin will start dropping OTel data. If keeping all of this data is important to you there are undefined you can set:OTEL_BSP_MAX_CONCURRENT_EXPORTS=4 OTEL_BSP_MAX_QUEUE_SIZE=4096 OTEL_BSP_SCHEDULE_DELAY=1000 OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318 spin upSpin supports a wide array of OTel configuration options beyond what we've covered here. You can read more about them undefined and undefined.","keywords":"","subsectionKeywords":"","url":"/v2/observing-apps#configuring-spin"},{"project":"v2","title":"Observing Applications","subheading":"Traces","content":"After sending some requests to your Spin app, navigate to Jaeger undefined to view the traces.undefinedSpin supports both inbound and outbound undefined. This allows you to include Spin in your distributed traces that span all your services.","keywords":"","subsectionKeywords":"","url":"/v2/observing-apps#traces"},{"project":"v2","title":"Observing Applications","subheading":"Metrics","content":"Navigate to undefined to view the metrics in Grafana. Make sure to choose the Prometheus data source from the top left dropdown menu.","keywords":"","subsectionKeywords":"","url":"/v2/observing-apps#metrics"},{"project":"v2","title":"Observing Applications","subheading":"Logs","content":"Navigate to undefined to view the logs in Grafana. Make sure to choose the Loki data source from the top left dropdown menu.Spin will still emit application logs as described in the undefined section. However, it will also send the logs to the OTel collector.","keywords":"","subsectionKeywords":"","url":"/v2/observing-apps#logs"},{"project":"v2","title":"Building Spin components in other languages","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedWebAssembly is becoming undefined, and as language toolchains add support for the\nundefined,\nbuilding Spin components will also become supported.As a general rule:undefinedundefinedundefined","subsectionKeywords":"","url":"/v2/other-languages"},{"project":"v2","title":"Building Spin components in other languages","subheading":"C/C++","content":"C and C++ are both broadly supported in the WebAssembly ecosystem. WASI/Wagi support means that both can be used to write Spin apps.undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/other-languages#cc"},{"project":"v2","title":"Building Spin components in other languages","subheading":"C# and .NET Languages","content":".NET has experimental support for WASI, so many (if not all) .NET languages, including C# and F#, can be used to write Spin applications.undefined","keywords":"","subsectionKeywords":"","url":"/v2/other-languages#c-and-net-languages"},{"project":"v2","title":"Building Spin components in other languages","subheading":"Grain","content":"undefined, a new functional programming language, has WASI/Wagi support and can be used to write Spin apps.undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/other-languages#grain"},{"project":"v2","title":"Building Spin components in other languages","subheading":"Ruby","content":"Upstream undefined officially supports WebAssembly and WASI, and we here at Fermyon have successfully run Ruby apps in Spin.undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/other-languages#ruby"},{"project":"v2","title":"Building Spin components in other languages","subheading":"Zig","content":"Zig is a low-level systems language that has support for Wasm and WASI, and can be used to write Spin apps.undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/other-languages#zig"},{"project":"v2","title":"Creating Spin Plugins","subheading":"","content":"undefinedundefinedundefinedSpin plugins add new functionality or subcommands to Spin without modifying the\nSpin codebase. They make Spin easily extensible while keeping it lightweight.\nSpin plugins can add new triggers to Spin (such as the undefined),\nenable new language SDKs (such as\nundefined),\nand more.This document will cover what Spin plugins are, how to use a plugin, and how to\ncreate a plugin.","subsectionKeywords":"","url":"/v2/plugin-authoring"},{"project":"v2","title":"Creating Spin Plugins","subheading":"What Are Spin Plugins?","content":"A Spin plugin is an executable that is added to Spin's plugins directory\n($XDG_DATA_HOME/spin/plugins) upon a spin plugins install <plugin-name>. The\nplugin is then ready to be used. If the plugin is an extension to the Spin CLI,\nit can now be executed directly as a subcommand: spin <plugin-name>. If the\nplugin is a trigger plugin, it will be executed during spin up when an app\nusing that trigger is run.While for now plugins are assumed to be executables, in the future, support for\nplugging in WebAssembly modules may be desirable.","keywords":"","subsectionKeywords":"","url":"/v2/plugin-authoring#what-are-spin-plugins"},{"project":"v2","title":"Creating Spin Plugins","subheading":"How to Find and Use a Spin Plugin","content":"Spin maintains a centralized catalogue of available Spin plugins in the undefined. During plugin\ninstallation, if it does not already exist, Spin fetches the remote catalogue\nand creates a local snapshot. To ensure that the local snapshot is up to date,\nit is best to run spin plugins update before installing any plugins.To list available plugins, run spin plugins search. Now, decide which plugin to\ninstall. For example, the js2wasm plugin, which is needed in order to build\nJavaScript Spin applications, can be installed by running:$ spin plugins install js2wasmWith the plugin installed, you can now call spin js2wasm to run it. In this\ncase, for example, you might call it from your JavaScript application's npm\nbuild script. Learn more about building Spin components in JavaScript\nundefined.To upgrade installed plugins to newer versions, run spin plugin update to\nfetch the latest plugins to the local catalogue and spin plugin upgrade to perform the\nupgrade on the installed plugins.","keywords":"","subsectionKeywords":"","url":"/v2/plugin-authoring#how-to-find-and-use-a-spin-plugin"},{"project":"v2","title":"Creating Spin Plugins","subheading":"Authoring a Spin Plugin","content":"Spin plugins are implemented as a manifest that points to one or more .tar.gz archives which contain the plugin executables. So, to create a plugin you must:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/plugin-authoring#authoring-a-spin-plugin"},{"project":"v2","title":"Creating Spin Plugins","subheading":"Environment Variables Available to the Plugin Executable","content":"Your plugin may need to know information about the instance of Spin it's running in. For example, suppose your plugin wants to call spin build. The trouble is that you don't know if it's on the user's system PATH. Suppose, further, that your plugin would prefer to call spin build -c (to build only a specific component) if it's available but can fall back to spin build (to build everything) if it's not. The -c option only exists in Spin 1.4 and above, so this optimization requires that you know which version of Spin you're running in.To help with this, when a user uses Spin to run your plugin, Spin sets a number of environment variables on the plugin process. Your code can use these environment variables to find out things like the path to the Spin binary and which version of Spin it is. When your plugin runs, the parent Spin process will set these to the right values for the undefined instance of Spin. In the example above, when your plugin wants to run spin build, it can consult the SPIN_BIN_PATH environment variable for the program path, and be confident that the SPIN_VERSION environment variable matches the Spin binary at that location.The variables Spin sets are:| Name               | Meaning                                                                                                               | Example |\n|--------------------|-----------------------------------------------------------------------------------------------------------------------|---------|\n| SPIN_BIN_PATH      | The path to the Spin executable that the user is running. Use this if your plugin issues commands using the Spin CLI. | /Users/alice/.cargo/bin/spin |\n| SPIN_BRANCH        | The Git branch from which the Spin executable was built.                                                              | main |\n| SPIN_BUILD_DATE    | The date on which the Spin executable was built, in yyyy-mm-dd format.                                                | 2023-05-15 |\n| SPIN_COMMIT_DATE   | The date of the Git commit from which the Spin executable was built, in yyyy-mm-dd format.                            | 2023-05-15 |\n| SPIN_COMMIT_SHA    | The SHA of the Git commit from which the Spin executable was built.                                                   | 49fb11b |\n| SPIN_DEBUG         | Whether the Spin executable is a debug build.                                                                         | false |\n| SPIN_TARGET_TRIPLE | The processor and operating system for which the Spin executable was built, in Rust target-triple format.             | aarch64-apple-darwin |\n| SPIN_VERSION       | The version of Spin. This can be used to detect features availability, or to determine pre-stable command syntax.     | 1.3.0 |\n| SPIN_VERSION_MAJOR | The major version of Spin.                                                                                            | 1 |\n| SPIN_VERSION_MINOR | The minor version of Spin.                                                                                            | 3 |\n| SPIN_VERSION_PRE   | The prerelease version string, or empty if this is a released version of Spin.                                        | pre0 |undefined","keywords":"","subsectionKeywords":"","url":"/v2/plugin-authoring#environment-variables-available-to-the-plugin-executable"},{"project":"v2","title":"Creating Spin Plugins","subheading":"Packaging a Plugin","content":"After creating your plugin executable, package it along with its license as a\ntar.gz archive. Note that the name field in the plugin manifest must match\nboth the binary and license name. See the undefined\nfor more details on naming conventions.Refer to the aptly named undefined for an\nexample of how to build a plugin.","keywords":"","subsectionKeywords":"","url":"/v2/plugin-authoring#packaging-a-plugin"},{"project":"v2","title":"Creating Spin Plugins","subheading":"Creating a Spin Plugin Manifest","content":"A Spin plugin manifest is a JSON file that conforms to the undefined.\nA manifest defines a plugin’s name, version, license, homepage (i.e. GitHub\nrepo), compatible Spin version, and gives a short description of the plugin. It\nalso lists the URLs of the tar archives of the plugin for various operating\nsystems and platforms. The URL can point to the local path to the file by using\nthe file scheme file://, for example, file:///tmp/my-plugin.tar.gz.To ensure your plugin manifest is valid, follow the steps in the undefined.","keywords":"","subsectionKeywords":"","url":"/v2/plugin-authoring#creating-a-spin-plugin-manifest"},{"project":"v2","title":"Creating Spin Plugins","subheading":"Installing a Local Plugin","content":"By default, Spin will look in the plugins catalogue for a plugin. However, when\ndeveloping and testing a plugin, it is unlikely to be in the the catalogue. For\nboth installs and upgrades, the --file or --url flags can be used to point\nto specific local or remote plugin manifests. For example, a local manifest\ncalled practice.json can be installed and run as follows:$ spin plugin install --file practice.json\n$ spin practice","keywords":"","subsectionKeywords":"","url":"/v2/plugin-authoring#installing-a-local-plugin"},{"project":"v2","title":"Creating Spin Plugins","subheading":"Contributing a Plugin","content":"If you think the community would benefit from your newly created plugin, create\na PR to add it to the undefined!","keywords":"","subsectionKeywords":"","url":"/v2/plugin-authoring#contributing-a-plugin"},{"project":"v2","title":"Building Spin Components in Python","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedWith <a href=\"https://www.python.org/\" target=\"_blank\">Python</a> being a very popular language, Spin provides support for building components with Python; undefined. The development of the Python SDK is continually being worked on to improve user experience and also add new features.undefinedundefinedundefined","subsectionKeywords":"","url":"/v2/python-components"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Prerequisite","content":"Ensure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.","keywords":"","subsectionKeywords":"","url":"/v2/python-components#prerequisite"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Componentize-Py","content":"The Python SDK is built using undefined. It is a undefined project that allows converting a Python application to a WebAssembly component. It can be installed using the following command:$ pip3 install componentize-py==0.13.3undefined","keywords":"","subsectionKeywords":"","url":"/v2/python-components#componentize-py"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Spin's Python HTTP Request Handler Template","content":"Spin's Python HTTP Request Handler Template can be installed from undefined using the following command:$ spin templates install --git https://github.com/spinframework/spin-python-sdk --updateThe above command will install the http-py template and produce an output similar to the following:Copying remote template source\nInstalling template http-py...\nInstalled 1 template(s)\n\n+---------------------------------------------+\n| Name      Description                       |\n+=============================================+\n| http-py   HTTP request handler using Python |\n+---------------------------------------------+undefined For more information about managing spin templates, see the undefined in the Spin Command Line Interface (CLI) documentation.","keywords":"","subsectionKeywords":"","url":"/v2/python-components#spins-python-http-request-handler-template"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Creating a New Python Component","content":"A new Python component can be created using the following command:$ spin new -t http-py hello-world --accept-defaults","keywords":"","subsectionKeywords":"","url":"/v2/python-components#creating-a-new-python-component"},{"project":"v2","title":"Building Spin Components in Python","subheading":"System Housekeeping (Use a Virtual Environment)","content":"Once the component is created, we can change into the hello-world directory, create and activate a virtual environment and then install the component's requirements:$ cd hello-worldCreate a virtual environment directory (we are still inside the Spin app directory):# python<version> -m venv <virtual-environment-name>\n$ python3 -m venv venv-dirActivate the virtual environment (this command depends on which operating system you are using):# macOS command to activate\n$ source venv-dir/bin/activateIf you are using Windows, use the following commands:C:\\Work> python3 -m venv venv\nC:\\Work> venv\\Scripts\\activateThe (venv-dir) will prefix your terminal prompt now:(venv-dir) user@123-456-7-8 hello-world %","keywords":"","subsectionKeywords":"","url":"/v2/python-components#system-housekeeping-use-a-virtual-environment"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Requirements","content":"The requirements.txt, by default, contains the references to the spin-sdk and componentize-py packages. These can be installed in your virtual environment using the following command:$ pip3 install -r requirements.txt \nCollecting spin-sdk==3.1.0 (from -r requirements.txt (line 1))\n  Using cached spin_sdk-3.1.0-py3-none-any.whl.metadata (16 kB)\nCollecting componentize-py==0.13.3 (from -r requirements.txt (line 2))\n  Using cached componentize_py-0.13.3-cp37-abi3-macosx_10_12_x86_64.whl.metadata (3.4 kB)\nUsing cached spin_sdk-3.1.0-py3-none-any.whl (94 kB)\nUsing cached componentize_py-0.13.3-cp37-abi3-macosx_10_12_x86_64.whl (38.8 MB)\nInstalling collected packages: spin-sdk, componentize-py\nSuccessfully installed componentize-py-0.13.3 spin-sdk-3.1.0","keywords":"","subsectionKeywords":"","url":"/v2/python-components#requirements"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Structure of a Python Component","content":"The hello-world directory structure created by the Spin http-py template is shown below:├── app.py\n├── spin.toml\n└── requirements.txt The spin.toml file will look similar to the following:spin_manifest_version = 2\n\n[application]\nname = \"hello-world\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nsource = \"app.wasm\"\n[component.hello-world.build]\ncommand = \"componentize-py -w spin-http componentize app -o app.wasm\"","keywords":"","subsectionKeywords":"","url":"/v2/python-components#structure-of-a-python-component"},{"project":"v2","title":"Building Spin Components in Python","subheading":"A Simple HTTP Components Example","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request and must return an HTTP response at the end of their execution. Components can be built in any language that compiles to WASI. If you would like additional information about building HTTP applications you may find undefined useful.Building a Spin HTTP component using the Python SDK means defining a top-level class named IncomingHandler which inherits from undefined, overriding the handle_request method. Here is an example of the default Python code which the previous spin new created for us; a simple example of a request/response:from spin_sdk.http import IncomingHandler, Request, Response\n\nclass IncomingHandler(IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(\"Hello from Python!\", \"utf-8\")\n        )The important things to note in the implementation above:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/python-components#a-simple-http-components-example"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Building and Running the Application","content":"All you need to do is run the spin build command from within the project's directory; as shown below:$ spin buildEssentially, we have just created a new Spin compatible module which can now be run using the spin up command, as shown below:$ spin upWith Spin running our application in our terminal, we can now go ahead (grab a new terminal) and call the Spin application via an HTTP request:$ curl -i localhost:3000\n\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 25\n\nHello from Python!","keywords":"","subsectionKeywords":"","url":"/v2/python-components#building-and-running-the-application"},{"project":"v2","title":"Building Spin Components in Python","subheading":"A HTTP Request Parsing Example","content":"The following snippet shows how you can access parts of the request e.g. the request.method and the request.body:import json\nfrom spin_sdk import http\nfrom spin_sdk.http import Request, Response\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        # Access the request.method\n        if request.method == 'POST':\n            # Read the request.body as a string\n            json_str = request.body.decode('utf-8')\n            # Create a JSON object representation of the request.body\n            json_object = json.loads(json_str)\n            # Access a value in the JSON object\n            name = json_object['name']\n            # Print the variable to console logs\n            print(name)\n            # Print the type of the variable to console logs\n            print(type(name))\n            # Print the available methods of the variable to the console logs\n            print(dir(name))\n        return Response(200,\n                    {\"content-type\": \"text/plain\"},\n                    bytes(f\"Practicing reading the request object\", \"utf-8\"))","keywords":"","subsectionKeywords":"","url":"/v2/python-components#a-http-request-parsing-example"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Building and Running the Application","content":"All you need to do is run the spin build --up command from within the project's directory; as shown below:$ spin build --upWith Spin running our application in our terminal, we can now go ahead (grab a new terminal) and call the Spin application via an HTTP request:$ curl --header \"Content-Type: application/json\" \\\n  --request POST \\\n  --data '{\"name\":\"Python\"}' \\\n  http://localhost:3000/\n\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 37\ndate: Mon, 15 Apr 2024 04:26:00 GMT\n\nPracticing reading the request objectThe response \"Practicing reading the request object\" is returned as expected. In addition, if we check the terminal where Spin is running, we will see that the console logs printed the following:The value of the variable called name:PythonThe name variable type (in this case a Python string):<class 'str'>The methods available to that type:['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__',\n... abbreviated ...\n'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']undefined","keywords":"","subsectionKeywords":"","url":"/v2/python-components#building-and-running-the-application"},{"project":"v2","title":"Building Spin Components in Python","subheading":"An Outbound HTTP Example","content":"This next example will create an outbound request, to obtain a random fact about animals, which will be returned to the calling code. If you would like to try this out, you can go ahead and update your existing app.py file from the previous step; using the following source code:from spin_sdk import http   \nfrom spin_sdk.http import Request, Response, send\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        resp = send(Request(\"GET\", \"https://random-data-api.fermyon.app/animals/json\", {}, None))\n\n        return  Response(200,\n                    {\"content-type\": \"text/plain\"},\n                    bytes(f\"Here is an animal fact: {str(resp.body, 'utf-8')}\", \"utf-8\"))\n","keywords":"","subsectionKeywords":"","url":"/v2/python-components#an-outbound-http-example"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Configuring Outbound Requests","content":"The Spin framework protects your code from making outbound requests to just any URL. For example, if we try to run the above code undefined, we will correctly get the following error AssertionError: HttpError::DestinationNotAllowed. To allow our component to request the random-data-api.fermyon.app domain, all we have to do is add that domain to the specific component of the application that is making the request. Here is an example of an updated spin.toml file where we have added allowed_outbound_hosts:spin_manifest_version = 2\n\n[application]\nname = \"hello-world\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nsource = \"app.wasm\"\nallowed_outbound_hosts = [\"https://random-data-api.fermyon.app\"]\n[component.hello-world.build]\ncommand = \"componentize-py -w spin-http componentize app -o app.wasm\"\nwatch = [\"*.py\", \"requirements.txt\"]","keywords":"","subsectionKeywords":"","url":"/v2/python-components#configuring-outbound-requests"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Building and Running the Application","content":"Run the spin build --up command from within the project's directory; as shown below:$ spin build --upWith Spin running our application in our terminal, we can now go ahead (grab a new terminal) and call the Spin application via an HTTP request:$ curl -i localhost:3000\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 99\ndate: Mon, 15 Apr 2024 04:52:45 GMT\n\nHere is an animal fact: {\"timestamp\":1713156765221,\"fact\":\"Bats are the only mammals that can fly\"}","keywords":"","subsectionKeywords":"","url":"/v2/python-components#building-and-running-the-application"},{"project":"v2","title":"Building Spin Components in Python","subheading":"An Outbound Redis Example","content":"In this final example, we talk to an existing Redis instance. You can find the official undefined. We also gave a quick run-through on setting up Redis with Spin in our previous article called undefined, so please take a look at that blog if you need a hand.","keywords":"","subsectionKeywords":"","url":"/v2/python-components#an-outbound-redis-example"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Configuring Outbound Redis","content":"After installing Redis on localhost, we add two entries to the spin.toml file:undefinedundefinedspin_manifest_version = 2\n\n[application]\nname = \"hello-world\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nid = \"hello-world\"\nsource = \"app.wasm\"\nvariables = { redis_address = \"redis://127.0.0.1:6379\" }\nallowed_outbound_hosts = [\"redis://127.0.0.1:6379\"]\n[component.hello-world.build]\ncommand = \"spin py2wasm app -o app.wasm\"If you are still following along, please go ahead and update your app.py file one more time, as follows:from spin_sdk import http, redis, variables\nfrom spin_sdk.http import Request, Response\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        with redis.open(variables.get(\"redis_address\")) as db:\n            db.set(\"foo\", b\"bar\")\n            value = db.get(\"foo\")\n            db.incr(\"testIncr\")\n            db.sadd(\"testSets\", [\"hello\", \"world\"])\n            content = db.smembers(\"testSets\")\n            db.srem(\"testSets\", [\"hello\"])\n            assert value == b\"bar\", f\"expected \\\"bar\\\", got \\\"{str(value, 'utf-8')}\\\"\"\n\n        return Response(200,\n                    {\"content-type\": \"text/plain\"},\n                    bytes(f\"Executed outbound Redis commands: {request.uri}\", \"utf-8\"))","keywords":"","subsectionKeywords":"","url":"/v2/python-components#configuring-outbound-redis"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Building and Running the Application","content":"Run the spin build --up command from within the project's directory; as shown below:$ spin build --upIn a new terminal, make the request via the curl command, as shown below:$ curl -i localhost:3000\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 35\ndate: Mon, 15 Apr 2024 05:53:17 GMT\n\nExecuted outbound Redis commands: /If we go into our Redis CLI on localhost we can see that the value foo which was set in the Python source code ( redis_set(redis_address, \"foo\", b\"bar\") ) is now correctly set to the value of bar:redis-cli\n127.0.0.1:6379> get foo\n\"bar\"","keywords":"","subsectionKeywords":"","url":"/v2/python-components#building-and-running-the-application"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Storing Data in the Spin Key-Value Store","content":"Spin has a key-value store built in. For information about using it from Python, see undefined.","keywords":"","subsectionKeywords":"","url":"/v2/python-components#storing-data-in-the-spin-key-value-store"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Storing Data in SQLite","content":"For more information about using SQLite from Python, see undefined.","keywords":"","subsectionKeywords":"","url":"/v2/python-components#storing-data-in-sqlite"},{"project":"v2","title":"Building Spin Components in Python","subheading":"AI Inferencing From Python Components","content":"For more information about using Serverless AI from Python, see the undefined API guide.","keywords":"","subsectionKeywords":"","url":"/v2/python-components#ai-inferencing-from-python-components"},{"project":"v2","title":"Building Spin Components in Python","subheading":"Troubleshooting","content":"If you bump into issues when installing the requirements.txt. For example:error: externally-managed-environment\n× This environment is externally managedPlease note, this error is specific to Homebrew-installed Python installations and occurs because installing a undefined Python package requires you to either:undefinedundefinedWe recommend installing a virtual environment using venv, as shown in the undefined above.For all Python examples, please ensure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.","keywords":"","subsectionKeywords":"","url":"/v2/python-components#troubleshooting"},{"project":"v2","title":"Taking Spin for a spin","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedLet's get Spin and take it from nothing to a \"hello world\" application!","keywords":"quickstart","subsectionKeywords":"","url":"/v2/quickstart"},{"project":"v2","title":"Taking Spin for a spin","subheading":"Install Spin","content":"{{ tabs \"os\" }}{{ startTab \"Linux\"}}Download the spin binary along with a starter set of templates and plugins using the install.sh script hosted on this site:Then move the spin binary somewhere in your path, so you can run it from anywhere. For example:$ sudo mv ./spin /usr/local/bin/spin{{ blockEnd }}{{ startTab \"macOS\"}}Download the spin binary along with a starter set of templates and plugins using the install.sh script hosted on this site:Then move the spin binary somewhere in your path, so you can run it from anywhere. For example:$ sudo mv ./spin /usr/local/bin/spin{{ blockEnd }}{{ startTab \"Windows\"}}Download <a href=\"https://github.com/spinframework/spin/releases/latest\" class=\"spin-install\" id=\"spin-install-windows\">the Windows binary release of Spin</a> from GitHub.Unzip the binary release and place the spin.exe in your system path.{{ blockEnd }}\n{{ blockEnd }}undefined","keywords":"","subsectionKeywords":"","url":"/v2/quickstart#install-spin"},{"project":"v2","title":"Taking Spin for a spin","subheading":"Install the Prerequisites","content":"","keywords":"","subsectionKeywords":"","url":"/v2/quickstart#install-the-prerequisites"},{"project":"v2","title":"Taking Spin for a spin","subheading":"Install a Template","content":"undefinedThe quickest and most convenient way to start a new application is to install and use a Spin template for your preferred language.{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}$ spin templates install --git https://github.com/spinframework/spin --update\nCopying remote template source\nInstalling template redis-rust...\nInstalling template http-rust...\n... other templates omitted ...\n+------------------------------------------------------------------------+\n| Name                Description                                        |\n+========================================================================+\n| ... other templates omitted ...                                        |\n| http-rust           HTTP request handler using Rust                    |\n| redis-rust          Redis message handler using Rust                   |\n| ... other templates omitted ...                                        |\n+------------------------------------------------------------------------+Note: The Rust templates are in a repo that contains several other languages; they will all be installed together.{{ blockEnd }}{{ startTab \"TypeScript\" }}$ spin templates install --git https://github.com/spinframework/spin-js-sdk --update --branch sdk-v2\nCopying remote template source\nInstalling template http-js...\nInstalling template http-ts...\n+------------------------------------------------------------------------+\n| Name                Description                                        |\n+========================================================================+\n| http-js             HTTP request handler using Javascript              |\n| http-ts             HTTP request handler using Typescript              |\n+------------------------------------------------------------------------+{{ blockEnd }}{{ startTab \"Python\" }}$ spin templates install --git https://github.com/spinframework/spin-python-sdk --update\nCopying remote template source\nInstalling template http-py...\n+---------------------------------------------+\n| Name      Description                       |\n+=============================================+\n| http-py   HTTP request handler using Python |\n+---------------------------------------------+{{ blockEnd }}{{ startTab \"TinyGo\" }}$ spin templates install --git https://github.com/spinframework/spin --update\nCopying remote template source\nInstalling template redis-go...\nInstalling template http-go...\n+------------------------------------------------------------------------+\n| Name                Description                                        |\n+========================================================================+\n| ... other templates omitted ...                                        |\n| http-go             HTTP request handler using (Tiny)Go                |\n| redis-go            Redis message handler using (Tiny)Go               |\n| ... other templates omitted ...                                        |\n+------------------------------------------------------------------------+Note: The Go templates are in a repo that contains several other languages; they will all be installed together.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/quickstart#install-a-template"},{"project":"v2","title":"Taking Spin for a spin","subheading":"Install the Tools","content":"Some languages require additional tool support for Wasm:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}You'll need the wasm32-wasi target for Rust:$ rustup target add wasm32-wasiundefined{{ blockEnd }}{{ startTab \"TypeScript\" }}undefinedYou'll need the Spin js2wasm plugin:$ spin plugins update\n$ spin plugins install js2wasm --yesundefined{{ blockEnd }}{{ startTab \"Python\" }}Ensure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.You'll install all the required Python tools as part of building the application.  We'll cover that in the Build Your Application section below.  For now, there's nothing to do here!undefined{{ blockEnd }}{{ startTab \"TinyGo\" }}You'll need the TinyGo compiler, as the standard Go compiler does not yet support WASI exports.  See the undefined.undefined{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/quickstart#install-the-tools"},{"project":"v2","title":"Taking Spin for a spin","subheading":"Create Your First Application","content":"{{suh_cards}}\n{{card_element \"sample\" \"Checklist Sample App\" \"A checklist app that persists data in a key value store\" \"https://developer.fermyon.com/hub/preview/sample_checklist\" \"Typescript,Http,Kv\" true }}\n{{card_element \"sample\" \"AI-assisted News Summarizer\" \"Read an RSS newsfeed and have AI summarize it for you\" \"https://developer.fermyon.com/hub/preview/sample_newsreader_ai\" \"Typescript,Javascript,Ai\" true }}\n{{card_element \"template\" \"Zola SSG Template\" \"A template for using Zola framework to create a static webpage\" \"https://developer.fermyon.com/hub/preview/template_zola_ssg\" \"rust\" true }}\n{{blockEnd}}Now you are ready to create your first Spin application:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}Use the spin new command and the http-rust template to scaffold a new Spin application:$ spin new\nPick a template to start your application with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-csharp (HTTP request handler using C# (EXPERIMENTAL))\n  http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n> http-rust (HTTP request handler using Rust)\n  http-swift (HTTP request handler using SwiftWasm)\n  http-zig (HTTP request handler using Zig)\n  redis-go (Redis message handler using (Tiny)Go)\n  redis-rust (Redis message handler using Rust)\n\nEnter a name for your new application: hello_rust\nProject description: My first Rust Spin application\nHTTP path: /...This command created a directory with the necessary files needed to build and run a Rust Spin application.  Change to that directory, and look at the files.  It looks very much like a normal Rust library project:$ cd hello_rust\n$ tree\n.\n├── .gitignore\n├── Cargo.toml\n├── spin.toml\n└── src\n    └── lib.rsThe additional spin.toml file is the manifest file, which tells Spin what events should trigger what components.  In this case our trigger is HTTP, for a Web application, and we have only one component, at the route /....  This is a wildcard that matches any route:spin_manifest_version = 2\n\n[application]\nname = \"hello_rust\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first Rust Spin application\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-rust\"\n\n[component.hello-rust]\nsource = \"target/wasm32-wasi/release/hello_rust.wasm\"\nallowed_outbound_hosts = []\n[component.hello-rust.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]This represents a simple Spin HTTP application (triggered by an HTTP request).  It has:undefinedundefinedundefinedNow let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in Rust — a regular Rust function that\ntakes an HTTP request as a parameter and returns an HTTP response, and it is\nannotated with the http_component macro which identifies it as the entry point\nfor HTTP requests:use spin_sdk::http::{IntoResponse, Request, Response};\nuse spin_sdk::http_component;\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn handle_hello_rust(req: Request) -> anyhow::Result<impl IntoResponse> {\n    println!(\"Handling request to {:?}\", req.header(\"spin-full-url\"));\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, Fermyon\")\n        .build())\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}Use the spin new command and the http-ts template to scaffold a new Spin application.  (If you prefer JavaScript to TypeScript, the http-js template is very similar.):$ spin new\nPick a template to start your application with:\n  http-js (HTTP request handler using Javascript)\n> http-ts (HTTP request handler using Typescript)\nEnter a name for your new application: hello_typescript\nProject description: My first TypeScript Spin application\nHTTP path: /...This command created a directory with the necessary files needed to build and run a TypeScript Spin application.  Change to that directory, and look at the files.  It looks similar to a lot of NPM projects:$ cd hello_typescript\n$ tree\n.\n├── package.json\n├── README.md\n├── spin.toml\n├── src\n│   └── index.ts\n├── tsconfig.json\n└── webpack.config.jsThe additional spin.toml file is the manifest file, which tells Spin what events should trigger what components.  In this case our trigger is HTTP, for a Web application, and we have only one component, at the route /....  This is a wildcard that matches any route:spin_manifest_version = 2\n\n[application]\nname = \"hello_typescript\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first TypeScript Spin application\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-typescript\"\n\n[component.hello-typescript]\nsource = \"target/hello-typescript.wasm\"\nexclude_files = [\"**/node_modules\"]\n[component.hello-typescript.build]\ncommand = \"npm run build\"This represents a simple Spin HTTP application (triggered by an HTTP request).  It has:undefinedundefinedundefinedNow let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in TypeScript — a regular function named handleRequest that\ntakes an HTTP request as a parameter and returns an HTTP response.  (The\nJavaScript version looks slightly different, but is still a function with\nthe same signature.)  The Spin js2wasm plugin looks for the handleRequest function\nby name when building your application into a Wasm module:import { HandleRequest, HttpRequest, HttpResponse } from \"@fermyon/spin-sdk\"\n\nexport const handleRequest: HandleRequest = async function (request: HttpRequest): Promise<HttpResponse> {\n  return {\n    status: 200,\n    headers: { \"content-type\": \"text/plain\" },\n    body: \"Hello from TS-SDK\"\n  }\n}{{ blockEnd }}{{ startTab \"Python\"}}You can install the Spin template for Python HTTP handlers from the undefined using the following command:$ spin templates install --git https://github.com/spinframework/spin-python-sdk --updateThe above command will install the http-py template and produce an output similar to the following:Copying remote template source\nInstalling template http-py...\nInstalled 1 template(s)\n\n+---------------------------------------------+\n| Name      Description                       |\n+=============================================+\n| http-py   HTTP request handler using Python |\n+---------------------------------------------+undefined For more information about managing spin templates, see the undefined in the Spin Command Line Interface (CLI) documentation.This command created a directory with the necessary files needed to build and run a Python Spin application.  Change to that directory, and look at the files.  It contains a minimal Python application:$ spin new -t http-py hello-python --accept-defaultsOnce the component is created, we can change into the hello-python directory, create and activate a virtual environment and then install the component's requirements:$ cd hello-pythonCreate a virtual environment directory (we are still inside the Spin app directory):# python<version> -m venv <virtual-environment-name>\n$ python3 -m venv venv-dirActivate the virtual environment (this command depends on which operating system you are using):# macOS & Linux command to activate\n$ source venv-dir/bin/activateIf you are using Windows, use the following commands:C:\\Work> python3 -m venv venv\nC:\\Work> venv\\Scripts\\activateThe (venv-dir) will prefix your terminal prompt now:(venv-dir) user@123-456-7-8 hello-python %The requirements.txt, by default, contains the references to the spin-sdk and componentize-py packages. These can be installed in your virtual environment using the following command:$ pip3 install -r requirements.txt \nCollecting spin-sdk==3.1.0 (from -r requirements.txt (line 1))\n  Using cached spin_sdk-3.1.0-py3-none-any.whl.metadata (16 kB)\nCollecting componentize-py==0.13.3 (from -r requirements.txt (line 2))\n  Using cached componentize_py-0.13.3-cp37-abi3-macosx_10_12_x86_64.whl.metadata (3.4 kB)\nUsing cached spin_sdk-3.1.0-py3-none-any.whl (94 kB)\nUsing cached componentize_py-0.13.3-cp37-abi3-macosx_10_12_x86_64.whl (38.8 MB)\nInstalling collected packages: spin-sdk, componentize-py\nSuccessfully installed componentize-py-0.13.3 spin-sdk-3.1.0","keywords":"","subsectionKeywords":"","url":"/v2/quickstart#create-your-first-application"},{"project":"v2","title":"Taking Spin for a spin","subheading":"Structure of a Python Component","content":"The hello-python directory structure created by the Spin http-py template is shown below:├── app.py\n├── spin.toml\n└── requirements.txt The additional spin.toml file is the manifest file, which tells Spin what events should trigger what components.  In this case our trigger is HTTP, for a Web application, and we have only one component, at the route /....  This is a wildcard that matches any route.spin_manifest_version = 2\n\n[application]\nname = \"hello-python\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first Python Spin application\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-python\"\n\n[component.hello-python]\nsource = \"app.wasm\"\n[component.hello-python.build]\ncommand = \"componentize-py -w spin-http componentize app -o app.wasm\"This represents a simple Spin HTTP application (triggered by an HTTP request).  It has:undefinedundefinedundefinedNow let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in Python — a regular function named handle_request that\ntakes an HTTP request as a parameter and returns an HTTP response.from spin_sdk.http import IncomingHandler, Request, Response\n\nclass IncomingHandler(IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(\"Hello from the Python SDK!\", \"utf-8\")\n        ){{ blockEnd }}{{ startTab \"TinyGo\"}}Use the spin new command and the http-go template to scaffold a new Spin application.$ spin new\nPick a template to start your application with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-empty (HTTP application with no components)\n> http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n  http-php (HTTP request handler using PHP)\n  http-rust (HTTP request handler using Rust)\nEnter a name for your new application: hello_go\nDescription: My first Go Spin application\nHTTP base: /\nHTTP path: /...This command created a directory with the necessary files needed to build and run a Go Spin application using the TinyGo compiler.  Change to that directory, and look at the files.  It looks very much like a normal Go project:$ cd hello_go\n$ tree\n.\n├── go.mod\n├── go.sum\n├── main.go\n└── spin.tomlThe additional spin.toml file is the manifest file, which tells Spin what events should trigger what components.  In this case our trigger is HTTP, for a Web application, and we have only one component, at the route /....  This is a wildcard that matches any route.spin_manifest_version = 2\n\n[application]\nname = \"hello_go\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first Go Spin application\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-go\"\n\n[component.hello-go]\nsource = \"main.wasm\"\nallowed_outbound_hosts = []\n[component.hello-go.build]\ncommand = \"tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"This represents a simple Spin HTTP application (triggered by an HTTP request).  It has:undefinedundefinedundefinedNow let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in Go. Notice where the work is done.  The\nmain function is empty (and Spin never calls it).  Instead, the init function\nsets up a callback, and passes that callback to spinhttp.Handle to register it as\nthe handler for HTTP requests.  You can learn more about this structure\nin the undefined.package main\n\nimport (\n        \"fmt\"\n        \"net/http\"\n\n        spinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n)\n\nfunc init() {\n        spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n                w.Header().Set(\"Content-Type\", \"text/plain\")\n                fmt.Fprintln(w, \"Hello Fermyon!\")\n        })\n}\n\nfunc main() {}{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/quickstart#structure-of-a-python-component"},{"project":"v2","title":"Taking Spin for a spin","subheading":"Build Your Application","content":"The Spin template creates starter source code.  Now you need to turn that into a Wasm module.  The template puts build instructions for each component into the manifest.  Use the spin build command to run them:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}$ spin build\nExecuting the build command for component hello-rust: cargo build --target wasm32-wasi --release\n    Updating crates.io index\n    Updating git repository `https://github.com/spinframework/spin`\n    Updating git repository `https://github.com/bytecodealliance/wit-bindgen`\n   Compiling anyhow v1.0.69\n   Compiling version_check v0.9.4\n   # ...\n   Compiling spin-sdk v0.10.0 \n   Compiling hello-rust v0.1.0 (/home/ivan/testing/start/hello_rust)\n    Finished release [optimized] target(s) in 11.94s\nFinished building all Spin componentsIf the build fails, check:undefinedundefinedundefinedIf you would like to know what build command Spin runs for a component, you can find it in the manifest, in the component.(id).build section:[component.hello-rust.build]\ncommand = \"cargo build --target wasm32-wasi --release\"You can always run this command manually; spin build is a shortcut to save you having to remember it.{{ blockEnd }}{{ startTab \"TypeScript\"}}As normal for NPM projects, before you build for the first time, you must run npm install:$ npm install\n\nadded 141 packages, and audited 142 packages in 13s\n\n20 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilitiesThen run spin build:$ spin build\nExecuting the build command for component hello-typescript: npm run build\n\n> hello-typescript@1.0.0 build\n> npx webpack --mode=production && mkdir -p target && spin js2wasm -o target/spin-http-js.wasm dist/spin.js\n\nasset spin.js 4.57 KiB [emitted] (name: main)\nruntime modules 670 bytes 3 modules\n./src/index.ts 2.85 KiB [built] [code generated]\nwebpack 5.75.0 compiled successfully in 1026 ms\n\nStarting to build Spin compatible module\nPreinitiating using Wizer\nOptimizing wasm binary using wasm-opt\nSpin compatible module built successfully\nFinished building all Spin componentsIf the build fails, check:undefinedundefinedundefinedIf you would like to know what build command Spin runs for a component, you can find it in the manifest, in the component.(id).build section:[component.hello-typescript.build]\ncommand = \"npm run build\"You can always run this command manually; spin build is a shortcut.{{ blockEnd }}{{ startTab \"Python\"}}As a standard practice for Python, create and activate a virtual env:If you are on a Mac/linux based operating system use the following commands:$ python3 -m venv venv\n$ source venv/bin/activateIf you are using Windows, use the following commands:C:\\Work> python3 -m venv venv\nC:\\Work> venv\\Scripts\\activateInstall componentize-py and spin-sdk packages$ pip3 install -r requirements.txtThen run:$ spin build\nExecuting the build command for component hello-python: \"componentize-py -w spin-http componentize app -o app.wasm\"\nFinished building all Spin componentsIf the build fails, check:undefinedundefinedundefinedIf you would like to know what build command Spin runs for a component, you can find it in the manifest, in the component.(id).build section:[component.hello-python.build]\ncommand = \"componentize-py -w spin-http componentize app -o app.wasm\"You can always run this command manually; spin build is a shortcut.{{ blockEnd }}{{ startTab \"TinyGo\"}}$ spin build\nExecuting the build command for component hello-go: tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\ngo: downloading github.com/fermyon/spin/sdk/go v0.10.0\nFinished building all Spin componentsIf the build fails, check:undefinedundefinedundefinedundefinedIf you would like to know what build command Spin runs for a component, you can find it in the manifest, in the component.(id).build section:[component.hello-go.build]\ncommand = \"tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"You can always run this command manually; spin build is a shortcut to save you having to remember it.{{ blockEnd }}{{ blockEnd }}undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/quickstart#build-your-application"},{"project":"v2","title":"Taking Spin for a spin","subheading":"Run Your Application","content":"Now that you have created the application and built the component, you can undefined\nthe application (pun intended):$ spin up\nServing http://127.0.0.1:3000\nAvailable Routes:\n  hello-typescript: http://127.0.0.1:3000 (wildcard)If you would like to see what Spin is doing under the hood, set the RUST_LOG environment variable for detailed logs, before running spin up:$ export RUST_LOG=spin=traceundefinedSpin instantiates all components from the application manifest, and\ncreates the router configuration for the HTTP trigger according to the routes in the manifest. The\ncomponent can now be invoked by making requests to http://localhost:3000/\n(or any path under that, since it's a wildcard):$ curl -i localhost:3000\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 14\ndate = \"2023-11-04T00:00:01Z\"\n\nHello, FermyonundefinedCongratulations! You just created, built and ran your first Spin application!","keywords":"","subsectionKeywords":"","url":"/v2/quickstart#run-your-application"},{"project":"v2","title":"Taking Spin for a spin","subheading":"Deploy Your Application to Fermyon Cloud","content":"spin up runs your application locally. Now it's time to put it on the Web via undefined.undefined","keywords":"","subsectionKeywords":"","url":"/v2/quickstart#deploy-your-application-to-fermyon-cloud"},{"project":"v2","title":"Taking Spin for a spin","subheading":"Log in to Fermyon Cloud","content":"Before deploying your application to Fermyon Cloud, you have to log in, using the spin login command. This generates a code to authorize your current device against the Fermyon Cloud, and prints a link that will take you to where you enter the code. (You will need to be logged into your GitHub account; if you're not, it will prompt you to log in.) Follow the instructions in the prompt to complete the authorization process.spin login prints a confirmation message when authorization completes:$ spin login\n\nCopy your one-time code:\n\nXXXXXXXX\n\n...and open the authorization page in your browser:\n\nhttps://cloud.fermyon.com/device-authorization\n\nWaiting for device authorization...\nDevice authorized!","keywords":"","subsectionKeywords":"","url":"/v2/quickstart#log-in-to-fermyon-cloud"},{"project":"v2","title":"Taking Spin for a spin","subheading":"Deploy the Application","content":"Now let's deploy the application:$ spin deployThe deployment process prints progress information as your application uploads and is rolled out to the cloud:Uploading hello_typescript version 0.1.0+XXXXXXXX to Fermyon Cloud...\nDeploying...\nWaiting for application to become ready... ready\nAvailable Routes:\n  hello-typescript: https://hello-typescript-XXXXXXXX.fermyon.app (wildcard)You can Ctrl+Click on the link in the terminal to visit the web application you just deployed.undefinedCongratulations again - you've now deployed your first Spin application to undefined!","keywords":"","subsectionKeywords":"","url":"/v2/quickstart#deploy-the-application"},{"project":"v2","title":"Taking Spin for a spin","subheading":"Next Steps","content":"undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/quickstart#next-steps"},{"project":"v2","title":"Relational Database Storage","subheading":"","content":"undefinedundefinedSpin provides two interfaces for relational (SQL) databases:undefinedundefinedThis page covers the \"bring your own database\" scenario.  See undefined for the built-in service.{{ details \"Why do I need a Spin interface? Why can't I just use my language's database libraries?\" \"The current version of the WebAssembly System Interface (WASI) doesn't provide a sockets interface, so database libraries that depend on sockets can't be built to Wasm. The Spin interface means Wasm modules can bypass this limitation by asking Spin to make the database connection on their behalf.\" }}","subsectionKeywords":"","url":"/v2/rdbms-storage"},{"project":"v2","title":"Relational Database Storage","subheading":"Using MySQL and PostgreSQL From Applications","content":"The Spin SDK surfaces the Spin MySQL and PostgreSQL interfaces to your language. The set of operations is the same across both databases:| Operation  | Parameters                 | Returns             | Behavior |\n|------------|----------------------------|---------------------|----------|\n| open     | address                    | connection resource | Opens a connection to the specified database. The host must be listed in allowed_outbound_hosts. Other operations must be called through a connection. |\n| query    | statement, SQL parameters  | database records    | Runs the specified statement against the database, returning the query results as a set of rows. |\n| execute  | statement, SQL parameters  | integer (not MySQL) | Runs the specified statement against the database, returning the number of rows modified by the statement.  (MySQL does not return the modified row count.) |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedMySQL functions are available in the spin_sdk::mysql module, and PostgreSQL functions in the spin_sdk::pg module. The function names match the operations above. This example shows MySQL:use spin_sdk::mysql::{self, Connection, Decode, ParameterValue};\n\nlet connection = Connection::open(&address)?;\n\nlet params = vec![ParameterValue::Int32(id)];\nlet rowset = connection.query(\"SELECT id, name FROM pets WHERE id = ?\", &params)?;\n\nmatch rowset.rows.first() {\n    None => /* no rows matched query */,\n    Some(row) => {\n        let name = String::decode(&row[1])?;\n    }\n}undefinedundefinedundefinedundefinedundefinedundefinedYou can find complete examples for using relational databases in the Spin repository on GitHub (undefined, undefined).For full information about the MySQL and PostgreSQL APIs, see undefined.{{ blockEnd }}{{ startTab \"TypeScript\"}}undefinedThe code below is an undefined. There is also an outbound undefined available.import { ResponseBuilder, Mysql } from '@fermyon/spin-sdk';\n\n// Connects as the root user without a password \nconst DB_URL = \"mysql://root:@127.0.0.1/spin_dev\"\n\n/*\n Run the following commands to setup the instance:\n create database spin_dev;\n use spin_dev;\n create table test(id int, val int);\n insert into test values (4,4);\n*/\n\nexport async function handler(_req: Request, res: ResponseBuilder) {\n  let conn = Mysql.open(DB_URL);\n  conn.execute('delete from test where id=?', [4]);\n  conn.execute('insert into test values (4,5)', []);\n  let ret = conn.query('select * from test', []);\n  // return a object that looks like \n  // { \"columns\": [{name: \"id\", dataType: \"int32\"}], \"rows\": [{ \"id\": 4, \"val\": 5 }] }\n  res.send(JSON.stringify(ret, null, 2));\n}{{ blockEnd }}{{ startTab \"Python\"}}undefinedThe code below is an undefined. There is also an outbound undefined available.from spin_sdk import http\nfrom spin_sdk.http import Request, Response\nfrom spin_sdk import mysql\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        with mysql.open(\"mysql://root:@127.0.0.1/spin_dev\") as db:\n            print(db.query(\"select * from test\", []))\n        \n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(\"Hello from Python!\", \"utf-8\")\n        ){{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedMySQL functions are available in the github.com/fermyon/spin/sdk/go/v2/mysql package, and PostgreSQL in github.com/fermyon/spin/sdk/go/v2/pg. undefinedThe package follows the usual Go database API. Use Open to return a connection to the database of type *sql.DB - see the undefined for usage information.  For example:package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\n\tspinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n\t\"github.com/fermyon/spin/sdk/go/v2/pg\"\n)\n\ntype Pet struct {\n\tID        int64\n\tName      string\n\tPrey      *string // nullable field must be a pointer\n\tIsFinicky bool\n}\n\nfunc init() {\n\tspinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n\n\t\t// addr is the environment variable set in `spin.toml` that points to the\n\t\t// address of the Mysql server.\n\t\taddr := os.Getenv(\"DB_URL\")\n\n\t\tdb := pg.Open(addr)\n\t\tdefer db.Close()\n\n\t\t_, err := db.Query(\"INSERT INTO pets VALUES ($1, 'Maya', $2, $3);\", int32(4), \"bananas\", true)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\trows, err := db.Query(\"SELECT * FROM pets\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tvar pets []*Pet\n\t\tfor rows.Next() {\n\t\t\tvar pet Pet\n\t\t\tif err := rows.Scan(&pet.ID, &pet.Name, &pet.Prey, &pet.IsFinicky); err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t}\n\t\t\tpets = append(pets, &pet)\n\t\t}\n\t\tjson.NewEncoder(w).Encode(pets)\n\t})\n}\n\nfunc main() {}{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/rdbms-storage#using-mysql-and-postgresql-from-applications"},{"project":"v2","title":"Relational Database Storage","subheading":"Granting Network Permissions to Components","content":"By default, Spin components are not allowed to make outgoing network requests, including MySQL or PostgreSQL. This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing. To grant a component permission to make network requests to a particular host, use the allowed_outbound_hosts field in the component manifest, specifying the host and allowed port:[component.uses-db]\nallowed_outbound_hosts = [\"postgres://postgres.example.com:5432\"]","keywords":"","subsectionKeywords":"","url":"/v2/rdbms-storage#granting-network-permissions-to-components"},{"project":"v2","title":"Relational Database Storage","subheading":"Configuration-Based Permissions","content":"You can use undefined in the allowed_outbound_hosts field. However, this feature is not yet available on Fermyon Cloud.","keywords":"","subsectionKeywords":"","url":"/v2/rdbms-storage#configuration-based-permissions"},{"project":"v2","title":"Redis Storage","subheading":"","content":"undefinedundefinedSpin provides an interface for you to read and write the Redis key/value store, and to publish Redis pub-sub messages.{{ details \"Why do I need a Spin interface? Why can't I just use my language's Redis library?\" \"The current version of the WebAssembly System Interface (WASI) doesn't provide a sockets interface, so Redis libraries that depend on sockets can't be built to Wasm. The Spin interface means Wasm modules can bypass this limitation by asking Spin to make the Redis connection on their behalf.\" }}","subsectionKeywords":"","url":"/v2/redis-outbound"},{"project":"v2","title":"Redis Storage","subheading":"Using Redis From Applications","content":"The Spin SDK surfaces the Spin Redis interface to your language. The set of operations is common across all SDKs:| Operation    | Parameters | Returns | Behavior |\n|--------------|---------------------|---------|----------|\n| open       | address    | connection resource | Opens a connection to the specified Redis instance. The host must be listed in allowed_outbound_hosts. Other operations must be called through a connection. (Exception: for JavaScript, do not call open, and pass the address to each data operation - see the language guides below.) |\n| Single value operations                      |\n| get        | key        | bytes   | Returns the value of key. If the key does not exist, returns a zero-length array. |\n| set        | key, bytes | -       | Sets the value of key, overwriting any existing value. |\n| incr       | key        | integer | Increments the value at key by 1. If the key does not exist, its value is set to 0 first (and immediately incremented to 1). If the current value isn't an integer, or a string that represents an integer, it errors and the value is not changed. |\n| del        | list of keys | -     | Removes the specified keys. Keys that don't exist are ignored (they do undefined cause an error). |\n| Set value operations                         |\n| sadd       | key, list of strings | integer | Adds the strings to the set of values of key, and returns the number of newly added values. If the key does not exist, its value is set to the set of values |\n| smembers   | key        | list of strings | Returns the set of values of key. if the key does not exist, this is an empty set. |\n| srem       | key, list of strings | integer | Removes the strings from the set of values of key, and returns the number of newly removed values. If the key does not exist, this does nothing. |\n| Pub-sub operations                           |\n| publish    | channel, bytes | - | Publishes a message to the specified channel, with the specified payload bytes. |\n| General operations                           |\n| execute    | command, list of argument values | list of results | Executes the specified command with the specified arguments. This is a general-purpose 'escape hatch' if you need a command that isn't covered by the built-in operations. |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedRedis functions are available in the spin_sdk::redis module.To access a Redis instance, use the Connection::open function.let connection = spin_sdk::redis::Connection::open(&address)?;You can then call functions on the Connection to work with the Redis instance:connection.set(\"my-key\", &\"my-value\".into());\nlet data = connection.get(\"my-key\")?;For full details of the Redis API, see the undefined;undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedYou can find a complete Rust code example for using outbound Redis from an HTTP component in the undefined. Please also see this, related, undefined.{{ blockEnd }}{{ startTab \"TypeScript\"}}undefinedRedis functions are available on undefined. The function names match the operations above. For example:import { Redis } from \"@fermyon/spin-sdk\"\n\nlet db = Redis.open(\"redis://localhost:6379\")\nlet value = db.get(key);undefinedundefinedundefinedundefinedundefinedundefinedYou can find a complete TypeScript example for using outbound Redis from an HTTP component in the undefined. Please also see this, related, undefined.{{ blockEnd }}{{ startTab \"Python\"}}undefinedRedis functions are available in undefined. The function names are prefixed redis_. You must pass the Redis instance address to undefined operation as its first parameter. For example:from spin_sdk import redis\nwith redis.open(\"redis://localhost:6379\") as db:\n    val = db.get(\"test\")undefinedundefinedundefinedundefinedundefinedundefinedYou can find a complete Python code example for using outbound Redis from an HTTP component in the undefined. Please also see this, related, undefined.{{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedRedis functions are available in the github.com/fermyon/spin/sdk/go/v2/redis package. undefined The function names are TitleCased. For example:import (\n\t\"github.com/fermyon/spin/sdk/go/v2/redis\"\n)\n\nrdb := redis.NewClient(addr)\npayload, err := rdb.Get(key)undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedYou can find a complete TinyGo example for using outbound Redis from an HTTP component in the undefined. Please also see this, related, undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/redis-outbound#using-redis-from-applications"},{"project":"v2","title":"Redis Storage","subheading":"Granting Network Permissions to Components","content":"By default, Spin components are not allowed to make outgoing network requests, including Redis. This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing. To grant a component permission to make network requests to a particular host, use the allowed_outbound_hosts field in the component manifest, specifying the host and allowed port:[component.uses-redis]\nallowed_outbound_hosts = [\"redis://redis.example.com:6379\"]","keywords":"","subsectionKeywords":"","url":"/v2/redis-outbound#granting-network-permissions-to-components"},{"project":"v2","title":"Redis Storage","subheading":"Configuration-Based Permissions","content":"You can use undefined in the allowed_outbound_hosts field. However, this feature is not yet available on Fermyon Cloud.","keywords":"","subsectionKeywords":"","url":"/v2/redis-outbound#configuration-based-permissions"},{"project":"v2","title":"The Spin Redis trigger","subheading":"","content":"undefinedundefinedundefinedundefinedPub-sub (publish-subscribe) messaging is a popular architecture for asynchronous message processing. Spin has built-in support to creating and running applications in response to messages on undefined.The Redis trigger in Spin subscribes to messages from a given Redis instance, and dispatches those messages to components for handling.undefinedundefined","subsectionKeywords":"","url":"/v2/redis-trigger"},{"project":"v2","title":"The Spin Redis trigger","subheading":"Specifying a Redis Trigger","content":"A Redis trigger maps a Redis channel to a component. For example:[[trigger.redis]]\naddress = \"redis://notifications.example.com:6379\" # the Redis instance that the trigger subscribes to (optional - see below)\nchannel = \"messages\"          # the channel that the trigger subscribes to\ncomponent = \"my-application\"  # the name of the component to handle this routeSuch a trigger says that Redis messages on the specified undefined should be handled by the specified undefined. The component field works the same way across all triggers - see undefined for the details.undefinedYou can use undefined in the address and channel fields.","keywords":"","subsectionKeywords":"","url":"/v2/redis-trigger#specifying-a-redis-trigger"},{"project":"v2","title":"The Spin Redis trigger","subheading":"Setting a Default Server","content":"In many applications, all components listen to the same Redis server (on different channels, of course). For this case, it is more convenient to specify the server at the application level instead of on each component. This is done via the [application.trigger.redis] section of manifest:[application.trigger.redis]\naddress = \"redis://notifications.example.com:6379\"undefinedYou can use undefined in the address field.","keywords":"","subsectionKeywords":"","url":"/v2/redis-trigger#setting-a-default-server"},{"project":"v2","title":"The Spin Redis trigger","subheading":"Redis Trigger Authentication","content":"By default, Spin does not authenticate to Redis. You can work around this by providing a password in the redis:// URL.  For example: address = \"redis://:p4ssw0rd@localhost:6379\"undefinedundefinedAs mentioned above, you can use undefined in Redis address fields. This can be particularly useful for credentials, allowing you to pass credentials in via undefined rather than including them in spin.toml.","keywords":"","subsectionKeywords":"","url":"/v2/redis-trigger#redis-trigger-authentication"},{"project":"v2","title":"The Spin Redis trigger","subheading":"Redis Components","content":"Spin runs Redis components using the undefined.  In this model, the Wasm module exports a well-known interface that Spin calls to handle the Redis message.","keywords":"","subsectionKeywords":"","url":"/v2/redis-trigger#redis-components"},{"project":"v2","title":"The Spin Redis trigger","subheading":"The Message Handler","content":"The exact signature of the Redis handler, and how a function is identified to be exported as the handler, will depend on your language.{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedIn Rust, the handler is identified by the #[spin_sdk::redis_component] attribute.  It takes a bytes::Bytes, representing the raw payload of the Redis message, and returns an anyhow::Result indicating success or an error with details.  This example just logs the payload as a string:use anyhow::Result;\nuse bytes::Bytes;\nuse spin_sdk::redis_component;\nuse std::str::from_utf8;\n\n/// A simple Spin Redis component.\n#[redis_component]\nfn on_message(message: Bytes) -> Result<()> {\n    println!(\"{}\", from_utf8(&message)?);\n    Ok(())\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}The JavaScript/TypeScript SDK doesn't currently support Redis components.  Please undefined if this is important to you.{{ blockEnd }}{{ startTab \"Python\"}}In Python, the handler needs to implement the undefined class, and override the handle_message method:from spin_sdk.wit import exports\nclass InboundRedis(exports.InboundRedis):\n    def handle_message(self, message: bytes):\n        print(message){{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedIn Go, you register the handler as a callback in your program's init function.  Call redis.Handle (from the Spin SDK redis package), passing your handler as the sole argument.  Your handler takes a single byte slice ([]byte) argument, and may return an error or nil.undefinedThis example just logs the payload as a string:package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/fermyon/spin/sdk/go/v2/redis\"\n)\n\nfunc init() {\n\tredis.Handle(func(payload []byte) error {\n\t\tfmt.Println(string(payload))\n\t\treturn nil\n\t})\n}\n\nfunc main() {}{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/redis-trigger#the-message-handler"},{"project":"v2","title":"The Spin Redis trigger","subheading":"Inside Redis Components","content":"For the most part, you'll build Redis component modules using a language SDK (see the Language Guides section), such as a Rust crate or Go package.  If you're interested in what happens inside the SDK, or want to implement Redis components in another language, read on!The Redis component interface is defined using a WebAssembly Interface (WIT) file.  (undefined).  You can find the latest WITs for Spin Redis components at undefined.In particular, the entry point for Spin Redis components is defined in undefined:interface inbound-redis {\n  use redis-types.{payload, error}\n\n  // The entrypoint for a Redis handler.\n  handle-message: func(message: payload) -> result<_, error>\n}This is the interface that all Redis components must implement, and\nwhich is used by Spin when instantiating and invoking the component.\nHowever, it is implemented internally by the Spin SDK - you don't need to implement it directly.","keywords":"","subsectionKeywords":"","url":"/v2/redis-trigger#inside-redis-components"},{"project":"v2","title":"Spin Apps in Registries","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v2/registry-tutorial"},{"project":"v2","title":"Spin Apps in Registries","subheading":"Spin Registry Support","content":"With Spin's registry support, you can package and save your Spin application as an artifact in a registry like undefined or undefined and then run your Spin app from these registries.","keywords":"","subsectionKeywords":"","url":"/v2/registry-tutorial#spin-registry-support"},{"project":"v2","title":"Spin Apps in Registries","subheading":"Prerequisites","content":"First, follow undefined to ensure you have the latest version of Spin installed (this tutorial refers to Spin 1.0 and above). You can check the Spin version using the following command:$ spin --version","keywords":"","subsectionKeywords":"","url":"/v2/registry-tutorial#prerequisites"},{"project":"v2","title":"Spin Apps in Registries","subheading":"Publishing and Running Spin Applications Using Registries (Video)","content":"The following video shows you how to push a Spin app to GHCR, and then run that artifact with Spin or with Docker. The video also contains additional information about signing and verifying your GHCR artifacts.The rest of this page shows you how to use GHCR artifacts locally with Spin.","keywords":"","subsectionKeywords":"","url":"/v2/registry-tutorial#publishing-and-running-spin-applications-using-registries-video"},{"project":"v2","title":"Spin Apps in Registries","subheading":"Set Up Your GHCR Instance","content":"To use a GHCR instance, you need to set up authentication. Follow undefined to generate a personal access token and then use it to sign into your GHCR. You should see the following message to confirm your login attempt to GHCR was successful:> Login Succeeded","keywords":"","subsectionKeywords":"","url":"/v2/registry-tutorial#set-up-your-ghcr-instance"},{"project":"v2","title":"Spin Apps in Registries","subheading":"Push a Spin App to GHCR","content":"Let's use this full-stack undefined to walk through this tutorial. If you have a Spin app already feel free to navigate to that directory and skip the step below.Fork and clone the app undefined:$ git clone https://github.com/USERNAME/spin-react-fullstack.gitNow, switch to that directory and rebuild the application:$ cd spin-react-fullstack\n$ spin buildNow we're ready to push the application. Run the spin registry push command to push your application to the registry:$ spin registry push ghcr.io/USERNAME/spin-react-fullstack:v1undefinedYou now have a Spin application stored in your registry. You can see the artifact under packages in the undefined.","keywords":"","subsectionKeywords":"","url":"/v2/registry-tutorial#push-a-spin-app-to-ghcr"},{"project":"v2","title":"Spin Apps in Registries","subheading":"Pull a Spin App From GHCR","content":"Now that we've successfully pushed a Spin app, let's see if we can pull it. To do so, run the following command:$ spin registry pull ghcr.io/USERNAME/spin-react-fullstack:v1","keywords":"","subsectionKeywords":"","url":"/v2/registry-tutorial#pull-a-spin-app-from-ghcr"},{"project":"v2","title":"Spin Apps in Registries","subheading":"Run a Spin App From GHCR","content":"Lastly, let's run this Spin application:$ spin up -f ghcr.io/USERNAME/spin-react-fullstack:v1","keywords":"","subsectionKeywords":"","url":"/v2/registry-tutorial#run-a-spin-app-from-ghcr"},{"project":"v2","title":"Spin Apps in Registries","subheading":"Deploy a Spin App from GHCR (or any registry)","content":"You can deploy a Spin app from any registry such as GHCR or DockerHub using the CLI command spin deploy -f <remote-reference-here>undefined","keywords":"","subsectionKeywords":"","url":"/v2/registry-tutorial#deploy-a-spin-app-from-ghcr-or-any-registry"},{"project":"v2","title":"Spin Apps in Registries","subheading":"Conclusion","content":"Congratulations on completing this tutorial! You have now successfully built, pushed, pulled, and run a Spin app using GHCR. Behind the scenes, Spin uses undefined project to distribute Spin apps across container registries. To learn more about how this feature works, take a look at undefined and undefined.","keywords":"","subsectionKeywords":"","url":"/v2/registry-tutorial#conclusion"},{"project":"v2","title":"Spin Apps in Registries","subheading":"Next Steps","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v2/registry-tutorial#next-steps"},{"project":"v2","title":"Running Spin Applications","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedOnce you have created and built your application, it's ready to run.  To run an application, use the spin up command.","subsectionKeywords":"","url":"/v2/running-apps"},{"project":"v2","title":"Running Spin Applications","subheading":"Specifying the Application to Run","content":"By default, spin up looks for a file named spin.toml in the current directory.If your manifest is named something different, or isn't in your current directory, use the -f (--from) flag. You also use -f to run remote applications.| -f Value                      | spin up Behavior  |\n|---------------------------------|---------------------|\n| File name: -f demo.toml       | Runs the specified manifest file |\n| Directory name: -f demo/      | Looks for a spin.toml file in that directory and runs that |\n| Registry reference: -f ghcr.io/fermyon/example:v1 | Pulls the application from the registry and runs that |undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/running-apps#specifying-the-application-to-run"},{"project":"v2","title":"Running Spin Applications","subheading":"Specifying the Wasm File to Run","content":"The spin up --from (spin up -f) option can point to a pre-existing Wasm binary executable instead of an application's manifest:$ spin up --from mymodule.wasmPlease note that the uses for performing spin up using just a Wasm file are very limited outside of basic testing of the Wasm file. This is because Wasm files run in this way have no access to application-level configuration that allows storage, outbound HTTP and so on. Only incoming HTTP handlers are supported.","keywords":"","subsectionKeywords":"","url":"/v2/running-apps#specifying-the-wasm-file-to-run"},{"project":"v2","title":"Running Spin Applications","subheading":"Testing HTTP Applications","content":"By default, HTTP applications listen on localhost:3000.  You can override this with the --listen option.  Spin prints links to the application components to make it easy to open them in the browser or copy them to curl commands for testing.","keywords":"","subsectionKeywords":"","url":"/v2/running-apps#testing-http-applications"},{"project":"v2","title":"Running Spin Applications","subheading":"Application Output","content":"By default, Spin prints application output, and any of its own error messages, to the console.To hide application output, pass the --quiet flag:$ spin up --quietTo limit application output to specific components, pass the --follow flag:$ spin up --follow cart --follow cart-api","keywords":"","subsectionKeywords":"","url":"/v2/running-apps#application-output"},{"project":"v2","title":"Running Spin Applications","subheading":"Persistent Logs","content":"By default:undefinedundefinedTo control logging, pass the --log-dir flag.  The logs will be saved to the specified directory (no matter whether the application is local or remote):$ spin up --log-dir ~/dev/bugbashIf you prefer undefined to have the stdout and stderr of your application's components written to disk (as in the example above), you can pass the --log-dir flag with an empty string, like this:$ spin up --log-dir \"\"","keywords":"","subsectionKeywords":"","url":"/v2/running-apps#persistent-logs"},{"project":"v2","title":"Running Spin Applications","subheading":"Trigger-Specific Options","content":"Some trigger types support additional spin up flags.  For example, HTTP applications can have a --listen flag to specify an address and port to listen on.  See the undefined and undefined pages for more details.","keywords":"","subsectionKeywords":"","url":"/v2/running-apps#trigger-specific-options"},{"project":"v2","title":"Running Spin Applications","subheading":"Monitoring Applications for Changes","content":"Spin's watch command rebuilds and restarts Spin applications whenever files change. You can use the spin watch undefined in place of the spin build and spin up commands, to build, run and then keep your Spin application running without manual intervention while staying on the latest code and files.undefinedBy default, Spin watch monitors:undefinedundefinedundefinedundefinedIf any of these change, Spin will rebuild the application if necessary, then restart the application with the new files.undefinedThe following spin.toml configuration (belonging to a Spin http-rust application) is configured to ensure that the application is both undefined (via cargo build --target wasm32-wasi --release) and undefined whenever changes occur in any Rust source (.rs) files, the Cargo.toml file or the spin.toml file, itself. When changes occur in either the Wasm binary file (target/wasm32-wasi/release/test.wasm) or the text file (my-files/changing-file.txt) the application is only undefined using the initial spin up command:[component.test]\n// -- snip\nfiles = [\"my-files/changing-file.txt\"]\nsource = \"target/wasm32-wasi/release/test.wasm\"\n[component.test.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\n# Example watch configuration for a Rust application\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]If the build section specifies a workdir, then watch patterns are relative to that directory. Otherwise, watch patterns are relative to the directory containing the spin.toml file.If you would prefer Spin watch to only rerun the application (without a rebuild) when changes occur, you can use the --skip-build option when running the spin watch command.  In this case, Spin will ignore the component.(id).build.watch section, and monitor only the spin.toml, component.source and component.files.The table below outlines exactly which files spin watch will monitor for changes depending on how you run the command. spin watch uses the configuration found on every component in your application.| Files                   | spin watch monitors for changes              | spin watch --skip-build monitors for changes |\n| ----------------------- | ---------------------------------------------- | ---------------------------------------------- |\n| Application manifest spin.toml   | Yes                                 | Yes                                            |\n| Component build.watch | Yes                                            | No                                             |\n| Component files       | Yes                                            | Yes                                            |\n| Component source      | No (Yes if the component has no build command) | YesSpin watch waits up to 100 milliseconds before responding to filesystem events, then processes all events that occurred in that interval together. This is so that if you make several changes close together (for example, using a Save All command), you get them all processed in one rebuild/reload cycle, rather than going through a cycle for each one. You can override the interval by passing in the --debounce option; e.g. spin watch --debounce 1000 will make Spin watch respond to filesystem events at most once per second.undefinedPassing the --clear flag clears the screen anytime a rebuild or rerun occurs. Spin watch does not clear the screen between rebuild and rerun as this provides you with an opportunity to see any warnings.For additional information about Spin's watch feature, please see the undefined blog article.undefined","keywords":"","subsectionKeywords":"","url":"/v2/running-apps#monitoring-applications-for-changes"},{"project":"v2","title":"Running Spin Applications","subheading":"The Always Build Option","content":"Some people find it frustrating having to remember to build their applications before running spin up. If you want to undefined build your projects when you run them, set the SPIN_ALWAYS_BUILD environment variable in your profile or session. If this is set, spin up runs undefined before starting your applications.","keywords":"","subsectionKeywords":"","url":"/v2/running-apps#the-always-build-option"},{"project":"v2","title":"Running Spin Applications","subheading":"Next Steps","content":"undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/running-apps#next-steps"},{"project":"v2","title":"Building Spin components in Rust","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedSpin aims to have best-in-class support for building components in Rust, and\nwriting such components should be familiar for Rust developers.undefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v2/rust-components"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Prerequisites","content":"","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#prerequisites"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Install the Templates","content":"You don't need the Spin Rust templates to work on Rust components, but they speed up creating new applications and components.  You can install them as follows:$ spin templates install --git https://github.com/spinframework/spin --update\nCopying remote template source\nInstalling template redis-rust...\nInstalling template http-rust...\n... other templates omitted ...\n+------------------------------------------------------------------------+\n| Name                Description                                        |\n+========================================================================+\n| ... other templates omitted ...                                        |\n| http-rust           HTTP request handler using Rust                    |\n| redis-rust          Redis message handler using Rust                   |\n| ... other templates omitted ...                                        |\n+------------------------------------------------------------------------+Note: The Rust templates are in a repo that contains several other languages; they will all be installed together.","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#install-the-templates"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Install the Tools","content":"To build Spin components, you'll need the wasm32-wasi target for Rust.$ rustup target add wasm32-wasiundefined","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#install-the-tools"},{"project":"v2","title":"Building Spin components in Rust","subheading":"HTTP Components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, but Rust has improved support\nfor writing Spin components with the Spin Rust SDK.undefinedBuilding a Spin HTTP component using the Rust SDK means writing a single function decorated with the undefined attribute. The function can have one of two forms:undefinedundefineduse spin_sdk::http::{Request, Response, IntoResponse};\nuse spin_sdk::http_component;\n\n/// A simple Spin HTTP component.\n#[http_component]\nasync fn handle_hello_rust(_req: Request) -> anyhow::Result<impl IntoResponse> {\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, Fermyon\")\n        .build())\n}The important things to note in the implementation above:undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#http-components"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Redis Components","content":"Besides the HTTP trigger, Spin has built-in support for a Redis trigger —\nwhich will connect to a Redis instance and will execute Spin components for\nnew messages on the configured channels.undefinedWriting a Redis component in Rust also takes advantage of the SDK:use anyhow::Result;\nuse bytes::Bytes;\nuse spin_sdk::redis_component;\n\n/// A simple Spin Redis component.\n#[redis_component]\nfn on_message(message: Bytes) -> Result<()> {\n    println!(\"{}\", std::str::from_utf8(&message)?);\n    Ok(())\n}undefinedundefinedundefinedThe component can be built with Cargo by executing:$ cargo build --target wasm32-wasi --releaseThe manifest for a Redis application must contain the address of the Redis\ninstance the trigger must connect to:spin_manifest_version = 2\nname = \"spin-redis\"\nversion = \"0.1.0\"\n\n[application.trigger.redis]\naddress = \"redis://localhost:6379\"\n\n[[trigger.redis]]\nchannel = \"messages\"\ncomponent = { source = \"target/wasm32-wasi/release/spinredis.wasm\" }This application will connect to redis://localhost:6379, and for every new\nmessage on the messages channel, the echo-message component will be executed:# first, start redis-server on the default port 6379\n$ redis-server --port 6379\n# then, start the Spin application\n$ spin up --file spin.toml\n# the application log file will output the following\nINFO spin_redis_engine: Connecting to Redis server at redis://localhost:6379\nINFO spin_redis_engine: Subscribed component 0 (echo-message) to channel: messagesFor every new message on the  messages channel:$ redis-cli\n127.0.0.1:6379> publish messages \"Hello, there!\"Spin will instantiate and execute the component we just built, which will emit the println! message to the application log file:INFO spin_redis_engine: Received message on channel \"messages\"\nHello, there!undefined","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#redis-components"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Sending Outbound HTTP Requests","content":"If allowed, Spin components can send outbound HTTP requests.\nLet's see an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:use anyhow::Result;\nuse spin_sdk::{\n    http::{IntoResponse, Request, Method, Response},\n    http_component,\n};\n\n#[http_component]\nasync fn send_outbound(_req: Request) -> Result<impl IntoResponse> {\n    // Create the outbound request object\n    let req = Request::builder()\n        .method(Method::Get)\n        .uri(\"https://random-data-api.fermyon.app/animals/json\")\n        .build();\n\n    // Send the request and await the response\n    let res: Response = spin_sdk::http::send(req).await?;\n\n    println!(\"{:?}\", res);  // log the response\n    Ok(res)\n}undefinedBefore we can execute this component, we need to add the random-data-api.fermyon.app\ndomain to the component's allowed_outbound_hosts list in the application manifest. This contains the list of\ndomains the component is allowed to make network requests to:# spin.toml\nspin_manifest_version = 2\n\n[application]\nname = \"animal-facts\"\nversion = \"1.0.0\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"get-animal-fact\"\n\n[component.get-animal-fact]\nsource = \"get-animal-fact/target/wasm32-wasi/release/get_animal_fact.wasm\"\nallowed_outbound_hosts = [\"https://random-data-api.fermyon.app\"]Running the application using spin up will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /outbound:$ curl -i localhost:3000\nHTTP/1.1 200 OK\ndate: Fri, 27 Oct 2023 03:54:36 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 185\nspin-component: get-animal-fact\n\n{\"timestamp\":1684299253331,\"fact\":\"Reindeer grow new antlers every year\"}   undefinedundefinedWe just built a WebAssembly component that sends an HTTP request to another\nservice, manipulates that result, then responds to the original request.\nThis can be the basis for building components that communicate with external\ndatabases or storage accounts, or even more specialized components like HTTP\nproxies or URL shorteners.undefined","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#sending-outbound-http-requests"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Routing in a Component","content":"The Rust SDK undefined that makes it easier to handle routing within a component:use anyhow::Result;\nuse spin_sdk::{\n    http::{IntoResponse, Params, Request, Response, Router},\n    http_component,\n};\n\n/// A Spin HTTP component that internally routes requests.\n#[http_component]\nfn handle_route(req: Request) -> Response {\n    let mut router = Router::new();\n    router.get(\"/goodbye/:planet\", api::goodbye_planet);\n    router.any_async(\"/*\", api::echo_wildcard);\n    router.handle(req)\n}\n\nmod api {\n    use super::*;\n\n    // /goodbye/:planet\n    pub fn goodbye_planet(_req: Request, params: Params) -> Result<impl IntoResponse> {\n        let planet = params.get(\"planet\").expect(\"PLANET\");\n        Ok(Response::new(200, planet.to_string()))\n    }\n\n    // /*\n    pub async fn echo_wildcard(_req: Request, params: Params) -> Result<impl IntoResponse> {\n        let capture = params.wildcard().unwrap_or_default();\n        Ok(Response::new(200, capture.to_string()))\n    }\n}Handlers within a Router can be sync or async. Use Router's \"plain\" methods (e.g. get, post) to assign synchronous handlers, and its \"async\" methods (e.g. get_async, post_async) for asynchronous handlers.  You can mix sync and async handlers in the same Router, and can use handle or handle_async to invoke Router processing, regardless of whether invididual handlers are sync or async.undefined","keywords":"","subsectionKeywords":"  async ","url":"/v2/rust-components#routing-in-a-component"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Storing Data in Redis From Rust Components","content":"Using the Spin's Rust SDK, you can use the Redis key/value store and to publish\nmessages to Redis channels. This can be used from both HTTP and Redis triggered\ncomponents.Let's see how we can use the Rust SDK to connect to Redis:use anyhow::Context;\nuse spin_sdk::{\n    http::{responses::internal_server_error, IntoResponse, Request, Response},\n    http_component,\n    redis::Connection,\n};\n\n// The environment variable set in `spin.toml` that points to the\n// address of the Redis server that the component will publish\n// a message to.\nconst REDIS_ADDRESS_ENV: &str = \"REDIS_ADDRESS\";\n\n// The environment variable set in `spin.toml` that specifies\n// the Redis channel that the component will publish to.\nconst REDIS_CHANNEL_ENV: &str = \"REDIS_CHANNEL\";\n\n/// This HTTP component demonstrates fetching a value from Redis\n/// by key, setting a key with a value, and publishing a message\n/// to a Redis channel. The component is triggered by an HTTP\n/// request served on the route configured in the `spin.toml`.\n#[http_component]\nfn publish(_req: Request) -> anyhow::Result<impl IntoResponse> {\n    let address = std::env::var(REDIS_ADDRESS_ENV)?;\n    let channel = std::env::var(REDIS_CHANNEL_ENV)?;\n\n    // Establish a connection to Redis\n    let conn = Connection::open(&address)?;\n\n    // Get the message to publish from the Redis key \"mykey\"\n    let payload = conn\n        .get(\"mykey\")\n        .context(\"Error querying Redis\")?\n        .context(\"'mykey' was unexpectedly empty\")?;\n\n    // Set the Redis key \"spin-example\" to value \"Eureka!\"\n    conn.set(\"spin-example\", &\"Eureka!\".to_owned().into_bytes())\n        .context(\"Error executing Redis set command\")?;\n\n    // Set the Redis key \"int-key\" to value 0\n    conn.set(\"int-key\", &format!(\"{:x}\", 0).into_bytes())\n        .context(\"Error executing Redis set command\")?;\n    let int_value = conn\n        .incr(\"int-key\")\n        .context(\"Error executing Redis incr command\")?;\n    assert_eq!(int_value, 1);\n\n    // Publish to Redis\n    match conn.publish(&channel, &payload) {\n        Ok(()) => Ok(Response::builder().status(200).build()),\n        Err(_e) => Ok(internal_server_error())\n    }\n}As with all networking APIs, you must grant access to Redis hosts via the allowed_outbound_hosts field in the application manifest:[component.redis-test]\nenvironment = { REDIS_ADDRESS = \"redis://127.0.0.1:6379\", REDIS_CHANNEL = \"messages\" }\n# Note this contains only the host and port - do not include the URL!\nallowed_outbound_hosts = [\"redis://127.0.0.1:6379\"]This HTTP component can be paired with a Redis component, triggered on new\nmessages on the messages Redis channel.undefined","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#storing-data-in-redis-from-rust-components"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Storing Data in the Spin Key-Value Store","content":"Spin has a key-value store built in. For information about using it from Rust, see undefined.","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#storing-data-in-the-spin-key-value-store"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Serializing Objects to the Key-Value Store","content":"The Spin key-value API stores and retrieves only lists of bytes. The Rust SDK provides helper functions that allow you to store and retrieve undefined serializable values in a typed way. The underlying storage format is JSON (and is accessed via the get_json and set_json helpers).To make your objects serializable, you will also need a reference to serde. The relevant Cargo.toml entries look like this:[dependencies]\n// --snip --\nserde = { version = \"1.0.163\", features = [\"derive\"] }\n// --snip --We configure our application to provision the default key_value_stores by adding the following line to our application's manifest (the spin.toml file), at the component level:[component.redis-test]\nkey_value_stores = [\"default\"]The Rust code below shows how to store and retrieve serializable objects from the key-value store (note how the example below implements Serde's derive feature):use anyhow::Context;\nuse serde::{Deserialize, Serialize};\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n    key_value::Store,\n};\n\n// Define a serializable User type\n#[derive(Serialize, Deserialize)]\nstruct User {\n    fingerprint: String,\n    location: String,\n}\n\n#[http_component]\nfn handle_request(_req: Request) -> anyhow::Result<Response> {\n    // Open the default key-value store\n    let store = Store::open_default()?;\n\n    // Create an instance of a User object and populate the values\n    let user = User {\n        fingerprint: \"0x1234\".to_owned(),\n        location: \"Brisbane\".to_owned(),\n    };\n    // Store the User object using the \"my_json\" key\n    store.set_json(\"my_json\", &user)?;\n    // Retrieve the user object from the key-value store, using the \"my_json\" key\n    let retrieved_user: User = store.get_json(\"my_json\")?.context(\"user not found\")?;\n    // Return the user's fingerprint as the response body\n    Ok(Response::builder()\n        .status(200)\n        .body(retrieved_user.fingerprint)\n        .build())\n}undefinedOnce built and running (using spin build and spin up) you can test the above example in your browser (by visiting localhost:3000) or via curl, as shown below:$ curl localhost:3000\nHTTP/1.1 200 OK\n\n0x1234For more information on the Rust key-value API see undefined.","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#serializing-objects-to-the-key-value-store"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Storing Data in SQLite","content":"For more information about using SQLite from Rust, see undefined.","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#storing-data-in-sqlite"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Storing Data in Relational Databases","content":"Spin provides clients for MySQL and PostgreSQL. For information about using them from Rust, see undefined.","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#storing-data-in-relational-databases"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Using External Crates in Rust Components","content":"In Rust, Spin components are regular libraries that contain a function\nannotated using the http_component macro, compiled to the wasm32-wasi target.\nThis means that any undefined that compiles to wasm32-wasi can\nbe used when implementing the component.","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#using-external-crates-in-rust-components"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Using the  http  crate","content":"If you're already familiar with the popular undefined, you may wish to use that instead of using the HTTP types included in the Spin SDK. Generally, the http crate's types can be used anywhere the Spin SDK HTTP types can be used. For example, the first basic HTTP component can be rewritten to use the http crate like so:use http::{Request, Response};\nuse spin_sdk::http::IntoResponse;\nuse spin_sdk::http_component;\n\n/// A simple Spin HTTP component.\n#[http_component]\nasync fn handle_hello_rust(_req: Request<()>) -> anyhow::Result<impl IntoResponse> {\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, Fermyon\")?)\n}Of course, you'll need to remember to add the http crate to your Cargo.toml:[dependencies]\n// --snip --\nhttp = \"0.2.9\"\n// --snip --","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#using-the-http-crate"},{"project":"v2","title":"Building Spin components in Rust","subheading":"AI Inferencing From Rust Components","content":"For more information about using Serverless AI from Rust, see the undefined API guide.","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#ai-inferencing-from-rust-components"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Troubleshooting","content":"If you bump into issues building and running your Rust component, here are some common causes of problems:undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#troubleshooting"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Manually Creating New Projects With Cargo","content":"The recommended way of creating new Spin projects is by starting from a template.\nThis section shows how to manually create a new project with Cargo.When creating a new Spin project with Cargo, you should use the --lib flag:$ cargo init --libA Cargo.toml with standard Spin dependencies looks like this:[package]\nname = \"your-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\n# Required to have a `cdylib` (dynamic library) to produce a Wasm module.\ncrate-type = [ \"cdylib\" ]\n\n[dependencies]\n# Useful crate to handle errors.\nanyhow = \"1\"\n# The Spin SDK.\nspin-sdk = { git = \"https://github.com/spinframework/spin\" }","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#manually-creating-new-projects-with-cargo"},{"project":"v2","title":"Building Spin components in Rust","subheading":"Read the Rust Spin SDK Documentation","content":"Although you learned a lot by following the concepts and samples shown here, you can dive even deeper and read the undefined.","keywords":"","subsectionKeywords":"","url":"/v2/rust-components#read-the-rust-spin-sdk-documentation"},{"project":"v2","title":"Built With Spin","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedSpin can be used to build many different types of applications. The following blog articles show how different applications are built with Spin.","subsectionKeywords":"","url":"/v2/see-what-people-have-built-with-spin"},{"project":"v2","title":"Built With Spin","subheading":"AI-powered bookmarking app with Python and WebAssembly","content":"undefined.","keywords":"","subsectionKeywords":"","url":"/v2/see-what-people-have-built-with-spin#ai-powered-bookmarking-app-with-python-and-webassembly"},{"project":"v2","title":"Built With Spin","subheading":"Like Button","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v2/see-what-people-have-built-with-spin#like-button"},{"project":"v2","title":"Built With Spin","subheading":"Social App","content":"The 'Building a Social App with Spin' series covers the process and decision-making of building an authenticated, dynamic, database-backed application and API, right the way from downloading Spin and setting up the project to deploying the finished application to the cloud.undefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/see-what-people-have-built-with-spin#social-app"},{"project":"v2","title":"Built With Spin","subheading":"Static Content Server","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v2/see-what-people-have-built-with-spin#static-content-server"},{"project":"v2","title":"Built With Spin","subheading":"Bots","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v2/see-what-people-have-built-with-spin#bots"},{"project":"v2","title":"Built With Spin","subheading":"URL Shortener and QR Code Generator","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v2/see-what-people-have-built-with-spin#url-shortener-and-qr-code-generator"},{"project":"v2","title":"Built With Spin","subheading":"Content Management System (CMS)","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v2/see-what-people-have-built-with-spin#content-management-system-cms"},{"project":"v2","title":"Built With Spin","subheading":"The Finicky Whiskers Game","content":"The 'Finicky Whiskers' series covers the journey of creating a game with an architecture designed to undefined and showcase how WebAssembly modules can be started, executed, and shut down in the blink of an eye.undefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/see-what-people-have-built-with-spin#the-finicky-whiskers-game"},{"project":"v2","title":"Built With Spin","subheading":"Accessing External APIs","content":"Chances are whatever you are building will want to talk to other endpoints on the web. If so, Spin's HTTP library can help. The following article explains how to access external APIs from within Spin applications.undefined","keywords":"","subsectionKeywords":"","url":"/v2/see-what-people-have-built-with-spin#accessing-external-apis"},{"project":"v2","title":"Built With Spin","subheading":"SQLite Storage Using Javascript","content":"Check out our undefined blog article that provides an SQLite database example (using Javascript).","keywords":"","subsectionKeywords":"","url":"/v2/see-what-people-have-built-with-spin#sqlite-storage-using-javascript"},{"project":"v2","title":"Built With Spin","subheading":"Next Steps","content":"undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/see-what-people-have-built-with-spin#next-steps"},{"project":"v2","title":"Serverless AI API","subheading":"","content":"undefinedundefinedundefinedThe nature of AI and LLM workloads on already trained models lends itself very naturally to a serverless-style architecture. As a framework for building and deploying serverless applications, Spin provides an interface for you to perform AI inference within Spin applications.","subsectionKeywords":"","url":"/v2/serverless-ai-api-guide"},{"project":"v2","title":"Serverless AI API","subheading":"Using Serverless AI From Applications","content":"","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-api-guide#using-serverless-ai-from-applications"},{"project":"v2","title":"Serverless AI API","subheading":"Configuration","content":"By default, a given component of a Spin application will not have access to any Serverless AI models. Access must be provided explicitly via the Spin application's manifest (the spin.toml file).  For example, an individual component in a Spin application could be given access to the llama2-chat model by adding the following ai_models configuration inside the specific [component.(name)] section:// -- snip --\n\n[component.please-send-the-codes]\nai_models = [\"codellama-instruct\"]\n\n// -- snip --undefined","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-api-guide#configuration"},{"project":"v2","title":"Serverless AI API","subheading":"File Structure","content":"By default, the Spin framework will expect any already trained model files (which are configured as per the previous section) to be downloaded by the user and made available inside a .spin/ai-models/ file path of a given application. For example:code-generator-rs/.spin/ai-models/llama/codellama-instructSee the undefined documentation for more concrete examples of implementing the Fermyon Serverless AI API, in your favorite language.undefined","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-api-guide#file-structure"},{"project":"v2","title":"Serverless AI API","subheading":"Serverless AI Interface","content":"The Spin SDK surfaces the Serverless AI interface to a variety of different languages. See the undefined to see if your specific language is supported.The set of operations is common across all supporting language SDKs:| Operation | Parameters | Returns | Behavior |\n|:-----|:----------------|:-------|:----------------|\n| infer  | modelstring<br /> promptstring| string  | The infer is performed on a specific model.<br /> <br />The name of the model is the first parameter provided (i.e. llama2-chat, codellama-instruct, or other; passed in as a string).<br /> <br />The second parameter is a prompt; passed in as a string.<br />|\n| infer_with_options  | modelstring<br /> promptstring<br /> paramslist | string  | The infer_with_options is performed on a specific model.<br /> <br />The name of the model is the first parameter provided (i.e. llama2-chat, codellama-instruct, or other; passed in as a string).<br /><br /> The second parameter is a prompt; passed in as a string.<br /><br /> The third parameter is a mix of float and unsigned integers relating to inferencing parameters in this order: <br /><br />- max-tokens (unsigned 32 integer) Note: the backing implementation may return less tokens. <br /> Default is 100<br /><br /> - repeat-penalty (float 32) The amount the model should avoid repeating tokens. <br /> Default is 1.1<br /><br /> - repeat-penalty-last-n-token-count (unsigned 32 integer) The number of tokens the model should apply the repeat penalty to. <br /> Default is 64<br /><br /> - temperature (float 32) The randomness with which the next token is selected. <br /> Default is 0.8<br /><br /> - top-k (unsigned 32 integer) The number of possible next tokens the model will choose from. <br /> Default is 40<br /><br /> - top-p (float 32) The probability total of next tokens the model will choose from. <br /> Default is 0.9<br /><br /> The result from infer_with_options is a string |\n| generate-embeddings  | modelstring<br /> promptlist<string>| string  | The generate-embeddings is performed on a specific model.<br /> <br />The name of the model is the first parameter provided (i.e. all-minilm-l6-v2, passed in as a string).<br /> <br />The second parameter is a prompt; passed in as a list of strings.<br /><br /> The result from generate-embeddings is a two-dimension array containing float32 type values only |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedTo use Serverless AI functions, the llm module from the Spin SDK provides the methods. The following snippet is from the undefined:use spin_sdk::{\n    http::{IntoResponse, Request, Response},\n    llm,\n};\n\n// -- snip --\n\nfn handle_code(req: Request) -> anyhow::Result<impl IntoResponse> {\n    // -- snip --\n\n    let result = llm::infer_with_options(\n        llm::InferencingModel::CodellamaInstruct,\n        &prompt,\n        llm::InferencingParams {\n            max_tokens: 400,\n            repeat_penalty: 1.1,\n            repeat_penalty_last_n_token_count: 64,\n            temperature: 0.8,\n            top_k: 40,\n            top_p: 0.9,\n        },\n    )?;\n\n    // -- snip --\t\n}\nundefinedThe infer_with_options examples, operation:undefinedundefinedundefinedundefined{{ blockEnd }}{{ startTab \"Typescript\"}}undefinedTo use Serverless AI functions, undefined from the Spin SDK provides two methods: infer and generateEmbeddings. For example:import { ResponseBuilder, Llm} from \"@fermyon/spin-sdk\"\n\nexport async function handler(req: Request, res: ResponseBuilder) {\n    let embeddings = Llm.generateEmbeddings(Llm.EmbeddingModels.AllMiniLmL6V2, [\"someString\"])\n    console.log(embeddings.embeddings)\n    let result = Llm.infer(Llm.InferencingModels.Llama2Chat, prompt)\n\n    res.set({\"content-type\":\"text/plain\"})\n    res.send(result.text)\n}undefinedinfer operation:undefinedundefinedundefinedundefinedgenerateEmbeddings operation:undefinedundefinedundefined{{ blockEnd }}{{ startTab \"Python\"}}undefinedfrom spin_sdk import http\nfrom spin_sdk.http import Request, Response\nfrom spin_sdk import llm\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        prompt=\"You are a stand up comedy writer. Tell me a joke.\"\n        result = llm.infer(\"llama2-chat\", prompt)\n        return Response(200,\n                        {\"content-type\": \"application/json\"},\n                        bytes(result.text, \"utf-8\"))undefinedundefined:undefinedundefined{{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedServerless AI functions are available in the github.com/fermyon/spin/sdk/go/v2/llm package. See undefined for reference documentation. For example:package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\tspinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n\t\"github.com/fermyon/spin/sdk/go/v2/llm\"\n)\n\nfunc init() {\n\tspinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n\t\tresult, err := llm.Infer(\"llama2-chat\", \"What is a good prompt?\", nil)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Prompt tokens:    %d\\n\", result.Usage.PromptTokenCount)\n\t\tfmt.Printf(\"Generated tokens: %d\\n\", result.Usage.GeneratedTokenCount)\n\t\tfmt.Fprintf(w, \"%s\\n\", result.Text)\n\n\t\tembeddings, err := llm.GenerateEmbeddings(\"all-minilm-l6-v2\", []string{\"Hello world\"})\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Prompt Tokens: %d\\n\", embeddings.Usage.PromptTokenCount)\n\t\tfmt.Printf(\"%v\\n\", embeddings.Embeddings)\n\t})\n}undefinedinfer operation:undefinedundefinedundefinedundefinedgenerateEmbeddings operation:undefinedundefinedundefined{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-api-guide#serverless-ai-interface"},{"project":"v2","title":"Serverless AI API","subheading":"Troubleshooting","content":"","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-api-guide#troubleshooting"},{"project":"v2","title":"Serverless AI API","subheading":"Error \"Local LLM operations are not supported in this version of Spin\"","content":"If you see \"Local LLM operations are not supported in this version of Spin\", then your copy of Spin has been built without local LLM support.undefinedMost Spin builds support local LLMs as described above. However, the models built into Spin do not build on some combinations of platforms (for example, there are known problems with the aarch64/musl combination). This may cause some environments that embed Spin to disable the local LLM feature altogether. (For examples, some versions of the containerd-spin-shim did this.) In such cases, you will see the error above.In such cases, you can:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-api-guide#error-local-llm-operations-are-not-supported-in-this-version-of-spin"},{"project":"v2","title":"Build your first AI app using Serverless AI Inferencing","subheading":"","content":"undefinedundefinedundefinedundefinedThis tutorial will show you how to use Fermyon Serverless AI to quickly build your first AI-enabled serverless application that can run on Fermyon Cloud.\nIn this tutorial we will:undefinedundefinedundefinedHere's a video walkthrough of this tutorial","subsectionKeywords":"","url":"/v2/serverless-ai-hello-world"},{"project":"v2","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Tutorial Prerequisites","content":"","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-hello-world#tutorial-prerequisites"},{"project":"v2","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Spin","content":"You will need to undefined. Serverless AI is supported on Spin v1.5 and above\nIf you already have Spin installed, undefined if required.","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-hello-world#spin"},{"project":"v2","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Dependencies","content":"undefined\nThe above installation script automatically installs the latest SDKs for Rust, which enables Serverless AI functionality.undefinedTo enable Serverless AI functionality via TypeScript/Javascript, please ensure you have the latest TypeScript/JavaScript template installed:$ spin templates install --git https://github.com/spinframework/spin-js-sdk --upgrade --branch sdk-v2undefinedEnsure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.To enable Serverless AI functionality via Python, please ensure you have the latest Python template installed:$ spin templates install --git https://github.com/spinframework/spin-python-sdk --updateAs a standard practice for Python, create and activate a virtual env:If you are on a Mac/linux based operating system use the following commands:$ python3 -m venv venv\n$ source venv/bin/activateIf you are using Windows, use the following commands:C:\\Work> python3 -m venv venv\nC:\\Work> venv\\Scripts\\activate","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-hello-world#dependencies"},{"project":"v2","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Licenses","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-hello-world#licenses"},{"project":"v2","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Serverless AI Inferencing With Spin","content":"Now, let's write your first Serverless AI application with Spin.","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-hello-world#serverless-ai-inferencing-with-spin"},{"project":"v2","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Creating a New Spin Application","content":"{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}The Rust code snippets below are taken from the undefined.$ spin new -t http-rust\nEnter a name for your new application: hello-world\nDescription: My first Serverless AI app\nHTTP path: /...{{ blockEnd }}{{ startTab \"Python\" }}The Python code snippets below are taken from the undefined.# Create new app\n$ spin new -t http-py hello-world --accept-defaults\n# Change into app directory\n$ cd hello-world\nEnter a name for your new application: hello-world\nDescription: My first Serverless AI app\nHTTP path: /...Create a virtual environment directory (we are still inside the Spin app directory):# python<version> -m venv <virtual-environment-name>\n$ python3 -m venv venv-dirActivate the virtual environment (this command depends on which operating system you are using):# macOS command to activate\n$ source venv-dir/bin/activateThe (venv-dir) will prefix your terminal prompt now:(venv-dir) user@123-456-7-8 hello-world %The requirements.txt, by default, contains the references to the spin-sdk and componentize-py packages. These can be installed in your virtual environment using the following command:$ pip3 install -r requirements.txt {{ blockEnd }}{{ startTab \"TypeScript\" }}The TypeScript code snippets below are taken from the undefined.$ spin new -t http-ts\nEnter a name for your new application: hello-world\nDescription: My first Serverless AI app\nHTTP path: /...{{ blockEnd }}\n{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-hello-world#creating-a-new-spin-application"},{"project":"v2","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Configuring Your Application","content":"The spin.toml file is the manifest file which tells Spin what events should trigger what components. Configure the [component.hello-world] section of our application's manifest explicitly naming our model of choice. For this example, we specify the llama2-chat value for our ai_models configuration:ai_models = [\"llama2-chat\"]This is what your spin.toml file should look like, based on whether you’re using Rust, TypeScript or Python:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}spin_manifest_version = 2\n\n[application]\nname = \"hello-world\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first Serverless AI app\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nsource = \"target/wasm32-wasi/release/hello_world.wasm\"\nallowed_outbound_hosts = []\nai_models = [\"llama2-chat\"]\n[component.hello-world.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]{{ blockEnd }}{{ startTab \"TypeScript\" }}spin_manifest_version = 2\n\n[application]\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first Serverless AI app\"\nname = \"hello-world\"\nversion = \"0.1.0\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nsource = \"target/hello-world.wasm\"\nexclude_files = [\"**/node_modules\"]\nai_models = [\"llama2-chat\"]\n[component.hello-world.build]\ncommand = \"npm run build\"{{ blockEnd }}{{ startTab \"Python\" }}spin_manifest_version = 2\n\n[application]\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\nname = \"hello-world\"\nversion = \"0.1.0\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nsource = \"app.wasm\"\nai_models = [\"llama2-chat\"]\n[component.hello-world.build]\ncommand = \"componentize-py -w spin-http componentize app -o app.wasm\"\nwatch = [\"*.py\", \"requirements.txt\"]{{ blockEnd }}\n{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-hello-world#configuring-your-application"},{"project":"v2","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Source Code","content":"Now let's use the Spin SDK to access the model from our app. Executing inference from a LLM is a single line of code. Add the Llm and the InferencingModels to your app and use the Llm.infer to execute an inference. Here’s how the code looks:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}use spin_sdk::{http::{IntoResponse, Request, Response}, http_component, llm};\n\n#[http_component]\nfn hello_world(_req: Request) -> anyhow::Result<impl IntoResponse> {\n   let model = llm::InferencingModel::Llama2Chat;\n   let inference = llm::infer(model, \"Can you tell me a joke about cats\");\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(format!(\"{:?}\", inference))\n        .build())\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}import { Llm, InferencingModels, HandleRequest, HttpRequest, HttpResponse } from  \"@fermyon/spin-sdk\"\nconst  model = InferencingModels.Llama2Chat\nexport  const  handleRequest: HandleRequest = async  function (request: HttpRequest): Promise<HttpResponse> {\nconst  prompt = \"Can you tell me a joke about cats\"\nconst  out = Llm.infer(model, prompt)\nreturn {\n\tstatus:  200,\n\tbody:  out.text\n\t}\n}{{ blockEnd }}{{ startTab \"Python\"}}from spin_sdk import http\nfrom spin_sdk.http import Request, Response\nfrom spin_sdk import llm\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        res = llm.infer_with_options(\"llama2-chat\", \"Can you tell me a joke about cats?\", llm.LLMInferencingParams(temperature=0.5))\n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(res.text, \"utf-8\")\n        )\n\n{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-hello-world#source-code"},{"project":"v2","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Building and Deploying Your Spin Application","content":"Now that you have written your first Serverless AI app, it’s time to build and deploy it. To build your app run the following commands from inside your app’s folder (where the spin.toml file is located):{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}$ spin build{{ blockEnd }}{{ startTab \"TypeScript\" }}\n$ npm install\n$ spin build\n{{ blockEnd }}\n{{ startTab \"Python\" }}$ spin build{{ blockEnd }}Now that your app is built, there are three ways to test your Serverless AI app. One way to test the app is to run inferencing locally. This means running a LLM on your CPU. This is not as optimal compared to deploying to Fermyon’s Serverless AI, which uses high-powered GPUs in the cloud. To know more about this method, including downloading LLMs to your local machine, check out undefined on Building a Sentiment Analysis API using Serverless AI.Here are the two other methods for testing your app:undefinedYou can deploy the app to the cloud by using the spin deploy command. In case you have not logged into your account before deploying your application, you need to grant access via a one-time token. Follow the instructions in the prompt to complete the auth process.Once you have logged in and the app is deployed, you will see a URL, upon successful deployment. The app is now deployed and can be accessed by anyone with the URL:$ spin deploy\n\n>Uploading hello-world version 0.1.0+ra01f74e2...\nDeploying...\nWaiting for application to become ready...... ready\nAvailable Routes:\nhello-world: https://hello-world-XXXXXX.fermyon.app (wildcard)The app’s manifest file reads the line ai_models = [\"llama2-chat\"] and uses that model in the cloud. For any changes to take effect in the app, it needs to be re-deployed to the cloud.undefinedTo avoid having to deploy the app for every change, you can use the undefined to deploy locally, with the LLM running in the cloud. While the app is hosted locally (running on localhost), every inferencing request is sent to the LLM that is running in the cloud. Follow the steps to use the cloud-gpu plugin.undefined: This plugin works only with spin v1.5.1 and above.First, install the plugin using the command:$ spin plugins install -u https://github.com/spinframework/spin-cloud-gpu/releases/download/canary/cloud-gpu.json -yLet’s initialize the plugin. This command essentially deploys the Spin app to a Cloud GPU proxy and generates a runtime-config:$ spin cloud-gpu init\n\n[llm_compute]\ntype = \"remote_http\"\nurl = \"https://fermyon-cloud-gpu-<AUTO_GENERATED_STRING>.fermyon.app\"\nauth_token = \"<AUTO_GENERATED_TOKEN>\"In the root of your Spin app directory, create a file named runtime-config.toml and paste the runtime-config generated in the previous step.Now you are ready to test the Serverless AI app locally, using a GPU that is running in the cloud. To deploy the app locally you can use spin up (or spin watch) but with the following flag:$ spin up --runtime-config-file <path/to/runtime-config.toml>\n\nLogging component stdio to  \".spin/logs/\"\nServing http://127.0.0.1:3000\nAvailable Routes:\nhello-world: http://127.0.0.1:3000 (wildcard)","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-hello-world#building-and-deploying-your-spin-application"},{"project":"v2","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Next Steps","content":"This was just a small example of what Serverless AI Inferencing can do. To check out more detailed code samples:undefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/serverless-ai-hello-world#next-steps"},{"project":"v2","title":"Application Structure","subheading":"","content":"A Spin application can contain multiple components. If more than one component is built from source, you should consider how to organise the application project.undefinedThe discussion on this page assumes that you know from the start that you are going to need to build multiple components. If you've already started a project, you may need to move some existing code around when you add your second built-from-source component. For information about this, see undefined or undefined.undefined","keywords":"structure","subsectionKeywords":"","url":"/v2/spin-application-structure"},{"project":"v2","title":"Application Structure","subheading":"Recommended Application Structure","content":"If we start with a blank canvas and use the http-empty template we will get a new Spin application:$ spin new -t http-empty\nEnter a name for your new application: myapp\nDescription: My applicationThe above command will provide an empty structure, as shown below:└── myapp\n    └── spin.tomlTo add new components to the application, we simply move into the myapp directory and begin to add components using the spin add subcommand:$ spin add -t http-rust\nEnter a name for your new component: first-http-rust-component\nDescription: The first of many new components\nHTTP path: /first/...\n$ spin add -t http-rust\nEnter a name for your new component: second-http-rust-component\nDescription: The second of many new components\nHTTP path: /second/...After adding two new components, we can see the visual representation of our application. Notice the symmetry; there is no hierarchy or nesting of components:.\n├── first-http-rust-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n├── second-http-rust-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.tomlTo customize each of the two components, we can modify the lib.rs (Rust source code) of each component:use spin_sdk::http::{IntoResponse, Request, Response};\nuse spin_sdk::http_component;\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn handle_first_http_rust_component(req: Request) -> anyhow::Result<impl IntoResponse> {\n    println!(\"Handling request to {:?}\", req.header(\"spin-full-url\"));\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, First Component\")\n        .build())\n}#[http_component]\nfn handle_second_http_rust_component(req: Request) -> anyhow::Result<impl IntoResponse> {\n    println!(\"Handling request to {:?}\", req.header(\"spin-full-url\"));\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, Second Component\")\n        .build())\n}As an additional example of adding more components, let's add a new static file server component:$ spin add -t static-fileserver\nEnter a name for your new component: assets\nHTTP path: /static/...\nDirectory containing the files to serve: assetsAfter the static file server component is added, we create the assets directory (our local directory containing the files to serve) and then add some static content into the assets directory to be served:$ mkdir assets\n$ cp ~/Desktop/my-static-image.jpg assets\n$ cp ~/Desktop/old.txt assets\n$ cp ~/Desktop/new.txt assetsundefinedWhy stop there? We can add even more functionality to our application. Let's now add a redirect component to redirect requests made to /static/old.txt and forward those through to /static/new.txt:$ spin add -t redirect\nEnter a name for your new component: additional-component-redirect\nRedirect from: /static/old.txt\nRedirect to: /static/new.txtWe now have 4 separate components scaffolded for us by Spin. Note the application manifest (the spin.toml file) is correctly configured based on our spin add commands:spin_manifest_version = 2\n\n[application]\nname = \"myapp\"\nversion = \"0.1.0\"\n\n[[trigger.http]]\nroute = \"/first/...\"\ncomponent = \"first-http-rust-component\"\n\n[component.first-http-rust-component]\nsource = \"first-http-rust-component/target/wasm32-wasi/release/first_http_rust_component.wasm\"\nallowed_outbound_hosts = []\n[component.first-http-rust-component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nworkdir = \"first-http-rust-component\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]\n\n[[trigger.http]]\nroute = \"/second/...\"\ncomponent = \"second-http-rust-component\"\n\n[component.second-http-rust-component]\nsource = \"second-http-rust-component/target/wasm32-wasi/release/second_http_rust_component.wasm\"\nallowed_outbound_hosts = []\n[component.second-http-rust-component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nworkdir = \"second-http-rust-component\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]\n\n[[trigger.http]]\nroute = \"/static/...\"\ncomponent = \"assets\"\n\n[component.assets]\nsource = { url = \"https://github.com/spinframework/spin-fileserver/releases/download/v0.1.0/spin_static_fs.wasm\", digest = \"sha256:96c76d9af86420b39eb6cd7be5550e3cb5d4cc4de572ce0fd1f6a29471536cb4\" }\nfiles = [ { source = \"assets\", destination = \"/\" } ]\n\n[[trigger.http]]\ncomponent = \"additional-component-redirect\"\nroute = \"/static/old.txt\"\n\n[component.additional-component-redirect]\nsource = { url = \"https://github.com/spinframework/spin-redirect/releases/download/v0.1.0/redirect.wasm\", digest = \"sha256:8bee959843f28fef2a02164f5840477db81d350877e1c22cb524f41363468e52\" }\nenvironment = { DESTINATION = \"/static/new.txt\" }Also, note that the application's folder structure, scaffolded for us by Spin via the spin add commands, is symmetrical and shows no nesting of components:├── assets\n│   ├── my-static-image.jpg\n│   ├── new.txt\n│   └── old.txt\n├── first-http-rust-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n├── second-http-rust-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.tomlThis is the recommended Spin application structure.","keywords":"","subsectionKeywords":"","url":"/v2/spin-application-structure#recommended-application-structure"},{"project":"v2","title":"Application Structure","subheading":"Next Steps","content":"undefinedundefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/spin-application-structure#next-steps"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Spin In Pods (Legacy)","content":"undefinedFor Kubernetes to run Spin workloads, it needs to be taught about a new runtime class. To do this, there is a shim for containerd. This compiles to a binary that must be placed on the Kubernetes nodes that host Shim pods. That binary then needs to be registered with Kubernetes as a new RuntimeClass. After that, wasm containers can be deployed to Kubernetes using the legacy Spin k8s plugin.","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#spin-in-pods-legacy"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Next Steps","content":"undefinedundefined{{ tabs \"platforms\" }}{{ startTab \"Azure AKS\"}}undefined","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#next-steps"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Setup Azure AKS for Spin","content":"","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#setup-azure-aks-for-spin"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Introduction","content":"Azure AKS provides a straightforward and officially undefined way to use Spin with AKS.","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#introduction"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Known Limitations","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#known-limitations"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Note for Rust","content":"In Cargo.toml, the spin-sdk dependency should be downgraded to v1.0.0-rc.1 in order to match the lower version running on the AKS shim.","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#note-for-rust"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Setup","content":"To get spin working on an AKS cluster, a few setup steps are required. First Add the aks-preview extension:$ az extension add --name aks-previewNext update to the latest version:$ az extension update --name aks-previewRegister the WasmNodePoolPreview feature:$ az feature register --namespace \"Microsoft.ContainerService\" --name \"WasmNodePoolPreview\"This will take a few minutes to complete. You can verify it’s done when this command returns undefined:$ az feature show --namespace \"Microsoft.ContainerService\" --name \"WasmNodePoolPreview\"Finally refresh the registration of the ContainerService:$ az provider register --namespace Microsoft.ContainerServiceOnce the service is registered, the next step is to add a Wasm/WASI nodepool to an existing AKS cluster. If a cluster doesn’t already exist, follow Azure’s undefined to create a new cluster:$ az aks nodepool add \\\n    --resource-group myResourceGroup \\\n    --cluster-name myAKSCluster \\\n    --name mywasipool \\\n    --node-count 1 \\\n    --node-vm-size Standard_B2s \\\n    --workload-runtime WasmWasiYou can verify the workloadRuntime using the following command:$ az aks nodepool show -g myResourceGroup --cluster-name myAKSCluster -n mywasipool --query workloadRuntimeThe next set of commands uses kubectl to create the necessary runtimeClass. If you don’t already have kubectl configured with the appropriate credentials, you can retrieve them with this command:$ az aks get-credentials -n myAKSCluster -g myResourceGroupFind the name of the nodepool:$ kubectl get nodes -o wideThen retrieve detailed information on the appropriate nodepool and verify among it’s labels is “kubernetes.azure.com/wasmtime-spin-v1=true”:kubectl describe node aks-mywasipool-12456878-vmss000000Find the wasmtime-spin-v1 RuntimeClass created by AKS:$ kubectl describe runtimeclass wasmtime-spin-v1{{ blockEnd }}{{ startTab \"Docker Desktop\"}}undefined","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#setup"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Setup Docker Desktop for Spin","content":"","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#setup-docker-desktop-for-spin"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Introduction","content":"Docker Desktop provides both undefined directly and its own Kubernetes option.","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#introduction"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Known Limitations","content":"undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#known-limitations"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Setup","content":"Install appropriate Preview Version of Docker Desktop+Wasm Technical Preview 2 from undefined. Then undefined for Docker in Settings → Experimental → Use containerd for pulling and storing images.Next Enable Kubernetes under Settings → Experimental → Enable Kubernetes, then hit “Apply & Restart”.Create a file wasm-runtimeclass.yml and populate with the following information:apiVersion: node.k8s.io/v1\nkind: RuntimeClass\nmetadata:\n  name: \"wasmtime-spin-v1\"\nhandler: \"spin\"Then register the runtime class with the cluster:$ kubectl apply -f wasm-runtimeclass.yaml","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#setup"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Using Docker Desktop With Spin","content":"Docker Desktop can be used with spin as a Kubernetes target per the instructions in the below in this document. However Docker can also run the containers directly with the following command:$ docker run --runtime=io.containerd.spin.v1 --platform=wasi/wasm -p <port>:<port> <image>:<version>If there is not command specified in the Dockerfile, one will need to be passed at the command line. Since Spin doesn't need this, \"/\" can be passed.{{ blockEnd }}{{ startTab \"K3d\"}}undefined","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#using-docker-desktop-with-spin"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Setup K8s for Spin","content":"","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#setup-k8s-for-spin"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Introduction","content":"undefined is a lightweight Kubernetes installation.","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#introduction"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Known Limitations","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#known-limitations"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Setup","content":"Ensure both Docker and k3d are installed. Then undefined for Docker in Settings → Experimental → Use containerd for pulling and storing images.Deis Labs provides a preconfigured K3d environment that can be run using this command:$ k3d cluster create wasm-cluster --image ghcr.io/deislabs/containerd-wasm-shims/examples/k3d:v0.10.0 -p \"8081:80@loadbalancer\" --agents 2 --registry-create mycluster-registry:12345Create a file wasm-runtimeclass.yml and populate with the following information:apiVersion: node.k8s.io/v1\nkind: RuntimeClass\nmetadata:\n  name: \"wasmtime-spin\"\nhandler: \"spin\"Then register the runtime class with the cluster:$ kubectl apply -f wasm-runtimeclass.yaml{{ blockEnd }}{{ startTab \"Generic Kubernetes\"}}undefined","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#setup"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Setup Generic Kubernetes for Spin","content":"","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#setup-generic-kubernetes-for-spin"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Introduction","content":"These instructions are provided for a self-managed or other Kubernetes service that isn't documented elsewhere.","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#introduction"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Known Limitations","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#known-limitations"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Setup","content":"We provide the undefined Helm chart that provides an automated method to install and configure the containerd shim for Fermyon Spin in Kubernetes. Please see the undefined in the installer repository for more information.The version of the container image and Helm chart directly correlates to the version of the containerd shim. We recommend selecting the shim version that correlates the version of Spin that you use for your application(s). For simplicity, here is a table depicting the version matrix between Spin and the containerd shim.| undefined              | undefined |\n| ------------------------------------------------------------- | ---------------------------------------------------------------------------------- |\n| undefined | undefined  |\n| undefined | undefined    |\n| undefined | undefined    |\n| undefined | undefined    |\n| undefined | undefined    |\n| undefined | undefined    |There are several values you may need to configure based on your Kubernetes environment. The installer needs to add a binary to the node's PATH and edit containerd's config.toml. The defaults we set are the same defaults for containerd and should work for most Kubernetes environments but you may need to adjust them if your distribution uses non-default paths.| Name                            | Default           | Description                                                              |\n| ------------------------------- | ----------------- | ------------------------------------------------------------------------ |\n| installer.hostEtcContainerdPath | /etc/containerd | Directory where containerd's config.toml is located                      |\n| installer.hostBinPath           | /usr/local/bin  | Directory where the shim binary should be installed to (must be on PATH) |undefined$ helm install fermyon-spin oci://ghcr.io/fermyon/charts/spin-containerd-shim-installer --version 0.8.0{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#setup"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Run a Spin Workload on Kubernetes","content":"","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#run-a-spin-workload-on-kubernetes"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Introduction","content":"This guide demonstrates the commands to run a Spin workload in Kubernetes. It should apply to all Kubernetes variants which have been properly configured using one of the Setup guides.","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#introduction"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Concepts","content":"Spin apps are bundled using the OCI format. These packages include the spin.toml file, and the wasm and static files which it references. While Kubernetes also uses OCI repositories, it expects the package to be in a container format.The containerd shim for Spin allows Kubernetes to appropriately schedule Spin applications as long as they have been wrapped in a lightweight “scratch” container.Once the Spin App Container has been created, it can be pushed to an OCI repository, and then deployed to an appropriately configured kubernetes cluster.","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#concepts"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Requirements","content":"The current Spin k8s plugin relies on Docker and Kubectl under the hood. It’s important that both of these tools be installed, the Docker service be running, and KUBECONFIG environment variable be configured to point to a kubeconfig file for the desired Kubernetes cluster.","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#requirements"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Install Plugin","content":"To install this plugin, run:spin plugin install -u https://raw.githubusercontent.com/chrismatteson/spin-plugin-k8s/main/k8s.jsonundefined","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#install-plugin"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Workflow","content":"The workflow is very similar to the normal Kubernetes workflow: build and test your application locally, push to a registry, and update the deployment.undefinedPlease see the undefined for a full tutorial on deploying Spin 2 applications.","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#workflow"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Detailed Explanation of Steps","content":"","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#detailed-explanation-of-steps"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"spin new","content":"An optional command to use a template to create a new Spin app:$ spin new","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#spin-new"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"spin build","content":"The following command builds a Spin app:spin build","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#spin-build"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Create the Deployment Manifest","content":"To create a deployment manifest (deploy.yaml), you can either:undefinedundefinedThe deploy.yaml file defines the deployment to the Kubernetes server. As you iterate with new versions of the registry image, you'll need to update the deployment manifest to match.In the deploy.yaml, the runtimeClassName undefined be defined as wasmtime-spin. It’s critical that that is the exact name used when setting up the Kubernetes service. spin k8s scaffold does this, and the example manifest below contains the correct name.undefinedThe following command creates a deployment manifest (deploy.yaml) for a Spin app to run on Kubernetes. Scaffold takes in a namespace as a mandatory argument. This can either be a username if using the Docker hub, or can be the entire address if using a separate repository such as ghcr.io:spin k8s scaffoldundefinedundefinedYou can find a sample manifest in the undefined or below.apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: test\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: test\n  template:\n    metadata:\n      labels:\n        app: test\n    spec:\n      runtimeClassName: wasmtime-spin\n      containers:\n        - name: test\n          image: chrismatteson/test:0.1.5\n          command: [\"/\"]\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: test\n  spec:\n    type: LoadBalancer\n    ports:\n      - protocol: TCP\n        port: 80\n        targetPort: 80\n    selector:\n      app: test\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: test\n  annotations:\n    ingress.kubernetes.io/ssl-redirect: \"false\"\nspec:\n  ingressClassName: traefik\n  rules:\n    - http:\n        paths:\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: test\n                port:\n                  number: 80","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#create-the-deployment-manifest"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"spin registry push","content":"The following command pushes the Spin application to the appropriate repository:$ spin registry push chrismatteson/test:0.1.5undefined","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#spin-registry-push"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"Deploy the Application","content":"The following command deploys the application to Kubernetes:$ kubectl apply -f deploy.yamlundefinedIt may take a few seconds for your application to be ready for use.","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#deploy-the-application"},{"project":"v2","title":"Spin In Pods (Legacy)","subheading":"spin k8s getsvc","content":"The following command retrieves information about the service that gets deployed (such as its external IP):$ spin k8s getsvc","keywords":"","subsectionKeywords":"","url":"/v2/spin-in-pods-legacy#spin-k8s-getsvc"},{"project":"v2","title":"SQLite Storage","subheading":"","content":"undefinedundefinedundefinedundefinedSpin provides an interface for you to persist data in an SQLite Database managed by Spin. This database allows Spin developers to persist relational data across application invocations.{{ details \"Why do I need a Spin interface? Why can't I just use my own external database?\" \"You can absolutely still use your own external database either with the undefined. However, if you're interested in quick, local relational storage without any infrastructure set-up then Spin's SQLite Database is a great option.\" }}","subsectionKeywords":"","url":"/v2/sqlite-api-guide"},{"project":"v2","title":"SQLite Storage","subheading":"Granting SQLite Database Permissions to Components","content":"By default, a given component of an app will not have access to any SQLite Databases. Access must be granted specifically to each component via the component manifest.  For example, a component could be given access to the default store using:[component.example]\nsqlite_databases = [\"default\"]undefined","keywords":"","subsectionKeywords":"","url":"/v2/sqlite-api-guide#granting-sqlite-database-permissions-to-components"},{"project":"v2","title":"SQLite Storage","subheading":"Using SQLite Storage From Applications","content":"The Spin SDK surfaces the Spin SQLite Database interface to your language.The set of operations is common across all SDKs:| Operation  | Parameters | Returns | Behavior |\n|------------|------------|---------|----------|\n| open  | name | connection  | Open the database with the specified name. If name is the string \"default\", the default database is opened, provided that the component that was granted access in the component manifest from spin.toml. Otherwise, name must refer to a store defined and configured in a undefined supplied with the application.|\n| execute | connection, sql, parameters | database records | Executes the SQL statement and returns the results of the statement. SELECT statements typically return records or scalars. INSERT, UPDATE, and DELETE statements typically return empty result sets, but may return values in some cases. The execute operation recognizes the undefined. |\n| close | connection | - | Close the specified connection. |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}Please note, we use serde in this Rust example, so please add serde as a dependency in your application's Cargo.toml file:[dependencies]\nserde = {version = \"1.0\", features = [\"derive\"]}\nserde_json = \"1.0\"undefinedSQLite functions are available in the spin_sdk::sqlite module. The function names match the operations above. For example:use anyhow::Result;\nuse serde::Serialize;\nuse spin_sdk::{\n    http::{Request, Response, IntoResponse},\n    http_component,\n    sqlite::{Connection, Value},\n};\n\n#[http_component]\nfn handle_request(req: Request) -> Result<impl IntoResponse> {\n    let connection = Connection::open_default()?;\n\n    let execute_params = [\n        Value::Text(\"Try out Spin SQLite\".to_owned()),\n        Value::Text(\"Friday\".to_owned()),\n    ];\n    connection.execute(\n        \"INSERT INTO todos (description, due) VALUES (?, ?)\",\n        execute_params.as_slice(),\n    )?;\n\n    let rowset = connection.execute(\n        \"SELECT id, description, due FROM todos\",\n        &[]\n    )?;\n\n    let todos: Vec<_> = rowset.rows().map(|row|\n        ToDo {\n            id: row.get::<u32>(\"id\").unwrap(),\n            description: row.get::<&str>(\"description\").unwrap().to_owned(),\n            due: row.get::<&str>(\"due\").unwrap().to_owned(),\n        }\n    ).collect();\n\n    let body = serde_json::to_vec(&todos)?;\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(body)\n        .build())\n}\n\n// Helper for returning the query results as JSON\n#[derive(Serialize)]\nstruct ToDo {\n    id: u32,\n    description: String,\n    due: String,\n}undefinedundefinedundefinedundefinedundefinedundefined{{ blockEnd }}{{ startTab \"Typescript\"}}undefinedTo use SQLite functions, use undefined to obtain undefined. SqliteConnection provides the execute method as described above. For example:import { ResponseBuilder, Sqlite } from \"@fermyon/spin-sdk\";\n\nexport async function handler(req: Request, res: ResponseBuilder) {\n    let conn = Sqlite.openDefault();\n    let result = conn.execute(\"SELECT * FROM todos WHERE id > (?);\", [1]);\n\n    res.send(JSON.stringify(result));\n}undefinedundefinedundefined{{ blockEnd }}{{ startTab \"Python\"}}undefinedTo use SQLite functions, use the sqlite module in the Python SDK. The undefined and undefined functions return a undefined. The connection object provides the undefined as described above. For example:from spin_sdk import http, sqlite\nfrom spin_sdk.http import Request, Response\nfrom spin_sdk.sqlite import ValueInteger\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        with sqlite.open_default() as db:\n            result = db.execute(\"SELECT * FROM todos WHERE id > (?);\", [ValueInteger(1)])\n            rows = result.rows\n        \n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(str(rows), \"utf-8\")\n        )undefinedundefinedundefinedundefined{{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedThe Go SDK is implemented as a driver for the standard library's undefined interface.package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\tspinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n\t\"github.com/fermyon/spin/sdk/go/v2/sqlite\"\n)\n\ntype Todo struct {\n\tID          string\n\tDescription string\n\tDue         string\n}\n\nfunc init() {\n\tspinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n\t\tdb := sqlite.Open(\"default\")\n\t\tdefer db.Close()\n\n\t\t_, err := db.Exec(\"INSERT INTO todos (description, due) VALUES (?, ?)\", \"Try out Spin SQLite\", \"Friday\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\trows, err := db.Query(\"SELECT id, description, due FROM todos\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tvar todos []*Todo\n\t\tfor rows.Next() {\n\t\t\tvar todo Todo\n\t\t\tif err := rows.Scan(&todo.ID, &todo.Description, &todo.Due); err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttodos = append(todos, &todo)\n\t\t}\n\t\tjson.NewEncoder(w).Encode(todos)\n\t})\n}\n\nfunc main() {}undefinedA convenience function sqlite.Open() is provided to create a database connection. Because the http.Handle function is inside the init() function the Spin SQLite driver cannot be initialized the same way as other drivers using undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/sqlite-api-guide#using-sqlite-storage-from-applications"},{"project":"v2","title":"SQLite Storage","subheading":"Preparing an SQLite Database","content":"Although Spin provides SQLite as a built-in database, SQLite still needs you to create its tables.  In most cases, the most convenient way to do this is to use the spin up --sqlite option to run whatever SQL statements you need before your application starts.  This is typically used to create or alter tables, but can be used for whatever other maintenance or troubleshooting tasks you need.You can run a SQL script from a file using the @filename syntax:spin up --sqlite @migration.sqlOr you can pass SQL statements directly on the command line as a (quoted) string:spin up --sqlite \"CREATE TABLE IF NOT EXISTS todos (id INTEGER PRIMARY KEY AUTOINCREMENT, description TEXT NOT NULL, due TEXT NOT NULL)\"As with runtime operations, this flag uses the undefined.You can provide the --sqlite flag more than once; Spin runs the statements (or files) in the order you provide them, and waits for each to complete before running the next.undefined","keywords":"","subsectionKeywords":"","url":"/v2/sqlite-api-guide#preparing-an-sqlite-database"},{"project":"v2","title":"SQLite Storage","subheading":"Custom SQLite Databases","content":"Spin defines a database named \"default\" and provides automatic backing storage.  If you need to customize Spin with additional databases, or to change the backing storage for the default database, you can do so via the --runtime-config-file flag and the runtime-config.toml file.  See undefined for details.","keywords":"","subsectionKeywords":"","url":"/v2/sqlite-api-guide#custom-sqlite-databases"},{"project":"v2","title":"SQLite Storage","subheading":"Granting Access to Custom SQLite Databases","content":"As mentioned above, by default, a given component of an app will not have access to any SQLite Databases. Access must be granted specifically to each component via the component manifest, using the component.sqlite_databases field in the manifest.Components can be given access to different databases, and may be granted access to more than one database. For example:# c1 has no access to any databases\n[component.example]\nname = \"c1\"\n\n# c2 can use the default database, but no custom databases\n[component.example]\nname = \"c2\"\nsqlite_databases = [\"default\"]\n\n# c3 can use the custom databases \"marketing\" and \"sales\", which must be\n# defined in the runtime config file, but cannot use the default database\n[component.example]\nname = \"c3\"\nsqlite_databases = [\"marketing\", \"sales\"]","keywords":"","subsectionKeywords":"","url":"/v2/sqlite-api-guide#granting-access-to-custom-sqlite-databases"},{"project":"v2","title":"Creating Spin templates","subheading":"","content":"undefinedundefinedundefinedundefinedSpin templates allow a Spin developer to quickly create the skeleton of an\napplication or component, ready for the application logic to be filled in.A template consists of two directories, content and metadata.undefinedundefinedFor examples of the directory contents, see the templates directory in the\nundefined.Templates must always be shared in a templates directory.  This allows the\ninstaller to locate them in repos that contain other content.","subsectionKeywords":"","url":"/v2/template-authoring"},{"project":"v2","title":"Creating Spin templates","subheading":"Authoring the Content","content":"Copy all the files that you want to be copied as part of the template into\nthe content directory. If you do nothing more, they will be copied\nverbatim. Often, though, you'll want to allow the user to put their own\nvalues in - for example, a project name, or an HTTP route.To do this, replace the text you want the user to be able to substitute\nwith an expression of the form {{parameter-name}}, where parameter-name\nis an identifier of your choice.  undefined - see below.You can reuse a parameter in more than one place - it will be prompted only once and will get the same value in each place.You can also transform the user value by specifying a filter after a bar:\n{{parameter-name | filter-name}}.  This is particularly useful when you\nwant to conform to specific language conventions. The following filters\nare supported:| Name          | Effect |\n|---------------|--------|\n| kebab_case  | Transforms input into kebab case, e.g. My Application to my-application |\n| snake_case  | Transforms input into snake case, e.g. My Application to my_application |\n| pascal_case | Transforms input into Pascal case, e.g. my application to MyApplication |","keywords":"","subsectionKeywords":"","url":"/v2/template-authoring#authoring-the-content"},{"project":"v2","title":"Creating Spin templates","subheading":"Expression Syntax","content":"Content uses undefined. See the Liquid documentation for the available syntax and control tags.A common pitfall occurs because some entries in spin.toml, such as undefined, use the same double-brace syntax as Liquid does. If you want to generate a line such as my-secret = \"{{ secret }}\", you must escape the double braces, for example using the Liquid undefined. If you don't do this, Liquid will look for a template parameter called secret instead!","keywords":"","subsectionKeywords":"","url":"/v2/template-authoring#expression-syntax"},{"project":"v2","title":"Creating Spin templates","subheading":"Authoring the Manifest","content":"The template manifest is a TOML file. It must be named spin-template.toml:manifest_version = \"1\"\nid = \"my-application\"\ndescription = \"An application\"\ntags = [\"my-tag\"]\n\n[parameters]\n# Example parameter\nproject-name = { type = \"string\", prompt = \"Project name\" }undefinedundefinedundefinedundefinedThe parameters table is where you list the placeholders that you edited\ninto your content for the user to substitute. You should include an entry\nfor each parameter. The key is the parameter name, and the value a JSON\ndocument that contains at minimum a type and prompt.  type must\ncurrently be string.  prompt is displayed when prompting the user\nfor the value to substitute.The document may also have a default, which will be displayed to the user\nand can be accepted by pressing Enter. It may also specify constraints\non what the user is allowed to enter. The following constraints are\nsupported:| Key           | Value and usage |\n|---------------|-----------------|\n| pattern     | A regular expression. The user input must match the regular expression to be accepted. |","keywords":"","subsectionKeywords":"","url":"/v2/template-authoring#authoring-the-manifest"},{"project":"v2","title":"Creating Spin templates","subheading":"Supporting  spin add","content":"The spin add command lets users add your template as a new component in\nan existing application. If you'd like to support this, you'll need to\nadd a few items to your metadata.undefinedundefined| Key             | Value and usage |\n|-----------------|-----------------|\n| snippets      | A subtable with an entry named component, whose value is the name of the file containing the component manifest template. (Don't include the snippets directory prefix - Spin knows to look in the snippets directory.) |\n| skip_files    | Optional array of content files that should undefined be copied when running in \"add component\" mode. For example, if your template contains a spin.toml file, you should use this setting to exclude that, because you want to add a new entry to the existing file, not overwrite it. |\n| skip_parameters | Optional array of parameters that Spin should undefined prompt for when running in \"add component\" mode. For example, the HTTP templates don't prompt for the base path, because that's defined at the application level, not set on an individual component. |Here is an example add_component table from a HTTP template:[add_component]\nskip_files = [\"spin.toml\"]\nskip_parameters = [\"http-base\"]\n[add_component.snippets]\ncomponent = \"component.txt\"undefined","keywords":"","subsectionKeywords":"","url":"/v2/template-authoring#supporting-spin-add"},{"project":"v2","title":"Creating Spin templates","subheading":"Hosting Templates in Git","content":"You can publish templates in a Git repo.  The templates must be in the /templates\ndirectory, with a subdirectory per template.When a user installs templates from your repo, by default Spin looks for a tag\nto identify a compatible version of the templates.  This tag is of the\nform spin/templates/vX.Y, where X is the major version, and Y the minor\nversion, of the user's copy of Spin. For example, if the user is on\nSpin 0.3.1, templates will be installed from spin/templates/v0.3.  If this\ntag does not exist, Spin installs templates from HEAD.","keywords":"","subsectionKeywords":"","url":"/v2/template-authoring#hosting-templates-in-git"},{"project":"v2","title":"Testing Applications","subheading":"","content":"The undefined allows you to run tests, written in WebAssembly, against a Spin application (where all Spin and WASI APIs are configurable mocks).To use spin test you write test scenarios for your app in any language with WebAssembly component support, and mock out all interactions your app has with the outside world without requiring any code changes to the app itself. That means the code you test in development is the same code that runs in production.undefined","subsectionKeywords":"","url":"/v2/testing-apps"},{"project":"v2","title":"Testing Applications","subheading":"Prerequisites","content":"The example below uses the undefined and undefined(a cargo subcommand for building WebAssembly components).","keywords":"","subsectionKeywords":"","url":"/v2/testing-apps#prerequisites"},{"project":"v2","title":"Testing Applications","subheading":"Installing the Plugin","content":"To run spin test , you’ll first need to install the canary release of the plugin. As spin test matures, we’ll be making stable releases:spin plugin install -u https://github.com/spinframework/spin-test/releases/download/canary/spin-test.jsonThis will install the plugin which can be invoked with spin test.","keywords":"","subsectionKeywords":"","url":"/v2/testing-apps#installing-the-plugin"},{"project":"v2","title":"Testing Applications","subheading":"Creating App and Component","content":"First, create an empty Spin app, change into that app folder and then add a component inside it:$ spin new -t http-empty my-app --accept-defaults\n$ cd my-app/\n$ spin add -t http-rust my-component --accept-defaultsThe above commands will scaffold out the application in the following format:my-app/\n├── my-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.toml","keywords":"","subsectionKeywords":"","url":"/v2/testing-apps#creating-app-and-component"},{"project":"v2","title":"Testing Applications","subheading":"Creating a Test Suite","content":"There is currently first-class support for writing tests in Rust, but any language with support for writing WebAssembly components can be used as long as the fermyon:spin-test/test world is targeted. You can find the definition of this world undefined. For this example, we'll use Rust.We use cargo to create a test suite, and then change into our newly created tests directory:$ cargo new tests --lib\n$ cd testsAfter running the cargo new command we will have the following application structure:my-app/\n├── my-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n├── spin.toml\n└── tests\n    ├── Cargo.toml\n    └── src\n        └── lib.rsFrom within that test suite (from inside the tests directory), we then add the spin-test SDK reference:$ cargo add spin-test-sdk --git https://github.com/spinframework/spin-testThen, we open the Cargo.toml file from within in the tests directory and edit to add the crate-type of cdylib:[lib]\ncrate-type = [\"cdylib\"]The my-app/tests/Cargo.toml file will look like this after editing:[package]\nname = \"tests\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nspin-test-sdk = { git = \"https://github.com/spinframework/spin-test\", version = \"0.1.0\" }\n\n[lib]\ncrate-type = [\"cdylib\"]","keywords":"","subsectionKeywords":"","url":"/v2/testing-apps#creating-a-test-suite"},{"project":"v2","title":"Testing Applications","subheading":"Writing a Test","content":"Next, create a test that spin test can run as a compiled WebAssembly component.In this example, we will write some tests appropriate to a JSON API service for information about service users. Here are two such tests written in Rust using the undefined. The first test ensures that the Spin app responds properly to an HTTP request. The second test ensures that the Spin app responds properly when the user data is present in the key-value store - for testing purposes, simulated by inserting it into a \"virtual\" store.Open the my-app/tests/src/lib.rs file and fill it with the following content:use spin_test_sdk::{\n    bindings::{fermyon::spin_test_virt, wasi, wasi::http},\n    spin_test,\n};\n\n#[spin_test]\nfn send_get_request_without_key() {\n    // Perform the request\n    let request = http::types::OutgoingRequest::new(http::types::Headers::new());\n    request.set_path_with_query(Some(\"/\")).unwrap();\n    let response = spin_test_sdk::perform_request(request);\n\n    // Assert response status and body is 404\n    assert_eq!(response.status(), 404);\n}\n\n#[spin_test]\nfn send_get_request_with_invalid_key() {\n    // Perform the request\n    let request = http::types::OutgoingRequest::new(http::types::Headers::new());\n    request.set_path_with_query(Some(\"/x?123\")).unwrap();\n    let response = spin_test_sdk::perform_request(request);\n\n    // Assert response status and body is 404\n    assert_eq!(response.status(), 404);\n}\n\n#[spin_test]\nfn send_get_request_with_invalid_key_id() {\n    // Perform the request\n    let request = http::types::OutgoingRequest::new(http::types::Headers::new());\n    request.set_path_with_query(Some(\"/user?0\")).unwrap();\n    let response = spin_test_sdk::perform_request(request);\n\n    // Assert response status and body is 404\n    assert_eq!(response.status(), 404);\n}\n\n#[spin_test]\nfn cache_hit() {\n    let user_json = r#\"{\"id\":123,\"name\":\"Ryan\"}\"#;\n\n    // Configure the app's virtualised 'default' key-value store ready for the test\n    let key_value = spin_test_virt::key_value::Store::open(\"default\");\n    // Set a specific key with a specific value\n    key_value.set(\"123\", user_json.as_bytes());\n\n    // Make the request against the Spin app\n    let request = wasi::http::types::OutgoingRequest::new(wasi::http::types::Headers::new());\n    request.set_path_with_query(Some(\"/user?123\")).unwrap();\n    let response = spin_test_sdk::perform_request(request);\n\n    // Assert the response status and body\n    assert_eq!(response.status(), 200);\n    let body = response.body_as_string().unwrap();\n    assert_eq!(body, user_json);\n\n    // Assert the key-value store was queried\n    assert_eq!(\n        key_value.calls(),\n        vec![spin_test_virt::key_value::Call::Get(\"123\".to_owned())]\n    );\n}The following points are intended to unpack the above example for your understanding:undefinedundefinedundefinedThe tests above run inside of WebAssembly. Calls, such as Key Value storage and retrieval, never actually leave the WebAssembly sandbox. This means your tests are quick and reproducible as you don’t need to rely on running an actual web server, and you don’t need to ensure any of your app’s dependencies are running. Everything your app interacts with is mocked for you. The isolation benefits from this mocking mean that your application's actual data is never touched. There is also the added benefit of reproducibility whereby you never have to worry about leftover data from previous tests.","keywords":"","subsectionKeywords":"","url":"/v2/testing-apps#writing-a-test"},{"project":"v2","title":"Testing Applications","subheading":"Configure  spin-test","content":"Before you can run the test, you'll need to tell spin-test where your test lives and how to build it. You do this from inside our app’s manifest (the spin.toml file). We change back up into our application's root directory:$ cd ..Then we edit the my-app application's manifest (the spin.toml file) by adding the following block:[component.my-component.tool.spin-test]\nsource = \"tests/target/wasm32-wasi/release/tests.wasm\"\nbuild = \"cargo component build --release\"\nworkdir = \"tests\"","keywords":"","subsectionKeywords":"","url":"/v2/testing-apps#configure-spin-test"},{"project":"v2","title":"Testing Applications","subheading":"Updating the App to Pass the Tests","content":"This section provides configuration and business logic at the application level.","keywords":"","subsectionKeywords":"","url":"/v2/testing-apps#updating-the-app-to-pass-the-tests"},{"project":"v2","title":"Testing Applications","subheading":"Configure App Storage","content":"We are using Key Value storage in the application and therefore need to configure the list of allowed key_value_stores in our spin.toml file (in this case we are just using the default). Go ahead and paste the key_value_stores configuration directly inside the [component.my-component] section, as shown below:[component.my-component]\n...\nkey_value_stores = [\"default\"]\n...undefinedAfter editing, the whole my-app/spin.toml file will look like the following:spin_manifest_version = 2\n\n[application]\nname = \"my-app\"\nversion = \"0.1.0\"\nauthors = [\"Fermyon Engineering <engineering@fermyon.com>\"]\ndescription = \"\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"my-component\"\n\n[component.my-component]\nsource = \"my-component/target/wasm32-wasi/release/my_component.wasm\"\nallowed_outbound_hosts = []\nkey_value_stores = [\"default\"]\n[component.my-component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nworkdir = \"my-component\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]\n\n[component.my-component.tool.spin-test]\nsource = \"tests/target/wasm32-wasi/release/tests.wasm\"\nbuild = \"cargo component build --release\"\ndir = \"tests\"","keywords":"","subsectionKeywords":"","url":"/v2/testing-apps#configure-app-storage"},{"project":"v2","title":"Testing Applications","subheading":"Adding Business Logic","content":"The goal of tests is to ensure that the business logic in our application works as intended. We haven't yet updated our \"business logic\" frrom the \"Hello, Fermyon\" app. To make our new tests pass, copy and paste the following code into the application's source file (located at my-app/my-component/src/lib.rs):use spin_sdk::{\n    http::{IntoResponse, Request, Response, Method},\n    http_component,\n    key_value::Store,\n};\n\n#[http_component]\nfn handle_request(req: Request) -> anyhow::Result<impl IntoResponse> {\n    // Open the default key-value store\n    let store = Store::open_default()?;\n\n    let (status, body) = match *req.method() {\n        Method::Get => {\n            // Get the value associated with the request URI, or return a 404 if it's not present\n            match store.get(req.query())? {\n                Some(value) => {\n                    println!(\"Found value for the key {:?}\", req.query());\n                    (200, Some(value))\n                }\n                None => {\n                    println!(\"No value found for the key {:?}\", req.query());\n                    (404, None)\n                }\n            }\n        }\n        // No other methods are currently supported\n        _ => (405, None),\n    };\n    Ok(Response::new(status, body))\n}","keywords":"","subsectionKeywords":"","url":"/v2/testing-apps#adding-business-logic"},{"project":"v2","title":"Testing Applications","subheading":"Building and Running the Test","content":"With the application's configuration and business logic done, we're ready for our test to be run. We can do this by invoking spin-test from the application's root directory (my-app):$ spin build\n$ spin test\n\nrunning 4 tests\nNo value found for the key \"123\"\ntest request-with-invalid-key    ... ok\nFound value for the key \"123\"\ntest cache-hit                   ... ok\nNo value found for the key \"0\"\ntest request-with-invalid-key-id ... ok\nNo value found for the key \"\"\ntest request-without-key         ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 2.08s","keywords":"","subsectionKeywords":"","url":"/v2/testing-apps#building-and-running-the-test"},{"project":"v2","title":"Testing Applications","subheading":"Next Steps","content":"spin-test is still in the early days of development, so you’re likely to run into things that don’t quite work yet. We’d love to hear about your experience so we can prioritize which features and bugs to fix first. We’re excited about the future potential of using WebAssembly components for testing, and we look forward to hearing about your experiences as we continue the development of spin-test.You might also like to learn about spin doctor which is a command-line tool that detects and helps fix issues preventing applications from building and running. For more information see the undefined.","keywords":"","subsectionKeywords":"","url":"/v2/testing-apps#next-steps"},{"project":"v2","title":"Triggers","subheading":"","content":"undefinedundefinedA Spin undefined maps an event, such as an HTTP request or a Redis pub-sub message, to a component that handles that event.An application can contain multiple triggers.In Spin 2.2 and earlier, all triggers must be of the same type.  For example, an application can contain triggers for multiple HTTP routes, or for multiple Redis pub-sub channels, but not both.In Spin 2.3 and later, an application can contain triggers of different types.  For example, a single application can serve HTTP on one or more routes, and at the same time subscribe to one or more Redis pub-sub channels.undefined","subsectionKeywords":"","url":"/v2/triggers"},{"project":"v2","title":"Triggers","subheading":"Triggers and Components","content":"How events are specified depends on the type of trigger involved. For example, an undefined is specified by the route it handles. A undefined is specified by the schedule on which it runs. A undefined is specified by the channel it monitors. A trigger always, however, has a component field, specifying the component that handles matching events.  The component can be specified in two ways.","keywords":"","subsectionKeywords":"","url":"/v2/triggers#triggers-and-components"},{"project":"v2","title":"Triggers","subheading":"Mapping a Trigger to a Named Component","content":"An application manifest can define undefined components in the component section. Each component is a WebAssembly component file (or reference) plus the supporting resources it needs, and metadata such as build information. The component name is written as part of the TOML component declaration. For example:[component.checkout]  # The component's name is \"checkout\"\nsource = \"target/wasm32-wasi/release/checkout.wasm\"\nallowed_outbound_hosts = [\"https://payment-processing.example.com\"]\nkey_value_stores = [\"default\"]\n[component.checkout.build]\ncommand = \"cargo build --target wasm32-wasi --release\"To map a trigger to a named component, specify its name in the trigger's component field:[[trigger.http]]\nroute = \"/cart/checkout\"\ncomponent = \"checkout\"","keywords":"","subsectionKeywords":"","url":"/v2/triggers#mapping-a-trigger-to-a-named-component"},{"project":"v2","title":"Triggers","subheading":"Writing the Component Inside the Trigger","content":"Instead of writing the component in a separate section and referencing it by name, you can write it the same fields undefined in the trigger component field.  For example:# Using inline table syntax\n[[trigger.http]]\nroute = \"/cart/...\"\ncomponent = { source = \"dist/cart.wasm\" }\n\n# Nested table syntax\n[[trigger.http]]\nroute = \"/cart/...\"\n[trigger.http.component]\nsource = \"target/wasm32-wasi/release/checkout.wasm\"\nallowed_outbound_hosts = [\"payment-processing.example.com\"]These behave in the same way: the inline table syntax is more compact for short declarations, but the nested table syntax is easier to read when there are many fields or the values are long.","keywords":"","subsectionKeywords":"","url":"/v2/triggers#writing-the-component-inside-the-trigger"},{"project":"v2","title":"Triggers","subheading":"Choosing Between the Approaches","content":"These ways of writing components achieve the same thing, so which should you choose?Named components have the following advantages:undefinedundefinedInline components have the following advantages:undefinedundefinedIf you are not sure, or are not experienced, we recommend using named components at first, and adopting inline components as and when you find cases where you prefer them.","keywords":"","subsectionKeywords":"","url":"/v2/triggers#choosing-between-the-approaches"},{"project":"v2","title":"Triggers","subheading":"Setting Up Multiple Trigger Types","content":"In this section, we build an application that contains multiple triggers.Here is an example of creating an application with both HTTP and Redis triggers:# Start with an empty application\n$ spin new -t http-empty multiple-trigger-example\nDescription: An application that handles both HTTP requests and Redis messages\n# Change into to the application directory\n$ cd multiple-trigger-example\n# Add an HTTP trigger application\n$ spin add -t http-rust rust-http-trigger-example\nDescription: A Rust HTTP example\nHTTP path: /...\n# Add a Redis trigger application\n$ spin add -t redis-rust rust-redis-trigger-example\nDescription: A Rust redis example\nRedis address: redis://localhost:6379\nRedis channel: oneThe above spin new and spin add commands will scaffold a Spin manifest (spin.toml file) with the following triggers:spin_manifest_version = 2\n\n[application]\nname = \"multiple-trigger-example\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"An application that handles both HTTP requests and Redis messages\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"rust-http-trigger-example\"\n\n[component.rust-http-trigger-example]\nsource = \"rust-http-trigger-example/target/wasm32-wasi/release/rust_http_trigger_example.wasm\"\nallowed_outbound_hosts = []\n[component.rust-http-trigger-example.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nworkdir = \"rust-http-trigger-example\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]\n\n[application.trigger.redis]\naddress = \"redis://localhost:6379\"\n\n[[trigger.redis]]\nchannel = \"one\"\ncomponent = \"rust-redis-trigger-example\"\n\n[component.rust-redis-trigger-example]\nsource = \"rust-redis-trigger-example/target/wasm32-wasi/release/rust_redis_trigger_example.wasm\"\nallowed_outbound_hosts = []\n[component.rust-redis-trigger-example.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nworkdir = \"rust-redis-trigger-example\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]                             ","keywords":"","subsectionKeywords":"","url":"/v2/triggers#setting-up-multiple-trigger-types"},{"project":"v2","title":"Triggers","subheading":"Cron Trigger","content":"Spin has experimental support for creating and running components on a schedule. Please note that there are only working Cron Trigger app samples written in undefined and undefined at present.undefinedLet's look at how the undefined allows you to deploy an application that runs on a schedule. A Cron trigger maps a cron expression (a schedule) to a specific component. For example:[[trigger.cron]]\ncomponent = \"hello-cron\"\ncron_expression = \"1/2 * * * * *\"undefined","keywords":"","subsectionKeywords":"","url":"/v2/triggers#cron-trigger"},{"project":"v2","title":"Triggers","subheading":"Cron Trigger Expressions","content":"The expression is based on the crontab (cron table) syntax whereby each line is made up of 7 fields that represent the time to execute.#  ┌──────────── sec (0–59)\n#  |    ┌───────────── min (0–59)\n#  |    │  ┌───────────── hour (0–23)\n#  |    │  │  ┌───────────── day of month (1–31)\n#  |    │  │  │  ┌───────────── month (1–12)\n#  |    │  │  │  │  ┌───────────── day of week (0–6)\n#  |    │  │  │  │  |  ┌─────────────- year\n#  |    │  │  │  │  |  │\n#  |    │  │  │  │  |  │\n  1/30  *  *  *  *  *  * undefinedLet's look at a time-based workload inside a Rust application.","keywords":"","subsectionKeywords":"","url":"/v2/triggers#cron-trigger-expressions"},{"project":"v2","title":"Triggers","subheading":"Installing the Cron Trigger Plugin","content":"First, we install the plugin:spin plugins install --url https://github.com/spinframework/spin-trigger-cron/releases/download/canary/trigger-cron.json","keywords":"","subsectionKeywords":"","url":"/v2/triggers#installing-the-cron-trigger-plugin"},{"project":"v2","title":"Triggers","subheading":"Installing the Cron Trigger Template","content":"Then, we install the template:spin templates install --git https://github.com/spinframework/spin-trigger-cron","keywords":"","subsectionKeywords":"","url":"/v2/triggers#installing-the-cron-trigger-template"},{"project":"v2","title":"Triggers","subheading":"Creating the Application","content":"With the plugin and template installed, we create a new application:spin new -t cron-rust hello_cron --accept-defaults","keywords":"","subsectionKeywords":"","url":"/v2/triggers#creating-the-application"},{"project":"v2","title":"Triggers","subheading":"Inspecting the Source Code","content":"The Rust source code for this application is as follows:use spin_cron_sdk::{cron_component, Error, Metadata};\nuse spin_sdk::variables;\n\n#[cron_component]\nasync fn handle_cron_event(metadata: Metadata) -> Result<(), Error> {\n    let key = variables::get(\"something\").unwrap_or_default();\n    println!(\n        \"[{}] Hello this is me running every {}\",\n        metadata.timestamp, key\n    );\n    Ok(())\n}","keywords":"","subsectionKeywords":"","url":"/v2/triggers#inspecting-the-source-code"},{"project":"v2","title":"Triggers","subheading":"Building and Running the Application","content":"We can immediately run this pre-written (template) application and observe the time-driven execution:cd hello_cron\nspin build --up\n\nBuilding component hello-cron with `cargo build --target wasm32-wasi --release`\n\n...\n\nFinished building all Spin components\n[1715640447] Hello from a cron component\n[1715640449] Hello from a cron component\n[1715640451] Hello from a cron component\n[1715640453] Hello from a cron component\n[1715640455] Hello from a cron component\n[1715640457] Hello from a cron componentAs we can see from the above output, our application is now running and executing the function every two seconds without the need for any incoming requests or any intervention from users or other machines.If you would like to learn more about using the Spin Cron Trigger, please check out undefined and the undefined.","keywords":"","subsectionKeywords":"","url":"/v2/triggers#building-and-running-the-application"},{"project":"v2","title":"Troubleshooting Application Development","subheading":"","content":"","subsectionKeywords":"","url":"/v2/troubleshooting-application-dev"},{"project":"v2","title":"Troubleshooting Application Development","subheading":"Spin Doctor","content":"The spin doctor command detects problems that could stop your application building and running, and can help to fix them.  These include problems like invalid manifests, missing Wasm files, and missing tools.To troubleshoot using spin doctor, run the command:$ spin doctorundefinedSpin performs a series of checks on your application. If it finds a problem, it prints a description and, if possible, offers to fix it. Here's an example where a stray keystroke has messed up the version field in the application manifest:$ spin doctor\n📟 The Spin Doctor is in.\n🩺 Checking spin.toml...\n\n❗ Diagnosis: Manifest 'spin_manifest_version' must be \"1\", not \"11\"\n🩹 The Spin Doctor can help! Would you like to:\n> Set manifest version to \"1\"\n  Do nothing\n  See more details about the recommended changesIf spin doctor detects a problem it can fix, you can choose to accept the fix, skip it to fix manually later, or see more details before choosing.  If spin doctor can't fix the problem, it displays the problem so you can make your own decision about how to fix it.undefined","keywords":"","subsectionKeywords":"","url":"/v2/troubleshooting-application-dev#spin-doctor"},{"project":"v2","title":"Troubleshooting Application Development","subheading":"Spin Test","content":"The undefined allows you to write test scenarios for your application's business logic. For more information, see undefined","keywords":"","subsectionKeywords":"","url":"/v2/troubleshooting-application-dev#spin-test"},{"project":"v2","title":"Upgrade Spin","subheading":"","content":"undefinedundefinedundefined","subsectionKeywords":"","url":"/v2/upgrade"},{"project":"v2","title":"Upgrade Spin","subheading":"Are You on the Latest Version?","content":"The best way to know if you're on the latest version of Spin is to run spin --version:$ spin --versionYou can compare the output from the above command with the undefined listed in the Spin GitHub repository (which is also shown in the image below):undefined","keywords":"","subsectionKeywords":"","url":"/v2/upgrade#are-you-on-the-latest-version"},{"project":"v2","title":"Upgrade Spin","subheading":"Upgrade Spin","content":"Spin can be installed in many ways, and therefore the upgrade procedure can differ between users. Here are a few suggested ways to upgrade Spin to the latest version. If you're not sure how or where you installed your current version of Spin try using the which command on undefined and the where command on undefined, as shown below:{{ tabs \"os\" }}{{ startTab \"Linux\"}}$ which spin{{ blockEnd }}{{ startTab \"macOS\"}}$ which spin{{ blockEnd }}{{ startTab \"Windows\"}}$ where spin{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v2/upgrade#upgrade-spin"},{"project":"v2","title":"Upgrade Spin","subheading":"Installer","content":"If you originally followed the documentation's undefined, please revisit to reinstall.undefined/usr/local/bin/spin","keywords":"","subsectionKeywords":"","url":"/v2/upgrade#installer"},{"project":"v2","title":"Upgrade Spin","subheading":"Homebrew","content":"If you installed Spin using undefined please use the following commands to upgrade Spin.$ brew update\n$ brew upgrade fermyon/tap/spin","keywords":"","subsectionKeywords":"","url":"/v2/upgrade#homebrew"},{"project":"v2","title":"Upgrade Spin","subheading":"Cargo","content":"If you originally followed the documentation's undefined, please revisit to reinstall.undefined~/.cargo/bin/spin","keywords":"","subsectionKeywords":"","url":"/v2/upgrade#cargo"},{"project":"v2","title":"Upgrade Spin","subheading":"Source","content":"If you followed the documentation's undefined please revisit to reinstall.undefined~/spin/target/release/spin","keywords":"","subsectionKeywords":"","url":"/v2/upgrade#source"},{"project":"v2","title":"Upgrade Spin","subheading":"Troubleshooting","content":"If you have upgraded Spin and don't see the newer version, please consider the following.","keywords":"","subsectionKeywords":"","url":"/v2/upgrade#troubleshooting"},{"project":"v2","title":"Upgrade Spin","subheading":"Not Seeing the Latest Version?","content":"It may be possible that you have installed Spin undefined of the above methods. In this case, the Spin executable that runs is the one that is listed first in your PATH system variable.If you have upgraded Spin yet still see the old version using spin --version this can be due to the order of precedence in your PATH. Try echoing your path to the screen and checking to see whether the location of your intended Spin executable is listed before or after other pre-existing installation paths:echo $PATH\n/Users/my_user/.cargo/bin:/usr/local/binundefinedIn the above case, the undefined's installation will take precedence over the undefined's installation.In this case, you can either remove the Cargo installation of Spin using cargo uninstall spin-cli or update your system path to prioritize the Spin binary path that you prefer.","keywords":"","subsectionKeywords":"","url":"/v2/upgrade#not-seeing-the-latest-version"},{"project":"v2","title":"Building a URL Shortener With Spin","subheading":"","content":"undefinedundefinedundefined","subsectionKeywords":"","url":"/v2/url-shortener-tutorial"},{"project":"v2","title":"Building a URL Shortener With Spin","subheading":"A Simple URL Shortener Built With Spin","content":"This tutorial will walk you through building a Spin component that\nredirects short URLs to their configured destinations.\nIn essence, this is a simple HTTP component that returns a response that contains\nredirect information based on the user-defined routes.This is an evolving tutorial. As Spin allows building more complex components\n(through supporting access to services like databases), this tutorial will be\nupdated to reflect that.","keywords":"","subsectionKeywords":"","url":"/v2/url-shortener-tutorial#a-simple-url-shortener-built-with-spin"},{"project":"v2","title":"Building a URL Shortener With Spin","subheading":"Here Is One We Prepared Earlier","content":"The complete implementation for this tutorial undefined.First, our URL shortener allows users to configure their own final URLs —\ncurrently, that is done through a configuration file that contains multiple\n[[route]] entries, each containing the shortened path as source, and\nthe destination URL:[[route]]\nsource = \"/spin\"\ndestination = \"https://github.com/spinframework/spin\"\n\n[[route]]\nsource = \"/hype\"\ndestination = \"https://www.fermyon.com/blog/how-to-think-about-wasm\"Whenever a request for https://<domain>/spin is sent, our component will\nredirect to https://github.com/spinframework/spin. Now that we have a basic\nunderstanding of how the component should behave, let's see how to implement it\nusing Spin.First, we start with undefined:/// A Spin HTTP component that redirects requests \n/// based on the router configuration.\n#[http_component]\nfn redirect(req: Request) -> Result<Response> {\n    let router = Router::default()?;\n    router.redirect(req)\n}All the component does is create a new router based on the default configuration,\nthen use it to redirect the request. Let's see how the router is defined:#[derive(Debug, Deserialize, Serialize)]\npub struct Route {\n    pub source: String,\n    pub destination: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct Router {\n    #[serde(rename = \"route\")]\n    pub routes: Vec<Route>,\n}The Router structure is a Rust representation of the TOML configuration above.pub fn redirect(self, req: Request) -> Result<Response> {\n    // read the request path from the `spin-path-info` header\n    let path_info = req\n        .headers()\n        .get(\"spin-path-info\")\n        .expect(\"cannot get path info from request headers\");\n    // if the path is not present in the router configuration,\n    // return 404 Not Found.\n    let route = match self.path(path_info.to_str()?) {\n        Some(r) => r,\n        None => return not_found(),\n    };\n    // otherwise, return the redirect to the destination\n    let res = http::Response::builder()\n        .status(http::StatusCode::PERMANENT_REDIRECT)\n        .header(http::header::LOCATION, route.destination)\n        .body(None)?;\n    Ok(res)\n}The redirect function is straightforward — it reads the request path from the\nspin-path-info header (make sure to read the undefined\nfor an overview of the HTTP headers present in Spin components), selects the\ncorresponding destination from the router configuration, then sends the\nHTTP redirect to the new location.At this point, we can build and run the module with Spin:$ spin build\n$ spin upAnd the component can now handle incoming requests:# based on the configuration file, a request\n# to /spin should be redirected\n$ curl -i localhost:3000/spin\nHTTP/1.1 308 Permanent Redirect\nlocation: https://github.com/spinframework/spin\ncontent-length: 0\n# based on the configuration file, a request\n# to /hype should be redirected\n$ curl -i localhost:3000/hype\nHTTP/1.1 308 Permanent Redirect\nlocation: https://www.fermyon.com/blog/how-to-think-about-wasm\ncontent-length: 0\n# /abc is not present in the router configuration,\n# so this returns a 404.\n$ curl -i localhost:3000/abc\nHTTP/1.1 404 Not Found\ncontent-length: 9\n\nNot FoundundefinedWe can now undefined (together\nwith router configuration file):$ spin registry push ghcr.io/alyssa-p-hacker/url-shortener:v1\nPushed with digest sha256:3c408a1b29b3098286c7ea5ab22f47248ccfadcc63ad5596ca0d85e3f522c43dAnd now we can run the application directly from the registry:$ spin up -f ghcr.io/alyssa-p-hacker/url-shortener:v1\n\nServing http://127.0.0.1:3000\nAvailable Routes:\n  shortener: http://127.0.0.1:3000 (wildcard)","keywords":"","subsectionKeywords":"","url":"/v2/url-shortener-tutorial#here-is-one-we-prepared-earlier"},{"project":"v2","title":"Building a URL Shortener With Spin","subheading":"Conclusion","content":"In this tutorial we built a simple URL shortener as a Spin component.\nIn the future we will expand this tutorial by storing the router configuration\nin a database supported by Spin, and potentially create another component that\ncan be used to add new routes to the configuration.","keywords":"","subsectionKeywords":"","url":"/v2/url-shortener-tutorial#conclusion"},{"project":"v2","title":"Application Variables","subheading":"","content":"undefinedundefinedSpin supports dynamic application variables. Instead of being static, their values can be updated without modifying the application, creating a simpler experience for rotating secrets, updating API endpoints, and more.These variables are defined in a Spin application manifest (in the [variables] section), and their values can be set or overridden at runtime by an undefined. When running Spin locally, the variables provider can be undefined for secrets, undefined, or host environment variables.For information about configuring application variables providers, refer to the undefined.","subsectionKeywords":"","url":"/v2/variables"},{"project":"v2","title":"Application Variables","subheading":"Adding Variables to Your Applications","content":"Variables are added to an application under the top-level [variables] section of an application manifest (spin.toml). Each entry must either have a default value or be marked as required = true. “Required” entries must be undefined with a value.For example, consider an application which makes an outbound API call using a bearer token. To configure this using variables, you would:undefinedundefinedundefined[variables]\napi_token = { required = true }\napi_uri = { default = \"http://my-api.com\" }Variables are surfaced to a specific component by adding a [component.(name).variables] section to the component and referencing them within it. The [component.(name).variables] section contains a mapping of component variables and values. Entries can be static (like api_version below) or reference an updatable application variable (like token below) using undefined-inspired string templates. Only components that explicitly use variables in their configuration section will get access to them. This enables only exposing variables (such as secrets) to the desired components of an application.[component.(name).variables]\ntoken = \"\\{{ api_token }}\"\napi_uri = \"\\{{ api_uri }}\"\napi_version = \"v1\"When a component variable references an application variable, its value will dynamically update as the application variable changes. For example, if the api_token variable is provided using the undefined, it can be updated by changing the value in HashiCorp Vault. The next time the component gets the value of token, the latest value of api_token will be returned by the provider. See the undefined to learn how to use Spin's configuration SDKs to get configuration variables within applications.Variables can also be used in other sections of the application manifest that benefit from dynamic configuration. In these cases, the variables are substituted at application load time rather than dynamically updated while the application is running. For example, the allowed_outbound_hosts can be dynamically configured using variables as follows:[component.(name)]\nallowed_outbound_hosts = [ \"\\{{ api_uri }}\" ]All in all, an application manifest with api_token and api_uri variables and a component that uses them would look similar to the following:spin_manifest_version = 2\n\n[application]\nname = \"api-consumer\"\nversion = \"0.1.0\"\ndescription = \"A Spin app that makes API requests\"\n\n[variables]\napi_token = { required = true }\napi_uri = { default = \"http://my-api.com\" }\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"api-consumer\"\n\n[component.api-consumer]\nsource = \"app.wasm\"\n[component.api-consumer.variables]\ntoken = \"\\{{ api_token }}\"\napi_uri = \"\\{{ api_uri }}\napi_version = \"v1\"","keywords":"","subsectionKeywords":"","url":"/v2/variables#adding-variables-to-your-applications"},{"project":"v2","title":"Application Variables","subheading":"Using Variables From Applications","content":"The Spin SDK surfaces the Spin configuration interface to your language. The undefined consists of one operation:| Operation  | Parameters         | Returns             | Behavior |\n|------------|--------------------|---------------------|----------|\n| get      | Variable name      | Variable value      | Gets the value of the variable from the configured provider |To illustrate the variables API, each of the following examples makes a request to some API with a bearer token. The API URI, version, and token are all passed as application variables. The application manifest associated with the examples would look similar to the one described undefined.The exact details of calling the config SDK from a Spin application depends on the language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedThe interface is available in the spin_sdk::variables module and is named get.use spin_sdk::{\n    http::{IntoResponse, Method, Request, Response},\n    http_component, variables,\n};\n\n#[http_component]\nasync fn handle_api_call_with_token(_req: Request) -> anyhow::Result<impl IntoResponse> {\n    let token = variables::get(\"token\")?;\n    let api_uri = variables::get(\"api_uri\")?;\n    let version = variables::get(\"version\")?;\n    let versioned_api_uri = format!(\"{}/{}\", api_uri, version);\n    let request = Request::builder()\n        .method(Method::Get)\n        .uri(versioned_api_uri)\n        .header(\"Authorization\", format!(\"Bearer {}\", token))\n        .build();\n    let response: Response = spin_sdk::http::send(request).await?;\n    // Do something with the response ...\n    Ok(Response::builder()\n        .status(200)\n        .build())\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}undefinedimport { ResponseBuilder, Variables } from \"@fermyon/spin-sdk\";\n\nexport async function handler(req: Request, res: ResponseBuilder) {\n  let token = Variables.get(\"token\")\n  let apiUri = Variables.get(\"api_uri\")\n  let version = Variables.get(\"version\")\n  let versionedAPIUri = `${apiUri}/${version}`\n  let response = await fetch(\n    versionedAPIUri,\n    {\n      headers: {\n        'Authorization': 'Bearer ' + token\n      }\n    }\n  );\n  // Do something with the response ...\n  res.set({ \"Content-Type\": \"text/plain\" })\n  res.send(\"Used an API\")\n}{{ blockEnd }}{{ startTab \"Python\"}}undefinedThe variables module has a function called get(https://fermyon.github.io/spin-python-sdk/variables.html#spin_sdk.variables.get).from spin_sdk.http import IncomingHandler, Request, Response, send\nfrom spin_sdk import variables\n\nclass IncomingHandler(IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        token = variables.get(\"token\")\n        api_uri = variables.get(\"api_uri\")\n        version = variables.get(\"version\")\n        versioned_api_uri = f\"{api_uri}/{version}\"\n        headers = {\n            \"Authorization\": f\"Bearer {token}\"\n        }\n        response = send(Request(\"GET\", versioned_api_uri, headers, None))\n        # Do something with the response ...\n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(\"Used an API\", \"utf-8\")\n        ){{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedThe function is available in the github.com/fermyon/spin/sdk/go/v2/variables package and is named Get. See undefined for reference documentation.import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\n\tspinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n\t\"github.com/fermyon/spin/sdk/go/v2/variables\"\n)\n\nfunc init() {\n\tspinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n\t\ttoken, err := variables.Get(\"token\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tapiUri, err := variables.Get(\"api_uri\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tversion, err := variables.Get(\"version\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tversionedApiUri := fmt.Sprintf(\"%s/%s\", apiUri, version)\n\n\t\trequest, err := http.NewRequest(\"GET\", versionedApiUri, bytes.NewBuffer([]byte(\"\")))\n\t\trequest.Header.Add(\"Authorization\", \"Bearer \"+token)\n\t\tresponse, err := spinhttp.Send(request)\n\t\t// Do something with the response ...\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tfmt.Fprintln(w, \"Used an API\")\n\t})\n}\n\nfunc main() {}{{ blockEnd }}{{ blockEnd }}To build and run the application, we issue the following commands:# Build the application\n$ spin build\n# Run the application, setting the values of the API token and URI via the environment variable provider\n# using the `SPIN_VARIABLE` prefix (upper case is necessary as shown here)\n$ SPIN_VARIABLE_API_TOKEN=\"your-token-here\" SPIN_VARIABLE_API_URI=\"http://my-best-api.com\" spin upAssuming you have configured you application to use an API, to test the application, simply query\nthe app endpoint:$ curl -i localhost:3000\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 11\ndate: Wed, 31 Jul 2024 22:03:35 GMT\n\nUsed an API","keywords":"","subsectionKeywords":"","url":"/v2/variables#using-variables-from-applications"},{"project":"v2","title":"Writing Spin Applications","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedA Spin application consists of a set of WebAssembly (Wasm) undefined, and a undefined that lists those components with some data about when and how to run them.  This page describes how to write components, manifests, and hence applications.","subsectionKeywords":"","url":"/v2/writing-apps"},{"project":"v2","title":"Writing Spin Applications","subheading":"Writing an Application Manifest","content":"undefinedA Spin undefined is a undefined file that contains:undefinedundefinedundefinedundefinedBy convention, the Spin manifest file is usually called spin.toml.This example is the manifest for a simple HTTP application with a single trigger executed when the /hello endpoint is accessed:spin_manifest_version = 2\n\n# General identification information\n[application]\nname = \"spin-hello-world\"\nversion = \"1.0.0\"\ndescription = \"A simple application that returns hello world.\"\n\n# The application's sole trigger. This application responds to HTTP requests\n# on the path \"/hello\", and handles them using the \"hello\" component.\n[[trigger.http]]\nroute = \"/hello\"\ncomponent = \"hello\"\n\n# The \"hello\" component\n[component.hello]\ndescription = \"A simple component that returns hello world.\"\n# The Wasm module to run for the component\nsource = \"target/wasm32-wasi/release/helloworld.wasm\"\n# How to build the Wasm module from source\n[component.hello.build]\ncommand = \"cargo build --target wasm32-wasi --release\"You can look up the various fields in the undefined, but let's look at the key fields in more detail.","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#writing-an-application-manifest"},{"project":"v2","title":"Writing Spin Applications","subheading":"The  trigger  Fields","content":"An application contains one or more undefined.  Each trigger specifies a type, an event of that type that the application responds to, and a component to handle that event.undefinedThe description above might sound a bit abstract. Let's clarify it with a concrete example. The most common trigger type is http, for which events are distinguished by the route. So an HTTP trigger might look like this:# double square brackets because there could be multiple 'trigger.http' tables\n[[trigger.http]]       # the type is part of the TOML \"section\"\nroute = \"/hello\"       # the route (event) that this trigger responds to\ncomponent = \"greeter\"  # the component to handle the triggerPut the type (http), event (route = \"/hello\"), and component (greeter) together, and this is saying \"when the application gets an HTTP request to /hello, respond to it using the greeter component.For more details about http triggers, see the undefined documentation.Another trigger type is redis, which is triggered by Redis pub-sub messages. For the redis type, the trigger event is specified by a pub-sub channel, e.g. channel = \"alerts\". See the undefined documentation for more information.Multiple triggers may refer to the same component. For example, you could have another trigger on /dober-dan which also invokes the greeter component.Some triggers have additional application-level configuration options.  For example, the HTTP trigger allows you to provide a base field, which tells Spin the \"root\" route to which all component routes are relative.  See the undefined and undefined documentation for more details.undefined","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#the-trigger-fields"},{"project":"v2","title":"Writing Spin Applications","subheading":"The Component Name","content":"Component names are identifier strings.  While not significant in themselves, they must be unique within the application.  Triggers use names to refer to components, and Spin uses the name in logging and error messages to tell you which component a message applies to.Each component is a TOML table, and the name is written as part of the table header. For example:[component.greeter]","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#the-component-name"},{"project":"v2","title":"Writing Spin Applications","subheading":"The Component  source","content":"Each component has a source field which tells Spin where to load the Wasm module from.For components that you are working on locally, set it to the file path to the compiled Wasm module file.  This must be a relative path from the directory containing spin.toml.[component.shopping-cart]\nsource = \"dist/cart.wasm\"For components that are published on the Web, provide a url field containing the URL of the Wasm module, and a digest field indicating the expected SHA256 hash of the module contents.  The digest must be prefixed with the string sha256:.  Spin uses the digest to check that the module is what you were expecting, and won't load the module if the content doesn't match.[component.asset-server]\nsource = { url = \"https://github.com/spinframework/spin-fileserver/releases/download/v0.0.1/spin_static_fs.wasm\", digest = \"sha256:650376c33a0756b1a52cad7ca670f1126391b79050df0321407da9c741d32375\" }Multiple components can have the same source.  An example is a document archive, where one component might serve user interface assets (CSS, images, etc.) on one route, while another serves the documents themselves on another route - both using the same file server module, but with different settings.","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#the-component-source"},{"project":"v2","title":"Writing Spin Applications","subheading":"Writing a Component Wasm Module","content":"undefinedAt the Wasm level, a Spin component is a Wasm component or module that exports a handler for the application trigger.  At the developer level, a Spin component is a library or program that implements your event handling logic, and uses Spin interfaces, libraries, or tools to associate that with the events handled by Spin.See the Language Guides section for how to do this in your preferred language. As an example, this is a component written in the Rust language. The hello_world function uses an attribute #[http_component] to identify the function as handling a Spin HTTP event. The function takes a Request and returns a anyhow::Result<impl IntoResponse>.use spin_sdk::http::{IntoResponse, Request, Response};\nuse spin_sdk::http_component;\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn hello_world(req: Request) -> anyhow::Result<impl IntoResponse> {\n    println!(\"Handling request to {:?}\", req.header(\"spin-full-url\"));\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, Fermyon\")\n        .build())\n}​​","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#writing-a-component-wasm-module"},{"project":"v2","title":"Writing Spin Applications","subheading":"Creating an Application From a Template","content":"If you've installed the Spin templates for your preferred language, you can use them to get started without having to write a manifest or the boilerplate code yourself.  To do this, run the spin new command, and choose the template that matches the type of application you want to create, and the language you want to use.{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}Choose the http-rust template to create a new HTTP application, or redis-rust to create a new Redis application.$ spin new\nPick a template to start your application with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-csharp (HTTP request handler using C# (EXPERIMENTAL))\n  http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n> http-rust (HTTP request handler using Rust)\n  http-swift (HTTP request handler using SwiftWasm)\n  http-zig (HTTP request handler using Zig)\n  redis-go (Redis message handler using (Tiny)Go)\n  redis-rust (Redis message handler using Rust)\n\nEnter a name for your new application: hello_rust\nProject description: My first Rust Spin application\nHTTP path: /...{{ blockEnd }}{{ startTab \"TypeScript\"}}Choose the http-ts or http-js template to create a new HTTP application, according to whether you want to use TypeScript or JavaScript.undefined$ spin new\nPick a template to start your application with:\n  http-js (HTTP request handler using Javascript)\n> http-ts (HTTP request handler using Typescript)\nEnter a name for your new application: hello_typescript\nProject description: My first TypeScript Spin application\nHTTP path: /...{{ blockEnd }}{{ startTab \"Python\"}}Choose the http-py template to create a new HTTP application.undefined$ spin new\nPick a template to start your application with:\n> http-py (HTTP request handler using Python)\nEnter a name for your new application: hello_python\nDescription: My first Python Spin application\nHTTP path: /...{{ blockEnd }}{{ startTab \"TinyGo\"}}Choose the http-go template to create a HTTP application, or redis-go to create a Redis application.$ spin new\nPick a template to start your application with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-empty (HTTP application with no components)\n> http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n  http-php (HTTP request handler using PHP)\n  http-rust (HTTP request handler using Rust)\nEnter a name for your new application: hello_go\nDescription: My first Go Spin application\nHTTP path: /...{{ blockEnd }}{{ blockEnd }}All of these templates create a manifest containing a single component, and the source code for a minimal \"hello world\" component.","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#creating-an-application-from-a-template"},{"project":"v2","title":"Writing Spin Applications","subheading":"Adding a New Component to an Application","content":"To add a new component to an existing application using a template, run the spin add command. This works in a very similar way to spin new, except that it expects the spin.toml file to already exist, and adds the details for the new component to that spin.toml.undefined","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#adding-a-new-component-to-an-application"},{"project":"v2","title":"Writing Spin Applications","subheading":"Including Files with Components","content":"You can include files with a component.  This means that:undefinedundefinedTo do this, use the files field in the component manifest:[component.asset-server]\nfiles = [ \"images/**/*.jpg\", { source = \"styles/dist\", destination = \"/styles\" } ]The files field is an array listing the files, patterns and directories you want to include. Each element of the array can be:undefinedundefinedIf your files list would match some files or directories that you undefined want included, you can use the exclude_files field to omit them.undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#including-files-with-components"},{"project":"v2","title":"Writing Spin Applications","subheading":"Adding Environment Variables to Components","content":"Environment variables can be provided to components via the Spin application manifest.To do this, use the environment field in the component manifest:[component.pet-info]\nenvironment = { PET = \"CAT\", FOOD = \"WATERMELON\" }The field accepts a map of environment variable key/value pairs. They are mapped inside the component at runtime.The environment variables can then be accessed inside the component. For example, in Rust:use spin_sdk::http::{IntoResponse, Request, Response};\nuse spin_sdk::http_component;\n\n#[http_component]\nfn handle_hello_rust(req: Request) -> anyhow::Result<impl IntoResponse> {\n    let response = format!(\"My {} likes to eat {}\", std::env::var(\"PET\")?, std::env::var(\"FOOD\")?);\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(response)\n        .build())\n}","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#adding-environment-variables-to-components"},{"project":"v2","title":"Writing Spin Applications","subheading":"Granting Networking Permissions to Components","content":"By default, Spin components are not allowed to make outgoing network requests.  This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing.To grant a component permission to make outbound requests to a particular address, use the allowed_outbound_hosts field in the component manifest. Each entry must comprise a host name or IP address undefined a port. For example:[component.talkative]\nallowed_outbound_hosts = [\"redis://redis.example.com:6379\", \"https://api.example.com:8080\"]If a port is specified, the component can make requests only to that port.  If no port is specified, the component can make requests only to the default port for the scheme (e.g. port 443 for the https scheme, port 5432 for the postgres scheme).  If you need to allow requests to undefined port, use the wildcard * (e.g. mysql://db.example.com:*).undefinedThe Wasm module can send network traffic undefined to the hosts specified in these two fields. Requests to other hosts (or other ports) will fail with an error.{{ details \"This feels like extra work! Why do I have to list the hosts?\" \"This comes from the Wasm principle of deny by default: the user of a component, rather than the component itself, should decide what resource it's allowed to access. But this isn't just an abstract principle: it's critical to being able to trust third party components. For example, suppose you add bad-boy-brians-totally-legitimate-file-server.wasm to your application. Unless you unwisely grant it network permissions, you can be undefined that it doesn't access your Postgres database or send information to evildoers.\" }}For development-time convenience, you can also pass the string \"*://*:*\" in the allowed_outbound_hosts collection.  This allows the component to make network requests to undefined host and on any port.  However, once you've determined which hosts your code needs, you should remove this string, and list the hosts instead.  Other Spin implementations may restrict host access, and may disallow components that ask to connect to anything and everything!","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#granting-networking-permissions-to-components"},{"project":"v2","title":"Writing Spin Applications","subheading":"Granting Storage Permissions to Components","content":"By default, Spin components are not allowed to access Spin's storage services.  This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing.  To grant a component permission to use a Spin-provided store, use the key_value_stores field in the component manifest:[component.squirrel]\nkey_value_stores = [ \"default\" ]See undefined for more information.","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#granting-storage-permissions-to-components"},{"project":"v2","title":"Writing Spin Applications","subheading":"Example Manifests","content":"This section shows some examples of Spin component manifests.","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#example-manifests"},{"project":"v2","title":"Writing Spin Applications","subheading":"Including a Directory of Files","content":"This example shows a Spin HTTP component that includes all the files in static/ under the application directory, made available to the Wasm module at the / path.[[trigger.http]]\nroute = \"/static/...\"\ncomponent = \"fileserver\"\n\n[component.fileserver]\nsource = \"modules/spin_static_fs.wasm\"\nfiles = [ { source = \"static/\", destination = \"/\" } ]","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#including-a-directory-of-files"},{"project":"v2","title":"Writing Spin Applications","subheading":"Using Public Components","content":"This is similar to the file server component above, but gets the Wasm module from a public release instead of a local copy.  Notice that the files are still drawn from a local path.  This is a way in which you can use off-the-shelf component logic with your own application data.[[trigger.http]]\nroute = \"/static/...\"\ncomponent = \"fileserver\"\n\n[component.fileserver]\nsource = { url = \"https://github.com/spinframework/spin-fileserver/releases/download/v0.0.1/spin_static_fs.wasm\", digest = \"sha256:650376c33a0756b1a52cad7ca670f1126391b79050df0321407da9c741d32375\" }\nfiles = [ { source = \"static/\", destination = \"/\" } ]","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#using-public-components"},{"project":"v2","title":"Writing Spin Applications","subheading":"Customizing the Executor","content":"This example shows an HTTP component whose Wasm module, instead of using the default Spin HTTP interface, uses the CGI-like WAGI (WebAssembly Gateway Interface) protocol. Spin can't work out the application model from the component, so the manifest needs to tell Spin to use WAGI instead of its default mode. It does this via the executor field. This is specific to the HTTP trigger so it goes under trigger.http.In addition, this module does not provide its WAGI functionality via the default _start entry point, but via a custom entry point named serve-wagi.  The executor table needs to tell Spin this via the entrypoint field.  Finally, this component needs to run the WAGI entry point with a specific set of command line arguments, which are expressed in the WAGI executor's argv field.[[trigger.http]]\nroute = \"/...\"\ncomponent = \"env\"\nexecutor = { type = \"wagi\", argv = \"test ${SCRIPT_NAME} ${ARGS} done\", entrypoint = \"serve-wagi\" }\n\n[component.env]\nsource = \"modules/env_wagi.wasm\"\nfiles = [ \"content/**/*\" , \"templates/*\", \"scripts/*\", \"config/*\"]","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#customizing-the-executor"},{"project":"v2","title":"Writing Spin Applications","subheading":"Setting the Redis Channel to Monitor","content":"The example shows a Redis component.  The manifest sets the channel field to say which channel the component should monitor.  In this case, the component is invoked for new messages on the messages channel.[[trigger.redis]]\nchannel = \"messages\"\ncomponent = \"echo-message\"\n\n[component.echo-message]\nsource = \"spinredis.wasm\"","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#setting-the-redis-channel-to-monitor"},{"project":"v2","title":"Writing Spin Applications","subheading":"Next Steps","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v2/writing-apps#next-steps"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedArtificial Intelligence (AI) Inferencing performs well on GPUs. However, GPU infrastructure is both scarce and expensive. This tutorial will show you how to use Fermyon Serverless AI to quickly build advanced AI-enabled serverless applications that can run on Fermyon Cloud. Your applications will benefit from 50 millisecond cold start times and operate 100x faster than other on-demand AI infrastructure services. Take a quick look at the video below to learn about executing inferencing on LLMs with no extra setup.In this tutorial we will:undefinedundefinedundefined","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Tutorial Prerequisites","content":"","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#tutorial-prerequisites"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Spin","content":"You will need to undefined. This tutorial requires Spin 3.0 or greater.If you already have Spin installed, undefined if required.","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#spin"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Dependencies","content":"The above installation script automatically installs the latest SDKs for Rust (which will enable us to write Serverless AI applications in Rust). However, some of the Serverless AI examples are written using TypeScript/Javascript, Python and TinyGo. To enable Serverless AI functionality via TypeScript/Javascript, Python and TinyGo, please ensure you have the latest TypeScript/JavaScript, Python or TinyGo template installed:undefined$ spin templates install --git https://github.com/spinframework/spin-js-sdk --upgradeundefinedEnsure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.Some of the Serverless AI examples are written using Python. To enable Serverless AI functionality via Python, please ensure you have the latest Python template installed:$ spin templates install --git https://github.com/spinframework/spin-python-sdk --upgradeundefinedSome of the Serverless AI examples are written using TinyGo. To enable Serverless AI functionality via TinyGo, please ensure you have the latest Spin template installed (the following command will make the http-go template available):$ spin templates install --git https://github.com/spinframework/spin --upgrade","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#dependencies"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Licenses","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#licenses"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Serverless AI Inferencing With Spin Applications","content":"Now, let's dive deep into a comprehensive tutorial and unlock your potential to use Fermyon Serverless AI.\nundefined The full source code with other examples can be found in our undefined","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#serverless-ai-inferencing-with-spin-applications"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Creating a New Spin Application","content":"{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}The Rust code snippets below are taken from the undefinedundefined$ spin new -t http-rust\nEnter a name for your new application: sentiment-analysis\nDescription: A sentiment analysis API that demonstrates using LLM inferencing and KV stores together\nHTTP path: /api/...{{ blockEnd }}{{ startTab \"TypeScript\" }}The TypeScript code snippets below are taken from the undefinedundefined$ spin new -t http-ts\nEnter a name for your new application: sentiment-analysis\nDescription: A sentiment analysis API that demonstrates using LLM inferencing and KV stores together\nHTTP path: /api/...{{ blockEnd }}{{ startTab \"Python\" }}The Python code snippets below are taken from the undefinedundefined$ spin new -t http-py\nEnter a name for your new application: sentiment-analysis\nDescription: A sentiment analysis API that demonstrates using LLM inferencing and KV stores together\nHTTP path: /api/...{{ blockEnd }}{{ startTab \"TinyGo\" }}undefined$ spin new -t http-go\nEnter a name for your new application: sentiment-analysis\nDescription: A sentiment analysis API that demonstrates using LLM inferencing and KV stores together\nHTTP path: /api/...{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#creating-a-new-spin-application"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Supported AI Models","content":"Fermyon's Spin and Serverless AI currently support:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#supported-ai-models"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Application Structure","content":"Next, we need to create the appropriate folder structure from within the application directory (alongside our spin.toml file). The code below demonstrates the variations in folder structure depending on which model is being used. Once the folder structure is in place, we then fetch the pre-trained AI model for our application:undefinedundefinedundefinedDownload the the *.safetensors, config.json and tokenizer.json from undefined and place it in the following structure below. The .spin directory needs to be placed in the root of the Spin project.tree .spin\n.spin\n└── ai-models\n    └── llama\n        └── llama2-chat\n            └── <*.safetensors files>\n            └── config.json\n            └── tokenizor.jsonundefinedundefinedDownload the *.safetensors, config.json and tokenizer.json from undefined and place it in the following structure below.tree .spin\n.spin\n└── ai-models\n    └── llama\n        └── codellama-instruct\n            └── <*.safetensors files>\n            └── config.json\n            └── tokenizor.jsonundefinedThe following section fetches a specific version of the undefined model:$ mkdir -p .spin/ai-models/all-minilm-l6-v2\n$ cd .spin/ai-models/all-minilm-l6-v2\n$ wget https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2/resolve/7dbbc90392e2f80f3d3c277d6e90027e55de9125/tokenizer.json\n$ wget https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2/resolve/0b6dc4ef7c29dba0d2e99a5db0c855c3102310d8/model.safetensorstree .spin\n.spin\n└── ai-models\n    └── all-minilm-l6-v2\n        ├── model.safetensors\n        └── tokenizer.jsonundefinedln -s ~/my-ai-models/ ~/application-one/.spin/ai-models","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#application-structure"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Application Configuration","content":"Then, we configure the [component.sentiment-analysis] section of our application's manifest (the spin.toml file); explicitly naming our model of choice. For example, in the case of the sentiment analysis application, we specify the llama2-chat value for our ai_models configuration, and add a default key-value store:undefined[component.sentiment-analysis]\n...\nai_models = [\"llama2-chat\"]\nkey_value_stores = [\"default\"]\n...","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#application-configuration"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Source Code","content":"Now let's use the Spin SDK to access the model from our app:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}The Rust source code for this sentiment analysis example uses serde. There are a couple of ways to add the required serde dependencies:undefinedundefinedserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"Once you have added serde, as explained above, modify your src/lib.rs file to match the following content:use std::str::FromStr;\n\nuse anyhow::Result;\nuse spin_sdk::{\n    http::{IntoResponse, Json, Params, Request, Response, Router},\n    http_component,\n    key_value::Store,\n    llm::{infer_with_options, InferencingModel::Llama2Chat},\n};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize)]\npub struct SentimentAnalysisRequest {\n    pub sentence: String,\n}\n\n#[derive(Serialize)]\npub struct SentimentAnalysisResponse {\n    pub sentiment: String,\n}\n\nconst PROMPT: &str = r#\"\\\n<<SYS>>\nYou are a bot that generates sentiment analysis responses. Respond with a single positive, negative, or neutral.\n<</SYS>>\n<INST>\nFollow the pattern of the following examples:\n\nUser: Hi, my name is Bob\nBot: neutral\n\nUser: I am so happy today\nBot: positive\n\nUser: I am so sad today\nBot: negative\n</INST>\n\nUser: {SENTENCE}\n\"#;\n\n/// A Spin HTTP component that internally routes requests.\n#[http_component]\nfn handle_route(req: Request) -> Response {\n    let mut router = Router::new();\n    router.any(\"/api/*\", not_found);\n    router.post(\"/api/sentiment-analysis\", perform_sentiment_analysis);\n    router.handle(req)\n}\n\nfn not_found(_: Request, _: Params) -> Result<impl IntoResponse> {\n    Ok(Response::new(404, \"Not found\"))\n}\n\nfn perform_sentiment_analysis(\n    req: http::Request<Json<SentimentAnalysisRequest>>,\n    _params: Params,\n) -> Result<impl IntoResponse> {\n    // Do some basic clean up on the input\n    let sentence = req.body().sentence.trim();\n    println!(\"Performing sentiment analysis on: {}\", sentence);\n\n    // Prepare the KV store\n    let kv = Store::open_default()?;\n\n    // If the sentiment of the sentence is already in the KV store, return it\n    if kv.exists(sentence).unwrap_or(false) {\n        println!(\"Found sentence in KV store returning cached sentiment\");\n        let sentiment = kv.get(sentence)?;\n        let resp = SentimentAnalysisResponse {\n            sentiment: String::from_utf8(sentiment.unwrap())?,\n        };\n        let resp_str = serde_json::to_string(&resp)?;\n\n        return Ok(Response::new(200, resp_str));\n    }\n    println!(\"Sentence not found in KV store\");\n\n    // Otherwise, perform sentiment analysis\n    println!(\"Running inference\");\n    let inferencing_result = infer_with_options(\n        Llama2Chat,\n        &PROMPT.replace(\"{SENTENCE}\", sentence),\n        spin_sdk::llm::InferencingParams {\n            max_tokens: 8,\n            ..Default::default()\n        },\n    )?;\n\n    println!(\"Inference result {:?}\", inferencing_result);\n\n    let sentiment = inferencing_result\n        .text\n        .lines()\n        .next()\n        .unwrap_or_default()\n        .strip_prefix(\"Bot:\")\n        .unwrap_or_default()\n        .parse::<Sentiment>();\n    println!(\"Got sentiment: {sentiment:?}\");\n\n    if let Ok(sentiment) = sentiment {\n        println!(\"Caching sentiment in KV store\");\n        let _ = kv.set(sentence, sentiment.as_str().as_bytes());\n    }\n\n    // Cache the result in the KV store\n    let resp = SentimentAnalysisResponse {\n        sentiment: sentiment\n            .as_ref()\n            .map(ToString::to_string)\n            .unwrap_or_default(),\n    };\n\n    let resp_str = serde_json::to_string(&resp)?;\n\n    Ok(Response::new(200, resp_str))\n}\n\n#[derive(Copy, Clone, Debug)]\nenum Sentiment {\n    Positive,\n    Negative,\n    Neutral,\n}\n\nimpl Sentiment {\n    fn as_str(&self) -> &str {\n        match self {\n            Self::Positive => \"positive\",\n            Self::Negative => \"negative\",\n            Self::Neutral => \"neutral\",\n        }\n    }\n}\n\nimpl std::fmt::Display for Sentiment {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.write_str(self.as_str())\n    }\n}\n\nimpl FromStr for Sentiment {\n    type Err = String;\n\n    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {\n        let sentiment = match s.trim() {\n            \"positive\" => Self::Positive,\n            \"negative\" => Self::Negative,\n            \"neutral\" => Self::Neutral,\n            _ => return Err(s.into()),\n        };\n        Ok(sentiment)\n    }\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}import { Llm, Kv } from \"@fermyon/spin-sdk\";\nimport { AutoRouter } from 'itty-router';\n\ninterface SentimentAnalysisRequest {\n  sentence: string;\n}\n\ninterface SentimentAnalysisResponse {\n  sentiment: \"negative\" | \"neutral\" | \"positive\";\n}\n\nconst decoder = new TextDecoder();\n\nconst PROMPT = `\\\n<<SYS>>\nYou are a bot that generates sentiment analysis responses. Respond with a single positive, negative, or neutral.\n<</SYS>>\n<INST>\nFollow the pattern of the following examples:\n\nHi, my name is Bob\nneutral\n\nI am so happy today\npositive\n\nI am so sad today\nnegative\n</INST>\n\n<SENTENCE>\n`;\n\nasync function performSentimentAnalysis(request: Request) {\n  // Parse sentence out of request\n  let data = await request.json() as SentimentAnalysisRequest;\n  let sentence = data.sentence;\n  console.log(\"Performing sentiment analysis on: \" + sentence);\n\n  // Prepare the KV store\n  let kv = Kv.openDefault();\n\n  // If the sentiment of the sentence is already in the KV store, return it\n  if (kv.exists(sentence)) {\n    console.log(\"Found sentence in KV store returning cached sentiment\");\n    return {\n      status: 200,\n      body: JSON.stringify({\n        sentiment: decoder.decode(kv.get(sentence)),\n      } as SentimentAnalysisResponse),\n    };\n  }\n  console.log(\"Sentence not found in KV store\");\n\n  // Otherwise, perform sentiment analysis\n  console.log(\"Running inference\");\n  let options: Llm.InferencingOptions = { maxTokens: 6 };\n  let inferenceResult = Llm.infer(\n    Llm.InferencingModels.Llama2Chat,\n    PROMPT.replace(\"<SENTENCE>\", sentence),\n    options\n  );\n  console.log(\n    `Inference result (${inferenceResult.usage.generatedTokenCount} tokens): ${inferenceResult.text}`\n  );\n  let sentiment = inferenceResult.text.split(/\\s+/)[0]?.trim();\n\n  // Clean up result from inference\n  if (\n    sentiment === undefined ||\n    ![\"negative\", \"neutral\", \"positive\"].includes(sentiment)\n  ) {\n    sentiment = \"neutral\";\n    console.log(\"Invalid sentiment, marking it as neutral\");\n  }\n\n  // Cache the result in the KV store\n  console.log(\"Caching sentiment in KV store\");\n  kv.set(sentence, sentiment);\n\n  return new Response(JSON.stringify({\n      sentiment,\n    } as SentimentAnalysisResponse),  { headers: { \"Content-Type\": \"application/json\" }});\n}\n\nlet router = AutoRouter();\n\n// Map the route to the handler\nrouter.post(\"/api/sentiment-analysis\", async (req) => {\n  console.log(`${new Date().toISOString()} POST /sentiment-analysis`);\n  return await performSentimentAnalysis(req);\n});\n\n//@ts-ignore\naddEventListener('fetch', async (event: FetchEvent) => {\n    event.respondWith(router.fetch(event.request));\n});{{ blockEnd }}{{ startTab \"Python\"}}from spin_sdk import http, llm, key_value\nfrom spin_sdk.http import Request, Response\nimport json\n\nPROMPT=\"\"\"<<SYS>>\nYou are a bot that generates sentiment analysis responses. Respond with a single positive, negative, or neutral.\n<</SYS>>\n[INST]\nFollow the pattern of the following examples:\n\nUser: Hi, my name is Bob\nBot: neutral\n\nUser: I am so happy today\nBot: positive\n\nUser: I am so sad today\nBot: negative\n\n[/INST]\nUser: \"\"\"\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        # Extracting the sentence from the request_body\n        request_body=json.loads(request.body)\n        sentence=request_body[\"sentence\"].strip()\n        print(\"Performing sentiment analysis on: \" + sentence)\n\n        # Open the default KV store\n        store = key_value.open_default()\n\n        # Check if the sentence is already in the KV store\n        if store.exists(sentence) is False:\n            result=llm.infer(\"llama2-chat\", PROMPT+sentence).text\n            print(\"Raw result: \" + result)\n            sentiment = get_sentiment_from_sentence(result)\n            print(\"Storing result in the KV store\")\n            store.set(sentence, str.encode(sentiment))\n        else:\n            sentiment = store.get(sentence).decode()\n            print(\"Found a cached result\")\n\n        response_body=json.dumps({\"sentiment\": sentiment})\n\n        return Response(200,\n                        {\"content-type\": \"application/json\"},\n                        bytes(response_body, \"utf-8\"))\n\ndef get_sentiment_from_sentence(sentence) -> str:\n    words = sentence.lower().split()\n    sentiments = [\"positive\", \"negative\", \"neutral\"]\n    result = next((word for word in sentiments if word in words), None)\n\n    if result is not None:\n        return result\n    else:\n        print(\"Inconclusive, returning 'neutral'\")\n        return \"neutral\"{{ blockEnd }}{{ startTab \"TinyGo\"}}package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\n\tspinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n\t\"github.com/fermyon/spin/sdk/go/v2/kv\"\n\t\"github.com/fermyon/spin/sdk/go/v2/llm\"\n)\n\ntype sentimentAnalysisRequest struct {\n\tSentence string\n}\n\ntype sentimentAnalysisResponse struct {\n\tSentiment string\n}\n\nconst prompt = `\\\nYou are a bot that generates sentiment analysis responses. Respond with a single positive, negative, or neutral.\nHi, my name is Bob\nneutral\nI am so happy today\npositive\nI am so sad today\nnegative\n<SENTENCE>\n`\n\nfunc init() {\n\tspinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n\t\trouter := spinhttp.NewRouter()\n\t\trouter.POST(\"/api/sentiment-analysis\", performSentimentAnalysis)\n\t\trouter.ServeHTTP(w, r)\n\t})\n}\n\nfunc performSentimentAnalysis(w http.ResponseWriter, r *http.Request, ps spinhttp.Params) {\n\tvar req sentimentAnalysisRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tfmt.Printf(\"Performing sentiment analysis on: %q\\n\", req.Sentence)\n\n\t// Open the KV store\n\tstore, err := kv.OpenStore(\"default\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer store.Close()\n\n\t// If the sentiment of the sentence is already in the KV store, return it\n\texists, err := store.Exists(req.Sentence)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif exists {\n\t\tfmt.Println(\"Found sentence in KV store returning cached sentiment\")\n\t\tvalue, err := store.Get(req.Sentence)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tres := sentimentAnalysisResponse{\n\t\t\tSentiment: string(value),\n\t\t}\n\t\tif err := json.NewEncoder(w).Encode(res); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n\tfmt.Println(\"Sentence not found in KV store\")\n\n\t// Otherwise, perform sentiment analysis\n\tfmt.Println(\"Running inference\")\n\tparams := &llm.InferencingParams{\n\t\tMaxTokens:   10,\n\t\tTemperature: 0.5,\n\t}\n\n\tresult, err := llm.Infer(\"llama2-chat\", strings.Replace(prompt, \"<SENTENCE>\", req.Sentence, 1), params)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Inference result (%d tokens): %s\\n\", result.Usage.GeneratedTokenCount, result.Text)\n\n\tvar sentiment string\n\tif fields := strings.Fields(result.Text); len(fields) > 0 {\n\t\tsentiment = fields[0]\n\t}\n\n\t// Cache the result in the KV store\n\tfmt.Println(\"Caching sentiment in KV store\")\n\tstore.Set(req.Sentence, []byte(sentiment))\n\n\tres := &sentimentAnalysisResponse{\n\t\tSentiment: sentiment,\n\t}\n\tif err := json.NewEncoder(w).Encode(res); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n\nfunc main() {}\n{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#source-code"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Additional Functionality","content":"This application also includes two more components, a key/value explorer and static-fileserver component. Let's quickly go ahead and create those (letting Spin do all of the scaffolding for us).","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#additional-functionality"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Static Fileserver Component For The UI","content":"We use the spin add command to add the new static-fileserver that we will name ui:$ spin add -t static-fileserver\nEnter a name for your new component: ui\nHTTP path [/static/...]: /...\nDirectory containing the files to serve [assets]: assets\n","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#static-fileserver-component-for-the-ui"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Add the Front-End","content":"We can add a webpage that asks the user for some text and does the sentiment analysis on it. In your assets folder, create two files dynamic.js and index.html.Here's the code snippet for index.html<!DOCTYPE html>\n<html data-theme=\"cupcake\">\n  <head>\n    <title>Sentiment Analyzer</title>\n    <meta name=\"description\" content=\"Perform sentiment analysis\" />\n\n    <!-- Tailwind and Daisy UI -->\n    <link\n      href=\"https://cdn.jsdelivr.net/npm/daisyui@3.2.1/dist/full.css\"\n      rel=\"stylesheet\"\n      type=\"text/css\"\n    />\n    <script src=\"https://cdn.tailwindcss.com?plugins=typography\"></script>\n\n    <!-- Import script to make page dynamic -->\n    <script src=\"dynamic.js\"></script>\n  </head>\n\n  <body class=\"bg-base-200\">\n    <div id=\"alert\" class=\"fixed top-20 inset-x-0 w-1/2 mx-auto\"></div>\n    <div class=\"flex flex-col min-h-screen\">\n      <div\n        class=\"sticky top-0 z-30 flex h-16 w-full justify-center bg-opacity-90 backdrop-blur transition-all duration-100 bg-base-100 text-base-content shadow-md\"\n      >\n        <nav class=\"navbar w-full\">\n          <div class=\"flex-1\">\n            <a href=\"/\" class=\"btn btn-ghost text-4xl font-bold\"\n              >Sentiment Analyzer</a\n            >\n          </div>\n          <div class=\"flex-none\">\n            <a href=\"\" class=\"btn btn-warning\">Restart</a>\n          </div>\n        </nav>\n      </div>\n      <main class=\"mx-auto my-10 prose\">\n        <p>\n          This Sentiment Analyzer is a demonstration of how you can use Fermyon\n          Serverless AI to easily make an AI-powered API. When you type in a\n          sentence it is sent to a Spin app running in the Fermyon Cloud,\n          inferencing is performed using the Fermyon serverless AI feature, and\n          the response is cached in a Fermyon key/value store.\n        </p>\n        <p>\n          Note that LLM's are not perfect and the sentiment analysis performed\n          by this application is not guaranteed to be perfect.\n        </p>\n        <p>\n          To get started type a sentence below and press\n          <kbd class=\"kbd kbd-sm\">enter</kbd>.\n        </p>\n\n        <div class=\"flex flex-col gap-8 w-full\">\n          <input\n            id=\"sentence-input\"\n            type=\"text\"\n            placeholder=\"Type the sentence you want to analyze here\"\n            class=\"input w-full\"\n          />\n          <div>\n            <button class=\"btn btn-primary\" onclick=\"newCard()\">Analyze</button>\n          </div>\n        </div>\n      </main>\n    </div>\n  </body>\n</html>Here's the code snippet for dynamic.js// Listen for the Enter key being pressed\ndocument.addEventListener(\"keydown\", function (event) {\n  if (event.keyCode === 13) {\n    newCard();\n  }\n});\n\nvar globalCardCount = 0;\nvar runningInference = false;\n\nfunction newCard() {\n  if (runningInference) {\n    console.log(\"Already running inference, please wait...\");\n    setAlert(\"Already running inference, please wait...\");\n    return;\n  }\n  var inputElement = document.getElementById(\"sentence-input\");\n  var sentence = inputElement.value;\n  if (sentence === \"\") {\n    console.log(\"Please enter a sentence to analyze\");\n    setAlert(\"Please enter a sentence to analyze\");\n    return;\n  }\n  inputElement.value = \"\";\n\n  var cardIndex = globalCardCount;\n  globalCardCount++;\n  var newCard = document.createElement(\"div\");\n  newCard.id = \"card-\" + cardIndex;\n  newCard.innerHTML = `\n    <div class=\"card bg-base-100 shadow-xl w-full\">\n        <div class=\"m-4 flex flex-col gap-2\">\n            <div>${sentence}</div>\n            <div class=\"flex flex-row justify-end\">\n                <span class=\"loading loading-dots loading-sm\"></span>\n            </div>\n        </div>\n    </div>\n    `;\n  document.getElementById(\"sentence-input\").before(newCard);\n\n  console.log(\"Running inference on sentence: \" + sentence);\n  runningInference = true;\n  fetch(\"/api/sentiment-analysis\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({ sentence: sentence }),\n  })\n    .then((response) => response.json())\n    .then((data) => {\n      console.log(data);\n      updateCard(cardIndex, sentence, data.sentiment);\n    })\n    .catch((error) => {\n      console.log(error);\n    });\n}\n\nfunction updateCard(cardIndex, sentence, sentiment) {\n  badge = \"\";\n  if (sentiment === \"positive\") {\n    badge = `<span class=\"badge badge-success\">Positive</span>`;\n  } else if (sentiment === \"negative\") {\n    badge = `<span class=\"badge badge-error\">Negative</span>`;\n  } else if (sentiment === \"neutral\") {\n    badge = `<span class=\"badge badge-ghost\">Neutral</span>`;\n  } else {\n    badge = `<span class=\"badge badge-ghost\">Unsure</span>`;\n  }\n  var cardElement = document.getElementById(\"card-\" + cardIndex);\n  cardElement.innerHTML = `\n    <div class=\"card bg-base-100 shadow-xl w-full\">\n        <div class=\"m-4 flex flex-col gap-2\">\n            <div>${sentence}</div>\n            <div class=\"flex flex-row justify-end\">\n                ${badge}\n            </div>\n        </div>\n    </div>\n    `;\n  runningInference = false;\n}\n\nfunction setAlert(msg) {\n  var alertElement = document.getElementById(\"alert\");\n  alertElement.innerHTML = `\n    <div class=\"alert alert-error\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"stroke-current shrink-0 h-6 w-6\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z\" /></svg>\n        <span class=\"text-error-content\">${msg}</span>\n    </div>\n    `;\n  setTimeout(function () {\n    alertElement.innerHTML = \"\";\n  }, 3000);\n}","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#add-the-front-end"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Key Value Explorer","content":"For this, we install use a pre-made template by pointing to the templates GitHub repository:$ spin templates install --git https://github.com/spinframework/spin-kv-explorerThen, we again use spin add to add the new component. We will name the component kv-explorer):$ spin add kv-explorer -t kv-explorer","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#key-value-explorer"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Application Manifest","content":"As shown below, the Spin framework has done all of the scaffolding for us:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}spin_manifest_version = 2\n\n[application]\nname = \"sentiment-analysis\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"A sentiment analysis API that demonstrates using LLM inferencing and KV stores together\"\n\n[[trigger.http]]\nroute = \"/api/...\"\ncomponent = \"sentiment-analysis\"\n\n[component.sentiment-analysis]\nsource = \"target/wasm32-wasip1/release/sentiment_analysis.wasm\"\nallow_outbound_hosts = []\nai_models = [\"llama2-chat\"]\nkey_value_stores = [\"default\"]\n[component.sentiment-analysis.build]\ncommand = \"cargo build --target wasm32-wasip1 --release\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"ui\"\n\n[component.ui]\nsource = { url = \"https://github.com/spinframework/spin-fileserver/releases/download/v0.3.0/spin_static_fs.wasm\", digest = \"sha256:ef88708817e107bf49985c7cefe4dd1f199bf26f6727819183d5c996baa3d148\" }\nfiles = [{ source = \"assets\", destination = \"/\" }]\n\n[[trigger.http]]\nroute = \"/internal/kv-explorer/...\"\ncomponent = \"kvv2\"\n\n[component.kv-explorer]\nsource = { url = \"https://github.com/spinframework/spin-kv-explorer/releases/download/v0.10.0/spin-kv-explorer.wasm\", digest = \"sha256:65bc286f8315746d1beecd2430e178f539fa487ebf6520099daae09a35dbce1d\" }\nallowed_outbound_hosts = [\"redis://*:*\", \"mysql://*:*\", \"postgres://*:*\"]\n# add or remove stores you want to explore here\nkey_value_stores = [\"default\"]{{ blockEnd }}{{ startTab \"Python\" }}spin_manifest_version = 2\n\n[application]\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"A sentiment analysis API that demonstrates using LLM inferencing and KV stores together\"\nname = \"sentiment-analysis\"\nversion = \"0.1.0\"\n\n[[trigger.http]]\nroute = \"/api/...\"\ncomponent = \"sentiment-analysis\"\n\n[component.sentiment-analysis]\nsource = \"app.wasm\"\nai_models = [\"llama2-chat\"]\nkey_value_stores = [\"default\"]\n[component.sentiment-analysis.build]\ncommand = \"componentize-py -w spin-http componentize app -o app.wasm\"\nwatch = [\"*.py\", \"requirements.txt\"]\n\n[[trigger.http]]\ncomponent = \"kv-explorer\"\nroute = \"/internal/kv-explorer/...\"\n\n[component.kv-explorer]\nsource = { url = \"https://github.com/spinframework/spin-kv-explorer/releases/download/v0.10.0/spin-kv-explorer.wasm\", digest = \"sha256:65bc286f8315746d1beecd2430e178f539fa487ebf6520099daae09a35dbce1d\" }\nallowed_outbound_hosts = [\"redis://*:*\", \"mysql://*:*\", \"postgres://*:*\"]\n# add or remove stores you want to explore here\nkey_value_stores = [\"default\"]\n\n[component.kv-explorer.variables]\nkv_credentials = \"{{ kv_explorer_user }}:{{ kv_explorer_password }}\"\n\n[variables]\nkv_explorer_user = { required = true }\nkv_explorer_password = { required = true }\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"ui\"\n\n[component.ui]\nsource = { url = \"https://github.com/spinframework/spin-fileserver/releases/download/v0.3.0/spin_static_fs.wasm\", digest = \"sha256:ef88708817e107bf49985c7cefe4dd1f199bf26f6727819183d5c996baa3d148\" }\nfiles = [{ source = \"assets\", destination = \"/\" }]{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#application-manifest"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Building and Deploying Your Spin Application","content":"undefined Running inferencing on localhost (your CPU) is not as optimal as deploying to Fermyon's Serverless AI (where inferencing is performed by high-powered GPUs). You can skip this spin build --up step and move straight to spin cloud deploy if you:undefinedundefinedNow, let's build and run our Spin Application locally. (undefined If you are following along with the TypeScript/JavaScript example, you will first need to run npm install. Otherwise, please continue to the following spin command.){{ tabs \"sdk-type\" }}{{ startTab \"Rust\" }}$ spin build --up{{ blockEnd }}{{ startTab \"Python\" }}$ python3 -m venv venv\n$ source venv/bin/activate\n$ pip3 install -r requirements.txt\n$ spin build --up{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#building-and-deploying-your-spin-application"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Test Locally","content":"# Create a new POST request to localhost\n$ curl -vXPOST 'localhost:3000/api/sentiment-analysis' -H'Content-Type: application/json' -d \"{\\\"sentence\\\": \\\"Well this is very nice indeed\\\" }\"\n\n{\"sentiment\":\"positive\"}","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#test-locally"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Deploy to Fermyon Cloud","content":"Deploying to the Fermyon Cloud is one simple command. If you have not logged into your Fermyon Cloud account already, the CLI will prompt you to login. Follow the instructions to complete the authorization process.$ spin cloud deploy","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#deploy-to-fermyon-cloud"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Testing in Fermyon Cloud","content":"# Create a new POST request to your apps URL in Fermyon Cloud\n$ curl -vXPOST 'https://abcxyz.fermyon.app/api/sentiment-analysis' -H'Content-Type: application/json' -d \"{\\\"sentence\\\": \\\"Well this is very nice indeed\\\" }\"\n\n{\"sentiment\":\"positive\"}","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#testing-in-fermyon-cloud"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Visit Fermyon Cloud UI","content":"Visiting your apps URL will produce a User Interface (UI) similar to the following.undefinedYou can type in a sentence, and the UI will respond with the sentiment analysis.undefined","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#visit-fermyon-cloud-ui"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Integrating Custom Domain and Storage","content":"The groundbreaking Fermyon Serverless AI introduces a revolutionary addition to the full-stack developer's arsenal. You can now seamlessly integrate the Fermyon undefined, undefined, and even your undefined with the launch of your very own advanced AI-enabled serverless applications.","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#integrating-custom-domain-and-storage"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Conclusion","content":"We want to get feedback on the Serverless AI API. We are curious about what models you would like to use and what applications you are building using Serverless AI. Let us know what you need, and how Fermyon's Serverless AI could potentially help solve a problem for you. We would love to help you write your new Serverless AI application.","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#conclusion"},{"project":"v3","title":"Sentiment Analysis With Serverless AI","subheading":"Next Steps","content":"undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/ai-sentiment-analysis-api-tutorial#next-steps"},{"project":"v3","title":"API Support Overview","subheading":"","content":"The following table shows the status of the interfaces Spin provides to applications.| Host Capabilities/Interfaces                 | Stability    |\n|----------------------------------------------|--------------|\n| undefined               | Stable       |\n| undefined             | Stable       |\n| undefined               | Experimental |\n| undefined             | Stable       |\n| undefined           | Stable       |\n| undefined       | Stable       |\n| undefined                | Experimental |\n| undefined                     | Experimental |\n| undefined    | Stabilizing  |\n| undefined   | Experimental |\n| undefined         | Experimental |\n| undefined             | Experimental |For more information about what is possible in the programming language of your choice, please see our undefined.","subsectionKeywords":"","url":"/v3/api-guides-overview"},{"project":"v3","title":"Building Spin Application Code","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedA Spin application is made up of one or more components. Components are binary Wasm modules; undefined refers to the process of converting your source code into those modules.undefinedBecause most compilers don't target Wasm by default, building Wasm modules often requires special command options, which you may not have at your fingertips.\nWhat's more, when developing a multi-component application, you may need to issue such commands for several components on each iteration.\nDoing this manually can be tedious and error-prone.To make the build process easier, the spin build command allows you to build all the components in one command.undefined","subsectionKeywords":"","url":"/v3/build"},{"project":"v3","title":"Building Spin Application Code","subheading":"Setting Up for  spin build","content":"To use spin build, each component that you want to build must specify the command used to build it in spin.toml, as part of its component.(name).build table:[component.hello]\n# This is the section you need for `spin build`\n[component.hello.build]\ncommand = \"npm run build\"If you generated the component from a Fermyon-supplied template, the build section should be set up correctly for you.  You don't need to change or add anything.undefined{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}For Rust applications, you must have the wasm32-wasip1 target installed:$ rustup target add wasm32-wasip1The build command typically runs cargo build with the wasm32-wasip1 target and the --release option:[component.hello.build]\ncommand = \"cargo build --target wasm32-wasip1 --release\"undefined{{ blockEnd }}{{ startTab \"TypeScript\" }}For JavaScript and TypeScript applications, you must have undefined.It's normally convenient to put the detailed build instructions in package.json. The build script looks like:{\n  \"scripts\": {\n    \"build\": \"knitwit --out-dir build/wit/knitwit --out-world combined && npx webpack --mode=production && npx mkdirp target && npx j2w -i dist.js -d combined-wit -n combined -o target/spin-http-js.wasm\"\n  }\n}{{ details \"Parts of the build script\" \"The build script calls out to undefined and j2w which is a script provided by the @fermyon/spin-sdk package that utilizes undefined. undefined is a utility that helps combine wit worlds \"}}The build command can then call the NPM script:[component.hello.build]\ncommand = \"npm run build\"{{ blockEnd }}{{ startTab \"Python\" }}Ensure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.For Python applications, you must have undefined installed:$ pip3 install componentize-pyThe build command then calls componentize-py on your application file:[component.hello.build]\ncommand = \"componentize-py -w spin-http componentize app -o app.wasm\"{{ blockEnd }}{{ startTab \"TinyGo\" }}For Go applications, you must use the TinyGo compiler, as the standard Go compiler does not yet support the WASI standard.  See the undefined.The build command calls TinyGo with the WASI backend and appropriate options:[component.hello.build]\ncommand = \"tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"{{ blockEnd }}{{ blockEnd }}undefined","keywords":"","subsectionKeywords":"","url":"/v3/build#setting-up-for-spin-build"},{"project":"v3","title":"Building Spin Application Code","subheading":"Running  spin build","content":"Once the build commands are set up, running spin build will execute, sequentially, each build command:$ spin build\nBuilding component hello with `cargo build --target wasm32-wasip1 --release`\n    Updating crates.io index\n    Updating git repository `https://github.com/spinframework/spin`\n\n    //--snip--\n\n    Compiling hello v0.1.0 (hello)\n    Finished release [optimized] target(s) in 39.05s\nFinished building all Spin componentsundefined","keywords":"","subsectionKeywords":"","url":"/v3/build#running-spin-build"},{"project":"v3","title":"Building Spin Application Code","subheading":"Running the Application After Build","content":"You can pass the --up option to spin build to start the application as soon as the build process completes successfully.This is equivalent to running spin up immediately after spin build.  It accepts all the same flags and options that up does.  See undefined for details.","keywords":"","subsectionKeywords":"","url":"/v3/build#running-the-application-after-build"},{"project":"v3","title":"Building Spin Application Code","subheading":"Overriding the Working Directory","content":"By default, the command to build a component is executed in the directory containing the spin.toml file. If a component's entire build source is under a subdirectory, it is often more convenient to build in that subdirectory rather than try to pass the path to the build command. You can do this by setting the workdir option in the component.(id).build table.For example, consider this Rust component located in subdirectory deep:.\n├── deep\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.tomlTo have the Rust build command run in directory deep, we can set the component's workdir:[component.deep.build]\n# `command` is the normal build command for this language\ncommand = \"cargo build --target wasm32-wasip1 --release\"\n# This tells Spin to run it in the directory of the build file (in this case Cargo.toml)\nworkdir = \"deep\"undefined","keywords":"","subsectionKeywords":"","url":"/v3/build#overriding-the-working-directory"},{"project":"v3","title":"Building Spin Application Code","subheading":"Next Steps","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/build#next-steps"},{"project":"v3","title":"Spin Internal Data Layout","subheading":"","content":"undefinedundefinedundefinedundefinedThis page describes how Spin lays out its internal data on disk.undefinedundefined","subsectionKeywords":"","url":"/v3/cache"},{"project":"v3","title":"Spin Internal Data Layout","subheading":"Base Directories","content":"Spin uses similar layouts across Linux, MacOS and Windows platforms, but the paths to various areas of the user's home directory differ across the platforms. On this page, the following terms have the following meanings:| Name          | Linux                                    | MacOS                                | Windows |\n|---------------------|------------------------------------------|--------------------------------------|-------------------|\n| DATA_DIR    | $XDG_DATA_HOME or $HOME/.local/share | $HOME/Library/Application Support, or $HOMEBREW_PREFIX/etc/fermyon-spin if installed using Homebrew  | %LOCALAPPDATA% or %USERPROFILE%\\AppData\\Local |\n| CACHE_DIR   | $XDG_CACHE_HOME or $HOME/.cache      | $HOME/Library/Caches               | %LOCALAPPDATA% or %USERPROFILE%\\AppData\\Local |These directories are based on the undefined, and specifically on the cross-platform implementation in the undefined.undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/cache#base-directories"},{"project":"v3","title":"Spin Internal Data Layout","subheading":"Plugins","content":"Installed plugins are stored in (DATA_DIR)/spin/plugins.  A snapshot of the plugins registry is also stored under that directory at (DATA_DIR)/spin/plugins/.spin-plugins; this is structured as a Git repository.undefinedIf you delete the plugins directory, you will no longer be able to run your plugins (until you reinstall them), but other Spin operations will be unaffected.","keywords":"","subsectionKeywords":"","url":"/v3/cache#plugins"},{"project":"v3","title":"Spin Internal Data Layout","subheading":"Templates","content":"Installed templates are stored in (DATA_DIR)/spin/templates.undefinedIf you delete the templates directory, you will lose access to your installed templates (until you reinstall them), but other Spin operations will be unaffected.","keywords":"","subsectionKeywords":"","url":"/v3/cache#templates"},{"project":"v3","title":"Spin Internal Data Layout","subheading":"Application Cache","content":"Downloaded application data, such as applications downloaded from registries or Wasm modules downloaded from URLs, are stored in (CACHE_DIR)/spin/registry.If you delete the application cache directory, Spin will automatically re-download the files as needed.  Spin operations will be otherwise unaffected.","keywords":"","subsectionKeywords":"","url":"/v3/cache#application-cache"},{"project":"v3","title":"Spin Internal Data Layout","subheading":"Inside the Application Cache","content":"undefinedThe application cache is divided into three subdirectories, data, manifests, and wasm.The data directory contains all static assets referenced from applications distributed with remote registries. The wasm directory contains all component sources referenced either in applications distributed with remote registries, or component sources from HTTP endpoints, directly referenced in spin.toml.undefinedThe manifests directory contains the registry manifests for entire apps distributed with remote registries. They are placed in subdirectories that identify the application based on the registry, repository, and digest (or tag).The following tree command shows a typical (abbreviated) cache directory:$ tree ~/Library/Caches/spin/registry/\n\n├── data\n│   ├── sha256:41a4649a8a8c176133792119cb45a7686767d3fa376ffd656e2ff76a6071fb07\n│   └── sha256:da3fda2db338a73483068072e22f7e7eef27afdbae3db824e130932adce703ba\n├── manifests\n│   └── ghcr.io\n│       └── radu-matei\n│           ├── hello-registries\n│           │   └── latest\n│           │       ├── config.json\n│           │       └── manifest.json\n│           └── spin-openai-demo\n│               └── v1\n│                   ├── config.json\n│                   └── manifest.json\n└── wasm\n    ├── sha256:0b985e7d43e719f34cbb54849759a2f8e7913c0f9b17bf7cb2b3d2458d33859e\n    └── sha256:d5f9e1f6b61b90f7404e3800285f7860fe2cfc7d0116023efc370adbb403fe87","keywords":"","subsectionKeywords":"","url":"/v3/cache#inside-the-application-cache"},{"project":"v3","title":"Contributing to Docs","subheading":"","content":"undefinedundefinedundefinedundefinedWe are delighted that you are interested in making our developer documentation better. Thank you! We welcome and appreciate contributions of all types — opening issues, fixing typos, adding examples, one-liner code fixes, tests, or complete features.Any contribution and interaction on any Fermyon project MUST follow our undefined. Thank you for being part of an inclusive and open community!Below are a few pointers designed to help you contribute.","keywords":"contribute contributing","subsectionKeywords":"","url":"/v3/contributing-docs"},{"project":"v3","title":"Contributing to Docs","subheading":"Technical Documentation Types","content":"The following points will help guide your contribution from a resource-type perspective; essentially we would really appreciate you creating and contributing any of the following 4 resource types.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#technical-documentation-types"},{"project":"v3","title":"Contributing to Docs","subheading":"1. Tutorials","content":"Tutorials are oriented toward learning. Tutorials are designed to get a user started on something new (that they have not tried before). You can think of a tutorial as a lesson i.e. teaching a Spin user undefined. The tutorial may contain many logically ordered steps i.e. installing Spin, installing Redis, using Spin templates, configuring a Spin application and so forth. The desired outcome for a tutorial is for the user to have a working deployment or application. Think of it as a lesson in how to bake a cake.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#1-tutorials"},{"project":"v3","title":"Contributing to Docs","subheading":"2. How-To Guides","content":"How-to guides are oriented towards showing a user how to solve a problem, which leads them to be able to achieve their own goal. The how-to guide will follow a series of logical steps. Think of it as providing a recipe for the user's creativity. For example, you can show a user how to undefined without telling them what the application must do; that is up to the user's imagination.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#2-how-to-guides"},{"project":"v3","title":"Contributing to Docs","subheading":"3. Reference","content":"Reference resources are merely a dry description; describing the feature in its simplest form. An example of a reference resource is the undefined. You will notice that the Manifest Reference page simply lists all of the manifest entries and available options.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#3-reference"},{"project":"v3","title":"Contributing to Docs","subheading":"4. Explanation","content":"An explanation resource is written using a deep-dive approach i.e. providing a deep explanation with the view to impart a deep understanding of a particular concept, feature or product. You may find your contribution is so in-depth that it becomes a long form article like a blog post. If that is the case, please get in touch and we can discuss options around getting your content published on another platform; like the undefined.undefinedYou will notice that the menu system is organized in terms of \"Tutorial\", \"How-To\", \"Reference\" and so forth. When you write your contribution please decide which product (Cloud, Spin, Bartholomew) category it falls into and also which resource type it aligns with. Armed with that information you can go ahead and create your new file. For example, your \"how-to\" resource on \"developing a Spin application\" in Fermyon cloud would be saved to the content/cloud/ folder; specifically, content/cloud/develop.md and the menu item (for the left-hand-side menu) would be added to the templates/cloud_sidebar.hbs file, as shown below.undefinedThe resulting output would be as follows.undefined","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#4-explanation"},{"project":"v3","title":"Contributing to Docs","subheading":"Documents Relevant to Two or More Projects","content":"If a document is relevant to two or more projects, the dynamic body feature of bartholomew is to be used. Create the document in one of the projects with the content. In the other project(s) create a file with only the frontmatter. Then add the following field to the frontmatter:.\n.\nbody_source = \"<path to the content>\"\n\n[extra]\nThe value for the body_source key, should be the path from which the content is being shared (relative to the repository's content folder). For example if the Spin project's developer/content/spin/v3/contributing-docs.md holds the sharable content (as the single source of truth), then the Cloud project can display that same content by using the following frontmatter:title = \"Contributing to Docs\"\ntemplate = \"cloud_main\"\ndate = \"2023-11-04T00:00:01Z\"\nbody_source = \"/spin/v3/contributing-docs\"\n\n[extra]\nurl = \"https://github.com/spinframework/spin-docs/blob/main/content/cloud/contributing-docs.md\"\nkeywords = \"contribute contributing\"\n\n---undefined","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#documents-relevant-to-two-or-more-projects"},{"project":"v3","title":"Contributing to Docs","subheading":"Technical Documentation Procedure (Video)","content":"","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#technical-documentation-procedure-video"},{"project":"v3","title":"Contributing to Docs","subheading":"Technical Documentation Procedure (Text)","content":"","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#technical-documentation-procedure-text"},{"project":"v3","title":"Contributing to Docs","subheading":"1. Fork the Repository","content":"The first step is to fork the undefined, from Fermyon's GitHub, to your own GitHub account.undefinedEnsure that you are forking the developer repository undefined GitHub account; where you have full editing privileges.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#1-fork-the-repository"},{"project":"v3","title":"Contributing to Docs","subheading":"2. Clone the Fork","content":"Copy the URL from the UI in readiness for running the git clone command.undefinedGo ahead and clone the new fork that you just created (the one which resides in your own GitHub account):$ cd ~\n$ git clone git@github.com:yourusername/developer.git\n$ cd developer","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#2-clone-the-fork"},{"project":"v3","title":"Contributing to Docs","subheading":"3. Create New Branch","content":"Create a new branch that will house all of your changes for this specific contribution:$ git checkout -b my_new_branch","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#3-create-new-branch"},{"project":"v3","title":"Contributing to Docs","subheading":"4. Add Upstream","content":"Create a new remote for the upstream (a pointer to the original repository to which you are contributing):$ git remote add upstream https://github.com/fermyon/developer","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#4-add-upstream"},{"project":"v3","title":"Contributing to Docs","subheading":"5. Code Blocks, Annotations and Table of Contents (ToC)","content":"It is highly recommended that you use either the <!-- @selectiveCpy --> or the <!-- @nocpy --> annotation before each of your code blocks, and that each code block defines the appropriate undefined. The annotation can be skipped for code blocks with example code snippets i.e. non-terminal or generic output examples.undefinedThe selective copy annotation (<!-- @selectiveCpy -->) is intended for use when communicating code and/or CLI commands for the reader to copy and paste. The selective copy annotation allows the reader to see the entire code block (both commands and results) but only copies the lines that start with $ into the reader's clipboard (minus the $) when the user clicks the copy button. For example, copying the following code block will only copy echo \"hello\" into your clipboard, for pasting.$ echo \"hello\"\nhelloundefinedundefinedThe no copy annotation (<!-- @nocpy -->) precedes a code block where no copy and pasting of code is intended. If using the no copy attribute please still be sure to add the appropriate syntax highlighting to your code block (for display purposes). For example:undefinedPlease find copyable snippet below, for your convenience:<!-- @nocpy -->\n\n```text\nSome generic code not intended for copying/pasting\n```The above markdown will render the following code block on the web page:Some generic code not intended for copying/pastingundefined - just a straight copy without any additional features.If you want the code in a code block to be copyable with no \"smarts\" to remove the $ then you can just simply leave out the annotation altogether. A code block in markdown will be copyable without smarts just as is.undefinedMulti-tab code blocks undefined. Examples can be seen in the undefined and undefined. The above examples demonstrate how tabs can either represent platforms i.e. Windows, Linux and macOS or represent specific programming languages i.e. Rust, JavaScript and Golang etc. Here is a brief example of how to implement multi-tab code blocks when writing technical documentation for this site, using markdown.The first step to implementing multi-tab code blocks is placing the enable_shortcodes = true configuration at the start of the .md file. Specifically, in the .md file's frontmatter.The markup to create tabs in markdown is as follows{{ tabs \"os\" }}\n\n{{ startTab \"Windows\"}}\n\nTo list files on windows use `dir`\n\n<!-- @selectiveCpy -->\n\n\\`\\`\\`bash\n$ dir hello_fermyon\n\\`\\`\\`\nand script in windows have the extension `.bat`\n\n<!-- @nocpy -->\n\n\\`\\`\\`bash\nhello.bat\ntest.bat\n\\`\\`\\`\n\n{{ blockEnd }}\n\n{{ startTab \"Linux\"}}\n\nTo list files on linux use `ls`\n\n<!-- @selectiveCpy -->\n\n\\`\\`\\`bash\n$ ls\n\\`\\`\\`\n\nand script in linux have the extension `.sh`\n\n<!-- @nocpy -->\n\n\\`\\`\\`bash\nhello.sh\ntest.sh\n\\`\\`\\`\n\n{{ blockEnd }}\n{{ blockEnd }}undefined: Existing documentation will already be using class names for code block tabs and startTab i.e. {{ tabs \"os\" }} and {{ startTab \"Windows\"}} respectively. Please consult the following tabs and startTab class names that are already in use (before creating your own). If you need to create a new class name (because one does not already exist) please add it to the list below as part of the pull request that contains your code block contribution.undefined:undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedThe next section covers the highly recommended use of ToCs.undefinedIf you create content with many headings it is highly recommended to place a ToC in your markdown file. There are excellent extensions (such as this Visual Studio Code Extension called undefined which will automatically generate your ToC).","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#5-code-blocks-annotations-and-table-of-contents-toc"},{"project":"v3","title":"Contributing to Docs","subheading":"6.1 Checking Your Content - Using NPM","content":"Once you are satisfied with your contribution, you can programmatically check your content.If you have not done so already, please go ahead and perform the npm ci (npm clean install) command; to enable Node dependencies such as markdownlint-cli2. Simply run the following command, from the root of the developer repository:$ npm ciOn top of the Node dependencies the timeout executable must be installed on your system and added to the PATH environment variable. The timeout executable is included in the undefined which should be present in most Linux distributions.On macOS you can install the timeout binary using the Homebrew package manager as shown below:$ brew install coreutilsHaving all dependencies installed, you can now check for broken links (which takes several minutes) and also lint your markdown files. Simply run the following command, from the root of the developer repository:$ npm run testundefined Optionally you can run only the linter with the following command:# Example of how to lint all Markdown files in a local folder (in this case the spin folder) \nnpx markdownlint-cli2 content/spin/*.md \\\"#node_modules\\\"\n# Example of how to lint a local Markdown file\nnpx markdownlint-cli2 content/spin/install.md \\\"#node_modules\\\"undefined Whilst the npm run test command (which lints and also programmatically checks all URLs) does take extra time to complete it undefined be utilized before you undefined; preventing the potential pushing of broken URLs to the developer documentation site.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#61-checking-your-content---using-npm"},{"project":"v3","title":"Contributing to Docs","subheading":"6.2 Indexing Your Content","content":"The developer documentation site implements in-house search. A new index is automatically generated for you when your contribution is merged into the developer documentation repository. This is done via a GitHub action. The following section explains how to alter content to increase search visibility for your content.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#62-indexing-your-content"},{"project":"v3","title":"Contributing to Docs","subheading":"6.3 Increasing Search Visibility For Your Content","content":"The built-in search functionality is based on the indexing of individual words in each markdown file, which works well most of the time. However, there are a couple of scenarios where you undefined want to deliberately increase search visibility for your content.undefinedWords in a documentation markdown file may not be words that are searched for by a user. For example, you may write about \"different HTTP listening options\" whereas a user may only ever try to find that specific content using a search phrase like \"alternate port\". If you are aware of typical user search phrases it is always recommended to craft your content to include any predictable user search phrases. However, in the rare case of a mismatch between words in your content and the words a user searches for, you can utilize use the keywords string in the [extra] section of your document's frontmatter to increase visibility. For example, the following code block shows frontmatter that helps a user find your documentation page (when the user searches for port):[extra]\nkeywords = \"port ports\"Adding a word to the keywords string of a page overrides the built-in search functionality by at least one order of magnitude. Adding a word to the keywords string may displace other content, so please use it only if necessary.undefinedThe keywords string takes users to the start of a page. In some cases, this is not ideal. You may want to home in on specific content to resolve a search query.If a search term relates to a specific part of a page, you may use the following syntax anywhere in the body of your markdown file, and the user's search action will direct them straight to the previous heading (nearest heading above the @searchTerm syntax).<!-- @searchTerm \"homing\" -->When using the above @searchTerm feature, please note the following:undefinedundefinedExample: If you search for the word \"homing\", the results will point you to the previous heading in this specific section of the developer documentation.undefined","keywords":"","subsectionKeywords":"  homing ","url":"/v3/contributing-docs#63-increasing-search-visibility-for-your-content"},{"project":"v3","title":"Contributing to Docs","subheading":"6.4 The Edit On GitHub Button","content":"Each markdown file in the developer documentation requires a link to its GitHub page for the site to correctly render the \"Edit on GitHub\" button for that page.undefinedIf you create a new markdown file and/or you notice a file without the explicit GitHub URL, please add a URL entry to the [extra] section. For example, the following url is required for this page that you are reading (you can check the raw markdown contents of this page to see this example):[extra]\nurl = \"https://github.com/spinframework/spin-docs/blob/main/content/spin/v3/contributing-docs.md\"","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#64-the-edit-on-github-button"},{"project":"v3","title":"Contributing to Docs","subheading":"6.5 How To Properly Edit CSS Styles","content":"undefinedDirectly editing .css files is not recommended, because .css files are overwritten. Instead, if you would like to make and test a new/different style please go ahead and update the appropriate .scss file. The following command will automatically update the .css file that is relevant to the .scss file that you are editing:$ npm run stylesThe above command is designed to be run in the background; enabling you to view your design changes (that are reflected in the .css) while you are editing the .scss in real-time. If you are not running this command in the background (i.e. just deliberately regenerating the .css files once), then the above command can be stopped by pressing Ctrl + C.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#65-how-to-properly-edit-css-styles"},{"project":"v3","title":"Contributing to Docs","subheading":"6.6 Checking Your Content - Using Bartholomew's CLI","content":"The Bartholomew Command Line Interface (CLI) Tool is called bart. The bart CLI is a tool that simplifies working with Bartholomew projects (by now you probably already know that undefined is our in-house WebAssembly (Wasm) content management system (CMS) that powers undefined). And this (our official documentation) site. The bart CLI is handy to ensure quality assurance of new and existing content. Installing the CLI is a cinch, so please go ahead and use it when contributing.To build the Bartholomew CLI from source perform the following commands:$ cd ~\n$ git clone https://github.com/fermyon/bartholomew.git\n$ cd ~/bartholomew\n$ make bartOnce built, you will find the bart CLI executable in the ~/bartholomew/target/release directory. However, for convenience it would be a great idea to go ahead and add the bart executable to your system path, for example:$ sudo mv ~/bartholomew/target/release/bart /usr/local/bin/Once installed, you can use the CLI's --help flag to learn more. For example:$ bart --help\nbart 0.6.0\nThe Bartholomew CLI\n\nUSAGE:\n    bart <SUBCOMMAND>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nSUBCOMMANDS:\n    calendar    Print the content calendar for a Bartholomew website\n    check       Check content and identify errors or warnings\n    help        Prints this message or the help of the given subcommand(s)\n    new         Create a new page or website from a templateLet's take a quick look at how you can use the bart CLI to check any content that you are wanting to contribute.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#66-checking-your-content---using-bartholomews-cli"},{"project":"v3","title":"Contributing to Docs","subheading":"6.7 Checking Your Content - Preview a Documentation Page on Localhost","content":"You can host your changes to the developer documentation on your own machine (localhost) by using the following spin commands:$ npm ci\n$ cd spin-up-hub\n$ npm ci\n$ cd ..\n$ spin build\n$ spin up -e \"PREVIEW_MODE=1\"undefined","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#67-checking-your-content---preview-a-documentation-page-on-localhost"},{"project":"v3","title":"Contributing to Docs","subheading":"6.8 Scheduling Menu Items for Timed Release","content":"As mentioned above, all pages (.md files) in the documentation have a UTC date i.e. date = \"2023-07-25T17:26:00Z\". The date is a page scheduling mechanism whereby each page is only displayed if the date has elapsed. Menu items (found in the /developer/templates/*.hbs files) that relate to a scheduled page can also be scheduled (so the specific menu item and its associated page appear at the same time). Simply envelope the menu item with the following if syntax to synchronize the appearance of the menu item with the related page:{{#if (timed_publish \"2023-07-25T17:26:00Z\" env.PREVIEW_MODE)}}\n    // Scheduled menu item for timed release\n{{/if}}undefined","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#68-scheduling-menu-items-for-timed-release"},{"project":"v3","title":"Contributing to Docs","subheading":"7. Checking Web Pages","content":"The bart check command can be used to check the content. Simply pass in the content as a parameter. The developer documentation undefined, so always pass --shortcodes ./shortcodes as shown below:$ bart check --shortcodes ./shortcodes content/spin/variables.md\nshortcodes: registering alert\nshortcodes: registering details\nshortcodes: registering tabs\nshortcodes: registering startTab\nshortcodes: registering blockEnd\n✅ content/spin/variables.mdundefined","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#7-checking-web-pages"},{"project":"v3","title":"Contributing to Docs","subheading":"8. Add Changes","content":"Once your changes have been checked, go ahead and add your changes by moving to a top-level directory, under which your changes exist i.e. cd ~/developer.Add your changes by running the following command, from the root of the developer repository:$ git add","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#8-add-changes"},{"project":"v3","title":"Contributing to Docs","subheading":"9. Commit Changes","content":"All commits must be signed off undefined GPG-signed with a GitHub verification key. The rest of this section is primarily for contributors not familiar with signing, and describes how to configure signing, and how to sign commits.First, ensure that your Git installation is configured sufficiently so that you can --signoff as part of the git commit command. Typically, you need the user.name and user.email to be configured in your Git session. You can check if these are set by typing git config --list.If you need to set these values please use the following commands:$ git config user.name \"yourusername\"$ git config user.email \"youremail@somemail.com\"You must also set up a GPG verification key on your GitHub account, and add this to your Git settings.  For more information about setting up a GPG verification key, see GitHub's documentation about undefined and undefined.With all this set up, type the following commit command, which both undefined (--signoff) and undefined the data (-S), and leaves a short commit message (-m):$ git commit -S --signoff -m \"Updating documentation\"undefined","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#9-commit-changes"},{"project":"v3","title":"Contributing to Docs","subheading":"10. Push Changes","content":"At this stage, it is a good idea to just quickly check what GitHub thinks the origin is. For example, if we type git remote -v we can see that the origin is our repo; which we a) forked the original repo into and b) which we then cloned to our local disk so that we could edit:$ git remote -vThe above command will return output similar to the following:origin\tgit@github.com:yourusername/developer.git (fetch)\norigin\tgit@github.com:yourusername/developer.git (push)\nupstream\thttps://github.com/fermyon/developer (fetch)\nupstream\thttps://github.com/fermyon/developer (push)Once you are satisfied go ahead and push your changes:$ git push -u origin my_new_branch","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#10-push-changes"},{"project":"v3","title":"Contributing to Docs","subheading":"11. Create a Pull Request","content":"If you return to your GitHub repository in your browser, you will notice that a PR has automatically been generated for you.Clicking on the green “Compare and pull request” button will allow you to add a title and description as part of the PR.undefinedYou can also add any information in the textbox provided below the title. For example, screen captures and/or code/console/terminal snippets of your contribution working correctly and/or tests passing etc.Once you have finished creating your PR, please keep an eye on the PR; answering any questions as part of the collaboration process.undefinedThanks for contributing.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-docs#11-create-a-pull-request"},{"project":"v3","title":"Contributing to Spin","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedWe are delighted that you are interested in making Spin better! Thank you!This document will guide you through making your first contribution to the project.\nWe welcome and appreciate contributions of all types — opening issues, fixing\ntypos, adding examples, one-liner code fixes, tests, or complete features.","subsectionKeywords":"","url":"/v3/contributing-spin"},{"project":"v3","title":"Contributing to Spin","subheading":"Spin Slack Channel","content":"Join us in the undefined! This is a great place to ask questions, meet people in the community, and share what you are working on. If you're not already signed up for the CNCF Slack, request an invite undefined.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-spin#spin-slack-channel"},{"project":"v3","title":"Contributing to Spin","subheading":"Developer Community Calls","content":"undefined<strong>Each Monday</strong> at 2:30pm UTC and 9:00pm UTC (alternating), we meet to discuss Spin issues, roadmap, and ideas in our Spin Project Meetings. The Spin Project follows an undefined - anyone who is interested is welcome to join the discussion. undefined for meeting dates.The undefined. The document contains a rolling agenda with the date and time of each meeting, the Zoom link, and topics of discussion for the day. You will also find the meeting minutes for each meeting and the link to the recording. If you have something you would like to demo or discuss at the project meeting, we encourage you to add it to the agenda.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-spin#developer-community-calls"},{"project":"v3","title":"Contributing to Spin","subheading":"Code of Conduct","content":"First, any contribution and interaction on the Spin project MUST follow our\nundefined. Thank you for being\npart of an inclusive and open community!If you plan on contributing anything complex, please go through the issue and PR\nqueues first to make sure someone else has not started working on it. If it\ndoesn't exist already, please open an issue so you have a chance to get feedback\nfrom the community and the maintainers before you start working on your feature.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-spin#code-of-conduct"},{"project":"v3","title":"Contributing to Spin","subheading":"Making Code Contributions to Spin","content":"The following guide is intended to make sure your contribution can get merged as\nsoon as possible. First, make sure you have Rust installed.undefinedAfter undefined please ensure the wasm32-wasip1 and\nwasm32-unknown-unknown targets are configured. For example:rustup target add wasm32-wasip1 && rustup target add wasm32-unknown-unknownIn addition, make sure you have the following prerequisites configured:undefinedundefinedundefinedundefinedundefinedOnce you have set up the prerequisites and identified the contribution you want to make to Spin, make sure you can correctly build the project:# clone the repository\n$ git clone https://github.com/spinframework/spin && cd spin\n# add a new remote pointing to your fork of the project\n$ git remote add fork https://github.com/<your-username>/spin\n# create a new branch for your work\n$ git checkout -b <your-branch>\n\n# build the Spin CLI\n$ cargo build\n\n# make sure compilation is successful\n$ ./target/debug/spin --help\n\n# run the tests and make sure they pass\n$ make testNow you should be ready to start making your contribution. To familiarize\nyourself with the Spin project, please read the\nundefined. Since most of Spin is implemented in\nRust, we try to follow the common Rust coding conventions (keep an eye on the\nrecommendations from Clippy!). If applicable, add unit or integration tests to\nensure your contribution is correct.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-spin#making-code-contributions-to-spin"},{"project":"v3","title":"Contributing to Spin","subheading":"Before You Commit","content":"undefinedundefinedundefinedundefinedSpin enforces lints and tests as part of continuous integration - running them locally will save you a round-trip to your pull request!If everything works locally, you're ready to commit your changes.","keywords":"","subsectionKeywords":"","url":"/v3/contributing-spin#before-you-commit"},{"project":"v3","title":"Contributing to Spin","subheading":"Committing and Pushing Your Changes","content":"We require commits to be signed both with an email address and with a GPG signature.undefined$ git commit -S -s -m \"<your commit message>\"undefinedWe try to only keep useful changes as separate commits — if you prefer to commit\noften, please\nundefined\nbefore opening a pull request.Once you are happy with your changes you can push the branch to your fork:# \"fork\" is the name of the git remote pointing to your fork\n$ git push forkNow you are ready to create a pull request. Thank you for your contribution!","keywords":"","subsectionKeywords":"","url":"/v3/contributing-spin#committing-and-pushing-your-changes"},{"project":"v3","title":"Deploying Spin Applications to Fermyon","subheading":"","content":"undefinedundefined","subsectionKeywords":"","url":"/v3/deploying-to-fermyon"},{"project":"v3","title":"Deploying Spin Applications to Fermyon","subheading":"Fermyon Cloud","content":"undefined is a self-service application platform for WebAssembly-based serverless functions and microservices. It enables you to run Spin applications, at scale, in the cloud, without any infrastructure setup or maintenance required.","keywords":"","subsectionKeywords":"","url":"/v3/deploying-to-fermyon#fermyon-cloud"},{"project":"v3","title":"Deploying Spin Applications to Fermyon","subheading":"Fermyon Platform","content":"undefined is a self-host platform for Spin applications. With Fermyon, you can deploy your spin applications onto a server in moments.undefined","keywords":"","subsectionKeywords":"","url":"/v3/deploying-to-fermyon#fermyon-platform"},{"project":"v3","title":"Deploying Spin Applications to Fermyon","subheading":"Running on Your Workstation","content":"For instructions guiding you through running the Fermyon platform on your development workstation,\nfollow undefined.","keywords":"","subsectionKeywords":"","url":"/v3/deploying-to-fermyon#running-on-your-workstation"},{"project":"v3","title":"Deploying Spin Applications to Fermyon","subheading":"Running on AWS","content":"For instructions guiding you through running the Fermyon platform on AWS, follow\nundefined.","keywords":"","subsectionKeywords":"","url":"/v3/deploying-to-fermyon#running-on-aws"},{"project":"v3","title":"Publishing and Distribution","subheading":"","content":"undefinedundefinedundefinedundefinedIf you would like to publish a Spin application, so that other users can run it, you can do so using a undefined.{{ details \"What's all this about containers?\" \"The registry protocol was originally created to publish and distribute Docker containers. Over time, registries have evolved to host other kinds of artifact - see undefined for more information. However, the term remains, in services such as GitHub Container Registry or AWS Elastic Container Registry, and in the generic description undefined. When you use a 'container' registry to publish and distribute Spin applications, there are no actual containers involved at all!\" }}Many cloud services offer public registries.  Examples include GitHub Container Registry, Docker Hub, or Amazon Elastic Container Registry.  These support both public and private distribution.  You can also run your own registry using open source software.","subsectionKeywords":"","url":"/v3/distributing-apps"},{"project":"v3","title":"Publishing and Distribution","subheading":"Logging Into a Registry","content":"Before you can publish to a registry, or run applications whose registry artifacts are private, you must log in to the registry.  This example shows logging into the GitHub Container Registry, ghcr.io:$ spin registry login ghcr.ioIf you don't provide any options to spin registry login, it prompts you for a username and password.","keywords":"","subsectionKeywords":"","url":"/v3/distributing-apps#logging-into-a-registry"},{"project":"v3","title":"Publishing and Distribution","subheading":"Logging In Using a Token","content":"In a non-interactive environment such as GitHub Actions, you will typically log in using a token configured in the environment settings, rather than a password.  To do this, use the --password-stdin flag, and echo the token value to the login command's standard input.  This example shows logging into GHCR from a GitHub action:$ echo \"$\\{{ secrets.GITHUB_TOKEN }}\" | spin registry login ghcr.io --username $\\{{ github.actor }} --password-stdinOther environments will have different ways of referring to the token and user but the pattern remains the same.","keywords":"","subsectionKeywords":"","url":"/v3/distributing-apps#logging-in-using-a-token"},{"project":"v3","title":"Publishing and Distribution","subheading":"Fallback Credentials","content":"If you have logged into a registry using docker login, but not using spin registry login, Spin will fall back to your Docker credentials.","keywords":"","subsectionKeywords":"","url":"/v3/distributing-apps#fallback-credentials"},{"project":"v3","title":"Publishing and Distribution","subheading":"Publishing a Spin Application to a Registry","content":"To publish an application to a registry, use the spin registry push command.  You must provide a undefined for the published application.  This is a string whose format is defined by the registry standard, and generally consists of <registry>/<username>/<application-name>:<version>.  (In specific circumstances you may be able to omit the username and/or the version.  If you want more detail on references, see the OCI documentation.)undefinedHere is an example of pushing an application to GHCR:$ spin registry push ghcr.io/alyssa-p-hacker/hello-world:v1\nPushed with digest sha256:06b19Notice that the username is part of the reference; the registry does not infer it from the login.  Also notice that the version is specified explicitly; Spin does not infer it from the spin.toml file.undefined","keywords":"","subsectionKeywords":"","url":"/v3/distributing-apps#publishing-a-spin-application-to-a-registry"},{"project":"v3","title":"Publishing and Distribution","subheading":"Running Published Applications","content":"To run a published application from a registry, use spin up -f and pass the registry reference:$ spin up -f ghcr.io/alyssa-p-hacker/hello-world:v1undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/distributing-apps#running-published-applications"},{"project":"v3","title":"Publishing and Distribution","subheading":"Running Published Applications by Digest","content":"Registry versions are mutable; that is, the owner of an application can change which build the :v1 label points to at any time.  If you want to run a specific build of the package, you can refer to it by undefined.  This is similar to a Git commit hash: it is immutable, meaning the same digest always gets the exact same data, no matter what the package owner does.  To do this, use the @sha256:... syntax instead of the :v... syntax:$ spin up -f ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19","keywords":"","subsectionKeywords":"","url":"/v3/distributing-apps#running-published-applications-by-digest"},{"project":"v3","title":"Publishing and Distribution","subheading":"Pulling a Published Application","content":"spin up automatically downloads the application from the registry. If you want to manually download the application, without running it, use the spin registry pull command:$ spin registry pull ghcr.io/alyssa-p-hacker/hello-world:v1\n$ spin registry pull ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19undefined","keywords":"","subsectionKeywords":"","url":"/v3/distributing-apps#pulling-a-published-application"},{"project":"v3","title":"Publishing and Distribution","subheading":"Signing Spin Applications and Verifying Signatures","content":"Because Spin uses the container registry standards to distribute applications, it can also take advantage of tooling built around those standards.  Here is an example of using undefined to sign and verify a Spin application:# Push your Spin application to any registry that supports the OCI registry artifacts,\n# such as the GitHub Container Registry, Docker Hub, Azure ACR, or AWS ECR.\n$ spin registry push ghcr.io/alyssa-p-hacker/hello-world:v1\n\n# You can now sign your Spin app using Cosign (or any other tool that can sign\n# OCI registry objects).\n$ cosign sign ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19\nGenerating ephemeral keys...\nRetrieving signed certificate...\ntlog entry created with index: 12519542\nPushing signature to: ghcr.io/alyssa-p-hacker/hello-world\n\n# Someone interested in your application can now use Cosign to verify the signature\n# before running the application.\n$ cosign verify ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19\nVerification for ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19 --\nThe following checks were performed on each of these signatures:\n  - The cosign claims were validated\n  - Existence of the claims in the transparency log was verified offline\n  - Any certificates were verified against the Fulcio roots.\n\n# The consumer of your app can now run it from the registry.\n$ spin up -f ghcr.io/alyssa-p-hacker/hello-world@sha256:06b19undefined","keywords":"","subsectionKeywords":"","url":"/v3/distributing-apps#signing-spin-applications-and-verifying-signatures"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"","content":"undefinedundefinedundefinedundefinedConfiguration for Spin application features such as undefined,\nundefined, undefined\nand undefined can be supplied dynamically, i.e. during the application runtime,\nrequiring no changes to the application code itself.This runtime configuration data is stored in the runtime-config.toml file and passed in via the --runtime-config-file flag\nwhen invoking the spin up command.Let's look at each configuration category in-depth below.","subsectionKeywords":"","url":"/v3/dynamic-configuration"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"Application Variables Runtime Configuration","content":"undefined values may be set at runtime by providers. Currently,\nthere are three application variable providers: the undefined,\nthe undefined and the undefined.Multiple application variable providers can be configured in Spin. Providers are\nprioritized top-down in the runtime configuration file, with higher-listed providers\ntaking precedence. The environment variable provider always has the highest\npriority.The provider examples below show how to use or configure each\nprovider. For examples on how to access these variables values within your application, see\nundefined.","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#application-variables-runtime-configuration"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"Environment Variable Provider","content":"The environment variable provider gets variable values from the spin process's\nenvironment (undefined the component environment). Variable keys are translated\nto environment variables by upper-casing and prepending with SPIN_VARIABLE_:$ export SPIN_VARIABLE_API_KEY=\"1234\"  # Sets the `api_key` value.\n$ spin up","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#environment-variable-provider"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"Vault Application Variable Provider","content":"The Vault application variable provider gets secret values from undefined.\nCurrently, only the undefined is supported.\nYou can set up the v2 kv secret engine at any mount point and provide Vault information in\nthe undefined file:[[config_provider]]\ntype = \"vault\"\nurl = \"http://127.0.0.1:8200\"\ntoken = \"root\"\nmount = \"secret\"","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#vault-application-variable-provider"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"Vault Application Variable Provider Example","content":"undefinedundefined$ vault server -dev -dev-root-token-id rootundefined$ export VAULT_TOKEN=root\n$ export VAULT_ADDR=http://127.0.0.1:8200\n$ vault kv put secret/secret value=\"test_password\"\n$ vault kv get secret/secretundefinedundefined$ spin build\n$ spin up --runtime-config-file runtime-config.tomlundefined$ curl localhost:3000 --data \"test_password\"\n{\"authentication\": \"accepted\"}$ curl localhost:3000 --data \"wrong_password\"\n{\"authentication\": \"denied\"}","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#vault-application-variable-provider-example"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"Azure Key Vault Application Variable Provider","content":"The Azure Key Vault application variable provider gets secret values from undefined.Currently, only receiving the latest version of a secret is supported.For authenticating against Azure Key Vault, you must use the client credentials flow. To do so, create a Service Principal (SP) within your Microsoft Entra ID (previously known as Azure Active Directory) and assign the Key Vault Secrets User role to the SP on the scope of your Azure Key Vault instance.You can set up Azure Key Vault application variable provider in\nthe undefined file:[[config_provider]]\ntype = \"azure_key_vault\"\nvault_url = \"https://spin.vault.azure.net/\"\nclient_id = \"12345678-1234-1234-1234-123456789012\"\nclient_secret = \"some.generated.password\"\ntenant_id = \"12345678-1234-1234-1234-123456789012\"\nauthority_host = \"AzurePublicCloud\"","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#azure-key-vault-application-variable-provider"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"Azure Key Vault Application Variable Provider Example","content":"undefined# Variable Definition\n$ KV_NAME=spin123\n$ LOCATION=germanywestcentral\n$ RG_NAME=rg-spin-azure-key-vault\n\n# Create an Azure Resource Group and an Azure Key Vault\n$ az group create -n $RG_NAME -l $LOCATION\n$ az keyvault create -n $KV_NAME \\\n  -g $RG_NAME \\\n  -l $LOCATION \\\n  --enable-rbac-authorization true\n\n# Grab the Azure Resource Identifier of the Azure Key Vault instance\n$ KV_SCOPE=$(az keyvault show -n $KV_NAME -g $RG_NAME -otsv --query \"id\")undefined# Grab the ID of the currently signed in user in Azure CLI\n$ CURRENT_USER_ID=$(az ad signed-in-user show -otsv --query \"id\")\n\n# Make the currently signed in user a \"Key Vault Secrets Officer\"\n# on the scope of the new Azure Key Vault instance\n$ az role assignment create --assignee $CURRENT_USER_ID \\\n  --role \"Key Vault Secrets Officer\" \\\n  --scope $KV_SCOPE\n\n# Create a test secret called `secret` in the Azure Key Vault instance\n$ az keyvault secret set -n secret --vault-name $KV_NAME --value secret_value --ononeundefined$ export SP_NAME=sp-spin\n\n# Create the SP\n$ SP=$(az ad sp create-for-rbac -n $SP_NAME -ojson)\n\n# Populate local shell variables from the SP JSON\n$ CLIENT_ID=$(echo $SP | jq -r '.appId')\n$ CLIENT_SECRET=$(echo $SP | jq -r '.password')\n$ TENANT_ID=$(echo $SP | jq -r '.tenant')\n\n# Assign the \"Key Vault Secrets User\" role to the SP\n# allowing it to read secrets from the Azure Key Vault instance\n$ az role assignment create --assignee $CLIENT_ID \\\n  --role \"Key Vault Secrets User\" \\\n  --scope $KV_SCOPEundefinedundefinedThe azure-key-vault-provider application contains a runtime-config.toml file. Replace all tokens (e.g. $KV_NAME$) with the corresponding shell variables you created in the previous steps.undefined$ spin build\n$ spin up --runtime-config-file runtime-config.tomlundefined$ curl localhost:3000\nLoaded Secret from Azure Key Vault: secret_value","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#azure-key-vault-application-variable-provider-example"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"Key Value Store Runtime Configuration","content":"Spin provides built-in key-value storage. By default, this storage is backed by a file in the application .spin directory. However, the Spin runtime configuration file (runtime-config.toml) can be updated to not only modify the file configuration but also choose to use a different backing store. The available store options are the file provider, an external Redis database, Azure CosmosDB or AWS DynamoDB.","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#key-value-store-runtime-configuration"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"File Key Value Store Provider","content":"To use a file as a backend for Spin's key-value store, set the type to spin, and provide a file path:[key_value_store.default]\ntype = \"spin\"\npath = \".spin/precious-data.db\"Spin creates the path and file if they don't already exist.undefined","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#file-key-value-store-provider"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"Redis Key Value Store Provider","content":"To use a Redis store as a backend for Spin's key-value store, set the type to redis and provide the URL of the Redis host:[key_value_store.default]\ntype = \"redis\"\nurl = \"redis://localhost\"","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#redis-key-value-store-provider"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"Azure CosmosDB Key Value Store Provider","content":"To use an Azure CosmosDB database as a backend for Spin's key-value store, set the type to azure_cosmos and specify your database account details:[key_value_store.default]\ntype = \"azure_cosmos\"\nkey = \"<key>\"\naccount = \"<cosmos-account>\"\ndatabase = \"<cosmos-database>\"\ncontainer = \"<cosmos-container>\"undefined","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#azure-cosmosdb-key-value-store-provider"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"AWS DynamoDB Key Value Store Provider","content":"To use an Amazon Web Services DynamoDB database as a backend for Spin's key-value store, set the type to aws_dynamo and specify your database account details:[key_value_store.default]\ntype = \"aws_dynamo\"\nregion = \"<aws-region>\"   # e.g. \"us-east-1\"\ntable = \"<dynamo-table>\"  # e.g. \"spin-key-values\"\nconsistent_read = true    # optional, to use strongly consistent readsYou may optionally provide access_key and secret_key credentials; otherwise, Spin picks these up from your undefined. For short-lived credentials, you can additionally provide token (from the undefined or undefined).By default, the DynamoDB backend uses eventually consistent reads. The consistent_read option turns on undefined. This ensures reads are up-to-date with writes, at an increased cost. See the undefined for more information.undefined","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#aws-dynamodb-key-value-store-provider"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"Multiple and Non-Default Key-Value Stores","content":"Whilst a single default store may be sufficient for certain application use cases, each Spin application can be configured to support multiple stores of any type, as shown in the runtime-config.toml file below:# This defines a new store named user_data\n[key_value_store.user_data]\ntype = \"spin\" \npath = \".spin/user_data.db\"\n\n# This defines a new store named other_data backed by a Redis database\n[key_value_store.other_data]\ntype = \"redis\"\nurl = \"redis://localhost\"You must individually grant each component access to the stores that it needs to use. To do this, use the component.key_value_stores entry in the component manifest within spin.toml. See undefined for more details.","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#multiple-and-non-default-key-value-stores"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"SQLite Storage Runtime Configuration","content":"Spin provides built-in SQLite storage. By default, this is backed by a database that Spin creates for you underneath your application directory (in the .spin subdirectory). However, you can use the Spin runtime configuration file (runtime-config.toml) to add and customize SQLite databases.The following example runtime-config.toml tells Spin to map the default database to an SQLite database elsewhere in the file system:[sqlite_database.default]\ntype = \"spin\"\npath = \"/planning/todo.db\"If you need more than one database, you can configure multiple databases, each with its own name:# This defines a new store named todo\n[sqlite_database.todo]\ntype = \"spin\"\npath = \"/planning/todo.db\"\n\n# This defines a new store named finance\n[sqlite_database.finance]\ntype = \"spin\"\npath = \"/super/secret/monies.db\"Spin creates any database files that don't exist.  However, it is up to you to delete them when you no longer need them.","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#sqlite-storage-runtime-configuration"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"LibSQL Storage Provider","content":"Spin can also use undefined databases accessed over HTTPS.  libSQL is fully compatible with SQLite but provides additional features including remote, distributed databases.undefinedTo use libSQL, set type = \"libsql\" in your runtime-config.toml entry.  You must then provide a url and authentication token instead of a file path.  For example, this entry tells Spin to map the default database to a libSQL service running on libsql.example.com:# This tells Spin to use the remote host as its default database\n[sqlite_database.default]\ntype = \"libsql\"\nurl = \"https://sensational-penguin-ahacker.libsql.example.com\"\ntoken = \"a secret\"Spin does undefined create libSQL databases.  Use your hosting service's tools to create them (or sqld if you are self-hosting) .  You can still set up tables and data in a libSQL database via spin up --sqlite.undefinedThe default database will still be defined, even if you add other databases.By default, components will not have access to any of these databases (even the default one). You must grant each component access to the databases that it needs to use. To do this, use the component.sqlite_databases entry in the component manifest within spin.toml. See undefined for more details.","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#libsql-storage-provider"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"LLM Runtime Configuration","content":"Spin provides a Large Language Model interface for interacting with LLMs for inferencing and embedding. The default host implementation is to use local CPU/GPU compute. However, the Spin runtime configuration file (runtime-config.toml) can be updated to enable Spin to use remote compute using HTTP requests.","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#llm-runtime-configuration"},{"project":"v3","title":"Dynamic and Runtime Application Configuration","subheading":"Remote Compute Provider","content":"The following is an example of how an application's runtime-config.toml file can be configured to use the remote compute option. Note the type, url and auth_token are set to remote_http, URL of the server and the auth token for the server.[llm_compute]\ntype = \"remote_http\"\nurl = \"http://example.com\"\nauth_token = \"<auth_token>\"Currently, the remote compute option requires an user to deploy their own LLM proxy service. Fermyon Cloud users can do this using the undefined.  If you prefer to create and deploy your own proxy service, you can find a reference implementation of the proxy protocol in the undefined.By default, components will not have access to the LLM models unless granted explicit access through the component.ai_models entry in the component manifest within spin.toml. See undefined for more details.","keywords":"","subsectionKeywords":"","url":"/v3/dynamic-configuration#remote-compute-provider"},{"project":"v3","title":"Extending and Embedding Spin","subheading":"","content":"undefinedundefined","subsectionKeywords":"","url":"/v3/extending-and-embedding"},{"project":"v3","title":"Extending and Embedding Spin","subheading":"Extending Spin with a Custom Trigger","content":"undefinedSpin currently implements triggers and application models for:undefinedundefinedThe Spin internals and execution context (the part of Spin executing\ncomponents) are agnostic of the event source and application model.\nIn this document, we will explore how to extend Spin with custom event sources\n(triggers) and application models built on top of the WebAssembly component\nmodel, as well as how to embed Spin in your application.In this article, we will build a Spin trigger to run the applications based on a\ntimer, executing Spin components at a configured time interval.undefinedApplication entry points are defined using\nundefined. Here's the entry point for HTTP triggers:interface incoming-handler {\n  use types.{incoming-request, response-outparam}\n\n  handle: func(\n    request: incoming-request,\n    response-out: response-outparam\n  )\n}The entry point we want to execute for our timer trigger takes no input and doesn't return anything. This is purposefully chosen\nto be a simple function signature. For simplicity, we allow guest code to use Spin's undefined but not other Spin APIs.undefinedHere is the resulting timer WIT:// examples/spin-timer/spin-timer.wit\npackage fermyon:example\n\nworld spin-timer {\n  import fermyon:spin/variables@2.0.0\n  export handle-timer-request: func()\n}handle-timer-request is the function that all components executed by the timer trigger must\nimplement, and which is used by the timer executor when instantiating and\ninvoking the component.The timer trigger itself is a Spin plugin whose name is trigger-timer. The first part must be trigger and the second part is the trigger type.You can see the full timer trigger code at the link above but here are some key features.","keywords":"","subsectionKeywords":"","url":"/v3/extending-and-embedding#extending-spin-with-a-custom-trigger"},{"project":"v3","title":"Extending and Embedding Spin","subheading":"Implement the Trigger World","content":"The timer trigger implements the WIT world described in spin-timer.wit. To do that, it uses the wasmtime binding generator — this generates code that allows the trigger to invoke the guest's entry point, and allows the guest to invoke the Spin APIs available in the world.// examples/spin-timer/src/main.rs\nwasmtime::component::bindgen!({\n    path: \".\",\n    world: \"spin-timer\",\n    async: true\n});","keywords":"","subsectionKeywords":"","url":"/v3/extending-and-embedding#implement-the-trigger-world"},{"project":"v3","title":"Extending and Embedding Spin","subheading":"The Trigger Implements the  Trigger  Trait","content":"Using Trigger allows the trigger to offload a great deal of boilerplate loader work to the spin_trigger crate and the FactorsTriggerCommand CLI helper.struct TimerTrigger {\n    speedup: u64,\n    component_timings: HashMap<String, u64>,\n}\n\n#[async_trait]\nimpl<F: RuntimeFactors> Trigger<F> for TimerTrigger {\n    // ...\n}The Trigger trait is generic in the set of undefined supported by the trigger - this is roughly the set of APIs available to guest code. In most circumstances, your implementation should also be generic, as shown, because your trigger is only concerned with detecting events, and can do that regardless of what APIs are available to the guests that handle those events.","keywords":"","subsectionKeywords":"","url":"/v3/extending-and-embedding#the-trigger-implements-the-trigger-trait"},{"project":"v3","title":"Extending and Embedding Spin","subheading":"The Trigger is an Executable","content":"A trigger is a separate program, so that it can be installed as a plugin. So it is a Rust bin project and has a main function. It can be useful to also provide a library crate, so that projects that embed Spin can load it in process if desired, but the timer sample doesn't currently show that.type Command = FactorsTriggerCommand<TimerTrigger, FactorsBuilder>;\n//                                         |              |\n//           the trigger type you created above           |\n//                      the factors (APIs) available to guests\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let t = Command::parse();\n    t.run().await\n}FactorsTriggerCommand allows you to configure the set of factors. spin_runtime_factors::FactorsBuilder will give you a set that matches the Spin CLI, which is almost always the right choice for a trigger plugin. If other hosts link your trigger, they will initialize it with the factors they support instead. (This is why it's desirable for your Trigger implementation to be as generic as possible!)","keywords":"","subsectionKeywords":"","url":"/v3/extending-and-embedding#the-trigger-is-an-executable"},{"project":"v3","title":"Extending and Embedding Spin","subheading":"The Trigger Detects Events...","content":"In this case the trigger \"detects\" events by running a timer. In most cases, the trigger detects events by listening on a socket, completion port, or other mechanism, or by polling a resource such as a directory or an HTTP endpoint.for (component_id, interval_secs) in &self.component_timings {\n    scope.spawn(async {\n        let duration =\n            tokio::time::Duration::from_millis(*interval_secs * 1000 / speedup);\n        loop {\n            tokio::time::sleep(duration).await;\n\n            self.handle_timer_event(&trigger_app, component_id)\n                .await\n                .unwrap();\n        }\n    });\n}","keywords":"","subsectionKeywords":"","url":"/v3/extending-and-embedding#the-trigger-detects-events"},{"project":"v3","title":"Extending and Embedding Spin","subheading":"...and Invokes the Guest","content":"The Trigger and FactorsTriggerCommand infrastructure provides the trigger with a TriggerApp representing the configured WebAssembly environment, already initialized with the guest Wasm for each component. When an event occurs, the trigger creates a component undefined from the TriggerApp and invokes it via the WIT interfaces.async fn handle_timer_event<F: RuntimeFactors>(\n    &self,\n    trigger_app: &TriggerApp<Self, F>,\n    component_id: &str,\n) -> anyhow::Result<()> {\n    // Obtain a component instance from the app\n    let instance_builder = trigger_app.prepare(component_id)?;\n    let (instance, mut store) = instance_builder.instantiate(()).await?;\n    // Wrap the instance in the generated WIT bindings\n    let timer = SpinTimer::new(&mut store, &instance)?;\n    // Invoke the guest entry point via the bindings\n    timer.call_handle_timer_request(&mut store).await\n}","keywords":"","subsectionKeywords":"","url":"/v3/extending-and-embedding#and-invokes-the-guest"},{"project":"v3","title":"Extending and Embedding Spin","subheading":"Other Ways to Extend and Use Spin","content":"Besides building custom triggers, the internals of Spin could also be used independently:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/extending-and-embedding#other-ways-to-extend-and-use-spin"},{"project":"v3","title":"Building Spin components in Go","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v3/go-components"},{"project":"v3","title":"Building Spin components in Go","subheading":"Versions","content":"TinyGo 0.30.0 is recommended, which requires Go v1.19+.","keywords":"","subsectionKeywords":"","url":"/v3/go-components#versions"},{"project":"v3","title":"Building Spin components in Go","subheading":"HTTP Components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, and Go has improved support for\nwriting applications, through its SDK.Building a Spin HTTP component using the Go SDK means writing a single function,\ninit — below is a complete implementation for such a component:// A Spin component written in Go that returns \"Hello, Fermyon!\"\npackage main\n\nimport (\n \"fmt\"\n \"net/http\"\n\n spinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n)\n\nfunc init() {\n spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n  w.Header().Set(\"Content-Type\", \"text/plain\")\n  fmt.Fprintln(w, \"Hello Fermyon!\")\n })\n}\n\nfunc main() {}The Spin HTTP component (written in Go) can be built using the tingygo toolchain:$ tinygo build -o main.wasm -target=wasi main.goOnce built, we can run our Spin HTTP component using the Spin up command:$ spin upThe Spin HTTP component can now receive and process incoming requests:$ curl -i localhost:3000\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 15\n\nHello Fermyon!The important things to note in the implementation above:undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/go-components#http-components"},{"project":"v3","title":"Building Spin components in Go","subheading":"Sending Outbound HTTP Requests","content":"If allowed, Spin components can send outbound requests to HTTP endpoints. Let's\nsee an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:// A Spin component written in Go that sends a request to an API\n// with random animal facts.\n\npackage main\n\nimport (\n \"fmt\"\n \"net/http\"\n \"os\"\n\n spinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n)\n\nfunc init() {\n spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n    resp, _ := spinhttp.Get(\"https://random-data-api.fermyon.app/animals/json\")\n\n  fmt.Fprintln(w, resp.Body)\n  fmt.Fprintln(w, resp.Header.Get(\"content-type\"))\n\n  // `spin.toml` is not configured to allow outbound HTTP requests to this host,\n  // so this request will fail.\n  if _, err := spinhttp.Get(\"https://fermyon.com\"); err != nil {\n   fmt.Fprintf(os.Stderr, \"Cannot send HTTP request: %v\", err)\n  }\n })\n}\n\nfunc main() {}The Outbound HTTP Request example above can be built using the tingygo toolchain:$ tinygo build -o main.wasm -target=wasi main.goBefore we can execute this component, we need to add the\nrandom-data-api.fermyon.app domain to the application manifest allowed_outbound_hosts\nlist containing the list of domains the component is allowed to make HTTP\nrequests to:# spin.toml\nspin_manifest_version = 2\n\n[application]\nname = \"spin-hello-tinygo\"\nversion = \"1.0.0\"\n\n[[trigger.http]]\nroute = \"/hello\"\ncomponent = \"tinygo-hello\"\n\n[component.tinygo-hello]\nsource = \"main.wasm\"\nallowed_outbound_hosts = [ \"https://random-data-api.fermyon.app\" ]Running the application using spin up will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /hello:$ curl -i localhost:3000/hello\nHTTP/1.1 200 OK\ncontent-length: 93\n\n{\"timestamp\":1684299253331,\"fact\":\"Reindeer grow new antlers every year\"}undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/go-components#sending-outbound-http-requests"},{"project":"v3","title":"Building Spin components in Go","subheading":"Redis Components","content":"Besides the HTTP trigger, Spin has built-in support for a Redis trigger, which\nwill connect to a Redis instance and will execute components for new messages\non the configured channels.undefinedWriting a Redis component in Go also takes advantage of the SDK:package main\n\nimport (\n \"fmt\"\n\n \"github.com/fermyon/spin/sdk/go/v2/redis\"\n)\n\nfunc init() {\n // redis.Handle() must be called in the init() function.\n redis.Handle(func(payload []byte) error {\n  fmt.Println(\"Payload::::\")\n  fmt.Println(string(payload))\n  return nil\n })\n}\n\n// main function must be included for the compiler but is not executed.\nfunc main() {}The manifest for a Redis application must contain the address of the Redis instance. This is set at the application level:spin_manifest_version = 2\n\n[application]\nname = \"spin-redis\"\ntrigger = { type = \"redis\",  }\nversion = \"0.1.0\"\n\n[application.trigger.redis]\naddress = \"redis://localhost:6379\"\n\n[[trigger.redis]]\nchannel = \"messages\"\ncomponent = \"echo-message\"\n\n[component.echo-message]\nsource = \"main.wasm\"\n[component.echo-message.build]\ncommand = \"tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"The application will connect to redis://localhost:6379, and for every new message\non the messages channel, the echo-message component will be executed:# first, start redis-server on the default port 6379\n$ redis-server --port 6379\n# then, start the Spin application\n$ spin build --up\nINFO spin_redis_engine: Connecting to Redis server at redis://localhost:6379\nINFO spin_redis_engine: Subscribed component 0 (echo-message) to channel: messagesFor every new message on the messages channel:$ redis-cli\n127.0.0.1:6379> publish messages \"Hello, there!\"Spin will instantiate and execute the component:INFO spin_redis_engine: Received message on channel \"messages\"\nPayload::::\nHello, there!","keywords":"","subsectionKeywords":"","url":"/v3/go-components#redis-components"},{"project":"v3","title":"Building Spin components in Go","subheading":"Storing Data in Redis From Go Components","content":"Using the Spin's Go SDK, you can use the Redis key/value store to publish\nmessages to Redis channels. This can be used from both HTTP and Redis triggered\ncomponents.Let's see how we can use the Go SDK to connect to Redis. This HTTP component demonstrates fetching a value from Redis by key, setting a\nkey with a value, and publishing a message to a Redis channel:package main\n\nimport (\n \"net/http\"\n \"os\"\n\n spin_http \"github.com/fermyon/spin/sdk/go/v2/http\"\n \"github.com/fermyon/spin/sdk/go/v2/redis\"\n)\n\nfunc init() {\n // handler for the http trigger\n spin_http.Handle(func(w http.ResponseWriter, r *http.Request) {\n\n  // addr is the environment variable set in `spin.toml` that points to the\n  // address of the Redis server.\n  addr := os.Getenv(\"REDIS_ADDRESS\")\n\n  // channel is the environment variable set in `spin.toml` that specifies\n  // the Redis channel that the component will publish to.\n  channel := os.Getenv(\"REDIS_CHANNEL\")\n\n  // payload is the data publish to the redis channel.\n  payload := []byte(`Hello redis from tinygo!`)\n\n  // create a new redis client.\n  rdb := redis.NewClient(addr)\n\n  if err := rdb.Publish(channel, payload); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n   return\n  }\n\n  // set redis `mykey` = `myvalue`\n  if err := rdb.Set(\"mykey\", []byte(\"myvalue\")); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n   return\n  }\n\n  // get redis payload for `mykey`\n  if payload, err := rdb.Get(\"mykey\"); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n  } else {\n   w.Write([]byte(\"mykey value was: \"))\n   w.Write(payload)\n  }\n })\n}\n\nfunc main() {}As with all networking APIs, you must grant access to Redis hosts via the allowed_outbound_hosts field in the application manifest:[component.storage-demo]\nenvironment = { REDIS_ADDRESS = \"redis://127.0.0.1:6379\", REDIS_CHANNEL = \"messages\" }\nallowed_outbound_hosts = [\"redis://127.0.0.1:6379\"]This HTTP component can be paired with a Redis component, triggered on new messages on the messages Redis channel, to build an asynchronous messaging application, where the HTTP front-end queues work for a Redis-triggered back-end to execute as capacity is available.undefined","keywords":"","subsectionKeywords":"","url":"/v3/go-components#storing-data-in-redis-from-go-components"},{"project":"v3","title":"Building Spin components in Go","subheading":"Using Go Packages in Spin Components","content":"Any undefined that can be imported in TinyGo and that compiles to\nWASI can be used when implementing a Spin component.undefined","keywords":"","subsectionKeywords":"","url":"/v3/go-components#using-go-packages-in-spin-components"},{"project":"v3","title":"Building Spin components in Go","subheading":"Storing Data in the Spin Key-Value Store","content":"Spin has a key-value store built in. For information about using it from TinyGo, see undefined.","keywords":"","subsectionKeywords":"","url":"/v3/go-components#storing-data-in-the-spin-key-value-store"},{"project":"v3","title":"Building Spin components in Go","subheading":"Storing Data in SQLite","content":"For more information about using SQLite from TinyGo, see undefined.","keywords":"","subsectionKeywords":"","url":"/v3/go-components#storing-data-in-sqlite"},{"project":"v3","title":"Building Spin components in Go","subheading":"AI Inferencing From Go Components","content":"For more information about using Serverless AI from TinyGo, see the undefined API guide.","keywords":"","subsectionKeywords":"","url":"/v3/go-components#ai-inferencing-from-go-components"},{"project":"v3","title":"Making HTTP Requests","subheading":"","content":"undefinedundefinedundefinedSpin provides an interface for you to make outgoing HTTP requests.{{ details \"Why do I need a Spin interface? Why can't I just use my language's HTTP library?\" \"The current version of the WebAssembly System Interface (WASI) doesn't provide a sockets interface, so HTTP libraries can't be built to Wasm. The Spin interface means Wasm modules can bypass this limitation by asking Spin to perform the HTTP request on their behalf.\" }}","subsectionKeywords":"","url":"/v3/http-outbound"},{"project":"v3","title":"Making HTTP Requests","subheading":"Using HTTP From Applications","content":"The outbound HTTP interface depends on your language.undefined{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedTo send requests, use the undefined function. This takes a request argument and returns a response (or error). It is async, so within an async inbound handler you can have multiple outbound sends running concurrently.undefinedsend is quite flexible in its request and response types. The request may be:undefinedundefinedundefinedundefinedGenerally, you should use OutgoingRequest when you need to stream the outbound request body; otherwise, the Request types are usually simpler.The response may be:undefinedundefinedundefinedundefinedGenerally, you should use IncomingResponse when you need to stream the response body; otherwise, the Response types are usually simpler.Here is an example of doing outbound HTTP in a simple request-response style:use spin_sdk::{\n    http::{IntoResponse, Request, Method, Response},\n    http_component,\n};\n\n#[http_component]\n// The trigger handler (in this case an HTTP handler) has to be async\n// so we can `await` the outbound send.\nasync fn handle_request(_req: Request) -> anyhow::Result<impl IntoResponse> {\n\n    // Create the outbound request object\n    let request = Request::builder()\n        .method(Method::Get)\n        .uri(\"https://www.fermyon.com/\")\n        .build();\n\n    // Send the request and await the response\n    let response: Response = spin_sdk::http::send(request).await?;\n\n    // Use the outbound response body\n    let response_len = response.body().len();\n\n    // Return the response to the inbound request\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(format!(\"The test page was {response_len} bytes\"))\n        .build())\n}For an example of receiving the response in a streaming style, undefined.{{ blockEnd }}{{ startTab \"TypeScript\"}}HTTP operations are available via the standard JavaScript fetch function. The Spin runtime maps this to the underlying Wasm interface. For example:const response = await fetch(\"https://example.com/users\");undefinedYou can find a complete example of using outbound HTTP in the JavaScript SDK repository on undefinedundefined: fetch currently only works when building for the HTTP trigger.{{ blockEnd }}{{ startTab \"Python\"}}undefinedHTTP functions and classes are available in the http module. The function name is undefined. The undefined is Request, and the undefined is Response. For example:from spin_sdk.http import Request, Response, send\nresponse = send(Request(\"GET\", \"https://random-data-api.fermyon.app/animals/json\", {}, None))undefinedundefinedundefinedundefinedundefinedYou can find a complete example for using outbound HTTP in the undefined.{{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedHTTP functions are available in the github.com/fermyon/spin/sdk/go/v2/http package. undefined The general function is named Send, but the Go SDK also surfaces individual functions, with request-specific parameters, for the Get and Post operations. For example:import (\n\tspinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n)\n\nres1, err1 := spinhttp.Get(\"https://random-data-api.fermyon.app/animals/json\")\nres2, err2 := spinhttp.Post(\"https://example.com/users\", \"application/json\", json)\n\nrequest, err := http.NewRequest(\"PUT\", \"https://example.com/users/1\", bytes.NewBufferString(user1))\nrequest.Header.Add(\"content-type\", \"application/json\")\nres3, err3 := spinhttp.Send(req)\nundefinedundefinedundefinedundefinedYou can find a complete example for using outbound HTTP in the undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/http-outbound#using-http-from-applications"},{"project":"v3","title":"Making HTTP Requests","subheading":"Restrictions","content":"Spin applications cannot set the Host header on outbound requests. (This is a limitation of the Wasmtime runtime which underpins Spin.)","keywords":"","subsectionKeywords":"","url":"/v3/http-outbound#restrictions"},{"project":"v3","title":"Making HTTP Requests","subheading":"Granting HTTP Permissions to Components","content":"By default, Spin components are not allowed to make outgoing HTTP requests. This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing. To grant a component permission to make HTTP requests to a particular host, use the allowed_outbound_hosts field in the component manifest:[component.example]\nallowed_outbound_hosts = [ \"https://random-data-api.fermyon.app\", \"http://api.example.com:8080\" ]The Wasm module can make HTTP requests undefined to the specified hosts. If a port is specified, the module can make requests only to that port; otherwise, the module can make requests only on the default port for the scheme. Requests to other hosts (or ports) will fail with an error.You can use a wildcard to allow requests to any subdomain of a domain:[component.example]\nallowed_outbound_hosts = [ \"https://*.example.com\" ]You can also pass an IPv4 CIDR address:[component.example]\nallowed_outbound_hosts = [ \"https://192.168.1.0/24\" ]For development-time convenience, you can also pass the string \"https://*:*\" in the allowed_outbound_hosts collection. This allows the Wasm module to make HTTP requests to undefined host and on any port. However, once you've determined which hosts your code needs, you should remove this string and list the hosts instead.  Other Spin implementations may restrict host access and disallow components that ask to connect to anything and everything!","keywords":"","subsectionKeywords":"","url":"/v3/http-outbound#granting-http-permissions-to-components"},{"project":"v3","title":"Making HTTP Requests","subheading":"Configuration-Based Permissions","content":"You can use undefined in the allowed_outbound_hosts field. However, this feature is not yet available on Fermyon Cloud.","keywords":"","subsectionKeywords":"","url":"/v3/http-outbound#configuration-based-permissions"},{"project":"v3","title":"Making HTTP Requests","subheading":"Making HTTP Requests Within an Application","content":"If your Spin application functions as a set of microservices, you'll often want to make requests directly from one component to another within the same application. It's best not to use a full URL for this, because that's not portable across different deployment environments - the URL in the cloud is different from the one in your development environment. Instead, Spin provides two ways to make inter-component requests:undefinedundefinedBoth of these work only from HTTP components. That is, if you want to make an intra-application request from, say, a Redis trigger, you must use a full URL.","keywords":"","subsectionKeywords":"","url":"/v3/http-outbound#making-http-requests-within-an-application"},{"project":"v3","title":"Making HTTP Requests","subheading":"Local Service Chaining","content":"To make an HTTP request to another component in your application, use the special <component-id>.spin.internal host name. For example, an outbound HTTP request to authz.spin.internal will be handled by the authz component.In this way of doing self-requests, the request is passed in memory without ever leaving the Spin host process. This is extremely fast, as the two components are wired almost directly together, but may reduce deployment flexibility depending on the nature of the microservices. Also, public components that are the target of service chaining requests may see URLs in both routed and chained forms: therefore, if they parse the URL (for example, extracting a resource identifier from the path), they must ensure both forms are correctly handled.undefinedYou must still grant permission by including the relevant spin.internal hosts in allowed_outbound_hosts:allowed_outbound_hosts = [\"http://authz.spin.internal\", \"https://reporting.spin.internal\"]To allow local chaining to undefined component in your application, you can use a subdomain wildcard:allowed_outbound_hosts = [\"http://*.spin.internal\"]However, the wildcard implies that the component requires undefined components to be local to it. You will therefore not be able to use undefined for an application that uses wildcard service chaining.undefined","keywords":"","subsectionKeywords":"","url":"/v3/http-outbound#local-service-chaining"},{"project":"v3","title":"Making HTTP Requests","subheading":"Intra-Application HTTP Requests by Route","content":"To make an HTTP request to another route with your application, you can pass just the route as the URL. For example, if you make an outbound HTTP request to /api/customers/, Spin prepends the route with whatever host the application is running on. It also replaces the URL scheme (http or https) with the scheme of the current HTTP request. For example, if the application is running in the cloud, Spin changes /api to https://.../api.In this way of doing self-requests, the request undergoes normal HTTP processing once Spin has prepended the host. For example, in a cloud deployment, the request passes through the network, and potentially back in through a load balancer or other gateway. The benefit of this is that it allows load to be distributed across the environment, but it may count against your use of bandwidth.You must still grant permission by including self in allowed_outbound_hosts:allowed_outbound_hosts = [\"http://self\", \"https://self\"]","keywords":"","subsectionKeywords":"","url":"/v3/http-outbound#intra-application-http-requests-by-route"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedHTTP applications are an important workload in event-driven environments,\nand Spin has built-in support for creating and running HTTP\ncomponents. This page covers Spin options that are specific to HTTP.The HTTP trigger type in Spin is a web server. When an application has HTTP triggers, Spin listens for incoming requests and,\nbased on the undefined, it routes them to a\ncomponent, which provides an HTTP response.","subsectionKeywords":"","url":"/v3/http-trigger"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Specifying an HTTP Trigger","content":"An HTTP trigger maps an HTTP route to a component.  For example:[[trigger.http]]\nroute = \"/...\"                # the route that the trigger matches\ncomponent = \"my-application\"  # the name of the component to handle this routeSuch a trigger says that HTTP requests matching the specified undefined should be handled by the specified undefined. The component field works the same way across all triggers - see undefined for the details.undefined","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#specifying-an-http-trigger"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"HTTP Trigger Routes","content":"An HTTP route may be undefined or undefined.An undefined route matches only the given route.  This is the default behavior.  For example, /cart matches only /cart, and not /cart/checkout:# Run the `shopping-cart` component when the application receives a request to `/cart`...\n[[trigger.http]]\nroute = \"/cart\"\ncomponent = \"shopping-cart\"\n\n# ...and the `checkout` component for `/cart/checkout`\n[[trigger.http]]\nroute = \"/cart/checkout\"\ncomponent = \"checkout\"You can use wildcards to match 'patterns' of routes. Spin supports two kinds of wildcards: single-segment wildcards and trailing wildcards.A single-segment wildcard uses the syntax :name, where name is a name that identifies the wildcard. Such a wildcard will match only a single segment of a path, and allows further matching on segments beyond it. For example, /users/:userid/edit matches /users/1/edit and /users/alice/edit, but does not match /users, /users/1, or /users/1/edit/cart.A trailing wildcard uses the syntax /... and matches the given route and any route under it.  For example, /users/... matches /users, /users/1, /users/1/edit, and so on. Any of these routes will run the mapped component.undefinedundefined[[trigger.http]]\n# Run the `user-manager` component when the application receives a request to `/users`\n# or any path beginning with `/users/`\nroute = \"/users/...\"\ncomponent = \"user-manager\"","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#http-trigger-routes"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Resolving Overlapping Routes","content":"If multiple triggers could potentially handle the same request based on their\ndefined routes, the trigger whose route has the longest matching prefix\ntakes precedence.  This also means that exact matches take precedence over wildcard matches.In the following example, requests starting with the  /users/ prefix (e.g. /users/1)\nwill be handled by user-manager, even though it is also matched by the shop route, because the /users prefix is longer than /.\nBut requests to /users/admin will be handled by the admin component, not user-manager, because that is a more exact match still:# spin.toml\n\n[[trigger.http]]\nroute = \"/users/...\"\ncomponent = \"user-manager\"\n\n[[trigger.http]]\nroute = \"/users/admin\"\ncomponent = \"admin\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"shop\"","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#resolving-overlapping-routes"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Private Endpoints","content":"Private endpoints are where an internal microservice is not exposed to the network (does not have an HTTP route) and so is accessible only from within the application.[[trigger.http]]\nroute = { private = true }\ncomponent = \"internal\"To access a private endpoint, use undefined (where the request is passed in memory without ever leaving the Spin host process). Such calls still require the internal endpoint to be included in allowed_outbound_hosts.","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#private-endpoints"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Reserved Routes","content":"Every HTTP application automatically has a special route always configured at /.well-known/spin/....  This route takes priority over any routes in the application: that is, the Spin runtime handles requests to this route, and the application never sees such requests.You can use paths within this route for health and status checking. The following are currently defined:undefinedundefinedOther paths within the reserved space currently return 404 Not Found.","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#reserved-routes"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Authoring HTTP Components","content":"undefinedBy default, Spin runs components using the undefined.  In this model, the Wasm module exports a well-known interface that Spin calls to handle the HTTP request.","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#authoring-http-components"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"The Request Handler","content":"The exact signature of the HTTP handler, and how a function is identified to be exported as the handler, will depend on your language.{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedIn Rust, the handler is identified by the undefined attribute.  The handler function can have one of two forms: undefined or undefined.undefinedThis form of handler function receives the request as an argument, and returns the response as the return value of the function. For example:#[http_component]\nasync fn handle(request: http::Request) -> anyhow::Result<http::Response> { ... }In this form, nothing is sent to the client until the entire response is ready. It is convenient for many use cases, but is not suitable for streaming responses.undefinedYou have some flexibility in choosing the types of the request and response.  The request may be:undefinedundefinedundefinedundefinedThe response may be:undefinedundefinedundefinedundefinedFor example:use http::{Request, Response};\nuse spin_sdk::http::IntoResponse;\nuse spin_sdk::http_component;\n\n/// A simple Spin HTTP component.\n#[http_component]\nasync fn handle_hello_rust(_req: Request<()>) -> anyhow::Result<impl IntoResponse> {\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, Fermyon\")?)\n}undefinedTo extract data from the request, specify a body type as the generic parameter for the Request type. You can use raw content types such as Vec<u8> and String, or automatically deserialize a JSON body by using the spin_sdk::http::Json<T> type.undefinedIn this form, the handler function receives the request as an argument of type undefined. It also receives an argument of type undefined, through which is sends the response. The function does not return a value. This form is recommended for streaming responses.To send a response:undefinedundefinedundefinedundefinedundefineduse futures::SinkExt;\nuse spin_sdk::http::{Headers, IncomingRequest, OutgoingResponse, ResponseOutparam};\nuse spin_sdk::http_component;\n\n/// A streaming Spin HTTP component.\n#[http_component]\nasync fn handle_hello_rust(_req: IncomingRequest, response_out: ResponseOutparam) {\n    // Status code and headers must be supplied before calling take_body\n    let response = OutgoingResponse::new(\n        200,\n        &Headers::new(&[(\"content-type\".to_string(), b\"text/plain\".to_vec())]),\n    );\n    // Get the sink for writing the body into. This must be mutable!\n    let mut body = response.take_body();\n\n    // Connect the OutgoingResponse to the ResponseOutparam.\n    response_out.set(response);\n\n    // Write to the body sink over a period of time. (In this case we simulate a\n    // long-running operation by manually calling `thread::sleep`.)\n    for i in 1..20 {\n        let payload = format!(\"Hello {i}\\n\");\n        if let Err(e) = body.send(payload.into()).await {\n            eprintln!(\"Error sending payload: {e:#}\");\n            return;\n        }\n        std::thread::sleep(std::time::Duration::from_millis(100));\n    }\n}For a full Rust SDK reference, see the undefined.{{ blockEnd }}{{ startTab \"TypeScript\"}}undefinedThe user must a define a function named handler which the SDK attaches to the undefined. Note that the incoming HTTP event is translated to a FetchEvent.The handler function takes in two arguments a undefined and a undefinedimport { ResponseBuilder } from \"@fermyon/spin-sdk\";\n\nexport async function handler(req: Request, res: ResponseBuilder) {\n    console.log(req);\n    res.send(\"hello universe\");\n}{{ blockEnd }}{{ startTab \"Python\"}}undefinedIn Python, the application must define a top-level class named IncomingHandler which inherits from undefined, overriding the handle_request method.from spin_sdk import http\nfrom spin_sdk.http import Request, Response\n\nclass IncomingHandler(http.IncomingHandler):\n      def handle_request(self, request: Request) -> Response:\n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(\"Hello from Python!\", \"utf-8\")\n        ){{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedIn Go, you register the handler as a callback in your program's init function.  Call spinhttp.Handle, passing your handler as the sole argument.  Your handler takes a http.Request record, from the standard net/http package, and a ResponseWriter to construct the response.undefinedpackage main\n\nimport (\n        \"fmt\"\n        \"net/http\"\n\n        spinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n)\n\nfunc init() {\n        spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n                w.Header().Set(\"Content-Type\", \"text/plain\")\n                fmt.Fprintln(w, \"Hello Fermyon!\")\n        })\n}\n\nfunc main() {}undefined{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#the-request-handler"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Getting Request and Response Information","content":"Exactly how the Spin SDK surfaces the request and response types varies from language to language; this section calls out general features.undefined","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#getting-request-and-response-information"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Additional Request Information","content":"As well as any headers passed by the client, Spin sets several headers on the request passed to your component, which you can use to access additional information about the HTTP request.undefinedundefined| Header Name                  | Value                | Example |\n|------------------------------|----------------------|---------|\n| spin-full-url              | The full URL of the request. This includes full host and scheme information. | https://example.com:8080/users/1/cart/items/3/edit?theme=pink |\n| spin-path-info             | The request path relative to the component route | /items/3/edit |\n| spin-path-match-n          | Where n is the pattern for our single-segment wildcard value (e.g. spin-path-match-userid will access the value in the URL that represents :userid)  | 1 |\n| spin-matched-route         | The part of the trigger route that was matched by the route (including the wildcard indicator if present) | /users/:userid/cart/... |\n| spin-raw-component-route   | The component route pattern matched, including the wildcard indicator if present | /users/:userid/cart/... |\n| spin-component-route       | The component route pattern matched, undefined any wildcard indicator | /users/:userid/cart |\n| spin-client-addr           | The IP address and port of the client | 127.0.0.1:53152 |","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#additional-request-information"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Inside HTTP Components","content":"For the most part, you'll build HTTP component modules using a language SDK (see the Language Guides section), such as a JavaScript module or a Rust crate.  If you're interested in what happens inside the SDK, or want to implement HTTP components in another language, read on!The HTTP component interface is defined using a WebAssembly Interface (WIT) file.  (undefined).  You can find the latest WITs for Spin HTTP components at undefined.The HTTP types and interfaces are defined in undefined, which tracks undefined.In particular, the entry point for Spin HTTP components is defined in undefined:// incoming-handler.wit\n\ninterface incoming-handler {\n  use types.{incoming-request, response-outparam}\n\n  handle: func(\n    request: incoming-request,\n    response-out: response-outparam\n  )\n}This is the interface that all HTTP components must implement, and which is used by the Spin HTTP executor when instantiating and invoking the component.However, this is not necessarily the interface you, the component author, work with. It may not even be the interface of the component you build!In many cases, you will use a more idiomatic wrapper provided by the Spin SDK, which implements the \"true\" interface internally. In some cases, you will build a Wasm \"core module\" which implements an earlier version of the Spin HTTP interface, which Spin internally adapts to the \"true\" interface as it loads your module.But if you wish, and if your language supports it, you can implement the incoming-handler interface directly, using tools such as the\nundefined. Spin will happily load and run such a component. This is exactly how Spin SDKs, such as the undefined SDK, are built; as component authoring tools roll out for Go, JavaScript, Python, and other languages, you'll be able to use those tools to build wasi-http handlers and therefore Spin HTTP components.undefined","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#inside-http-components"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"HTTP With Wagi (WebAssembly Gateway Interface)","content":"A number of languages support WASI Preview 1 but not the component model. To enable developers to use these languages, Spin supports an\nHTTP executor based on undefined, or the\nWebAssembly Gateway Interface, a project that implements the\nundefined\nspecification for WebAssembly.Wagi allows a module built in any programming language that compiles to undefined\nto handle an HTTP request by passing the HTTP request information to the module's\nstandard input, environment variables, and arguments, and expecting the HTTP\nresponses through the module's standard output.\nThis means that if a language has support for the WebAssembly System Interface,\nit can be used to build Spin HTTP components.\nThe Wagi model is only used to parse the HTTP request and response. Everything\nelse — defining the application, running it, or undefined\nis done the same way as a component that uses the Spin executor.","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#http-with-wagi-webassembly-gateway-interface"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Wagi Component Requirements","content":"Spin uses the component model by default, and cannot detect from the Wasm module alone whether it was built with component model support.  For Wagi components, therefore, you must tell Spin in the component manifest to run them using Wagi instead of 'default' Spin.  To do this, use the executor field in the trigger table:[[trigger.http]]\nroute = \"/\"\ncomponent = \"wagi-test\"\nexecutor = { type = \"wagi\" }undefinedWagi supports non-default entry points, and allows you to pass an arguments string that a program can receive as if it had been passed on the command line. If you need these you can specify them in the executor table. For details, see the undefined.","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#wagi-component-requirements"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Request Handling in Wagi","content":"Building a Wagi component in a particular programming language that can compile\nto wasm32-wasip1 does not require any special libraries — instead,\nundefined can\nbe done by reading the HTTP request from the standard input and environment\nvariables, and sending the HTTP response to the module's standard output.In pseudo-code, this is the minimum required in a Wagi component:undefinedundefinedundefinedprint(\"content-type: text/html; charset=UTF-8\\n\\n\");\nprint(\"hello world\\n\");Here is a working example, written in undefined,\na programming language that natively targets WebAssembly and WASI but\ndoes not yet support the component model:import Process from \"sys/process\";\nimport Array from \"array\";\n\nprint(\"content-type: text/plain\\n\");\n\n// This will print all the Wagi env variables\nprint(\"==== Environment: ====\");\nArray.forEach(print, Process.env());\n\n// This will print the route path followed by each query\n// param. So /foo?bar=baz will be [\"/foo\", \"bar=baz\"].\nprint(\"==== Args: ====\");\nArray.forEach(print, Process.argv());undefined","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#request-handling-in-wagi"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Wagi HTTP Environment Variables","content":"Wagi passes request metadata to the program through well-known environment variables. The key path-related request variables are:undefinedundefinedundefinedundefinedundefinedFor details, and for a full list of all Wagi environment variables, see\nundefined.","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#wagi-http-environment-variables"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Exposing HTTP Triggers Using HTTPS","content":"When exposing HTTP triggers using HTTPS you must provide spin up with a TLS certificate and a private key. This can be achieved by either using trigger options (--tls-cert and --tls-key) when running the spin up command, or by setting environment variables (SPIN_TLS_CERT and SPIN_TLS_KEY) before running the spin up command.","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#exposing-http-triggers-using-https"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Trigger Options","content":"The spin up command's --tls-cert and --tls-key trigger options provide a way for you to specify both a TLS certificate and a private key (whilst running the spin up command).The --tls-cert option specifies the path to the TLS certificate to use for HTTPS, if this is not set, normal HTTP will be used. The certificate should be in PEM format.The --tls-key option specifies the path to the private key to use for HTTPS, if this is not set, normal HTTP will be used. The key should be in PKCS#8 format.","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#trigger-options"},{"project":"v3","title":"The Spin HTTP Trigger","subheading":"Environment Variables","content":"The spin up command can also automatically use the SPIN_TLS_CERT and SPIN_TLS_KEY environment variables instead of the respective flags (--tls-cert and --tls-key):SPIN_TLS_CERT=<path/to/cert>\nSPIN_TLS_KEY=<path/to/key>Once set, spin up will automatically use these explicitly set environment variables. For example, if using a Linux-based system, you can go ahead and use the export command to set the variables in your session (before you run the spin up command):export SPIN_TLS_CERT=<path/to/cert>\nexport SPIN_TLS_KEY=<path/to/key>","keywords":"","subsectionKeywords":"","url":"/v3/http-trigger#environment-variables"},{"project":"v3","title":"Introducing Spin","subheading":"","content":"{{suh_cards}}\n{{card_element \"sample\" \"Checklist Sample App\" \"A checklist app that persists data in a key value store\" \"https://developer.fermyon.com/hub/preview/sample_checklist\" \"Typescript,Http,Kv\" true }}\n{{card_element \"template\" \"Zola SSG Template\" \"A template for using Zola framework to create a static webpage\" \"https://developer.fermyon.com/hub/preview/template_zola_ssg\" \"rust\" true }}\n{{card_element \"sample\" \"AI-assisted News Summarizer\" \"Read an RSS newsfeed and have AI summarize it for you\" \"https://developer.fermyon.com/hub/preview/sample_newsreader_ai\" \"Typescript,Javascript,Ai\" true }}\n{{blockEnd}}Spin is a framework for building and running event-driven microservice applications with WebAssembly (Wasm) components.Spin uses Wasm because it is undefined.  Millisecond cold start times mean no need to keep applications \"warm\".Many languages have Wasm implementations, so undefined.Spin is undefined and undefined, meaning you can take your Spin applications anywhere.  There are Spin implementations for local development, for self-hosted servers, for Kubernetes, and for cloud-hosted services.undefined  Check out what's undefined!Or dive into the documentation and get started:undefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v3/index"},{"project":"v3","title":"Install Spin","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefined","keywords":"install","subsectionKeywords":"","url":"/v3/install"},{"project":"v3","title":"Install Spin","subheading":"Installing Spin","content":"Spin runs on Linux (amd64 and arm64), macOS (Intel and Apple Silicon), and Windows (amd64):{{ tabs \"os\" }}{{ startTab \"Linux\"}}undefinedYou can manage your Spin installation via undefined. Homebrew automatically installs Spin templates and Spin plugins, and on uninstall, will prompt you to delete the directory where the templates and plugins were downloaded:Install the Fermyon tap, which Homebrew tracks, updates, and installs Spin from:$ brew tap fermyon/tapInstall Spin:$ brew install fermyon/tap/spinundefinedundefinedAnother option (other than brew) is to use our installer script. The installer script installs Spin along with a starter set of language templates and plugins:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bashOnce you have run the installer script, it is highly recommended to add Spin to a folder, which is on your path, e.g.:$ sudo mv spin /usr/local/bin/undefinedTo install a specific version (v1.2.3 is just an example), you can pass arguments to the install script this way:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v v1.2.3To install the canary version of spin, you should pass the argument -v canary. The canary version is always the latest commit to the main branch of Spin:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v canary{{ blockEnd }}{{ startTab \"macOS\"}}undefinedYou can manage your Spin installation via undefined. Homebrew automatically installs Spin templates and Spin plugins, and on uninstall, will prompt you to delete the directory where the templates and plugins were downloaded:Install the Fermyon tap, which Homebrew tracks, updates, and installs Spin from:$ brew tap fermyon/tapInstall Spin:$ brew install fermyon/tap/spinundefinedundefinedAnother option (other than brew) is to use our installer script. The installer script installs Spin along with a starter set of language templates and plugins:The installer script also installs Spin along with a starter set of language templates and plugins:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bashOnce you have run the installer script, it is highly recommended to add Spin to a folder, which is on your path, e.g.:$ sudo mv spin /usr/local/bin/undefinedTo install a specific version (v1.2.3 is just an example), you can pass arguments to the install script this way:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v v1.2.3To install the canary version of spin, you should pass the argument -v canary. The canary version is always the latest commit to the main branch of Spin:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v canary{{ blockEnd }}{{ startTab \"Windows\"}}If using Windows (PowerShell / cmd.exe), you can download <a href=\"https://github.com/spinframework/spin/releases/latest\" class=\"spin-install\" id=\"spin-install-windows\">the Windows binary release of Spin</a>.Simply unzip the binary release and place the spin.exe in your system path.This does not install any Spin templates or plugins. For a starter list, see the undefined.If you want to use WSL2 (Windows Subsystem for Linux 2), please follow the instructions for using Linux.{{ blockEnd }}\n{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/install#installing-spin"},{"project":"v3","title":"Install Spin","subheading":"Verifying the Release Signature","content":"The Spin project undefined using undefined, a project that helps with signing software and undefined. Consumers of Spin releases can validate the integrity of the package they downloaded by performing a validation of the artifact against the signature present in the public log. Specifically, users get two main guarantees by verifying the signature: 1) that the author of the artifact is indeed the one expected (i.e. the build infrastructure associated with the Spin project, at a given revision that can be inspected), and 2) that the content generated by the build infrastructure has not been tampered with.To verify the release signature, first undefined. This is the CLI tool that we will use validate the signature.\nThe same directory where the installation script was run should also contain a signature of the Spin binary and the certificate used to perform the signature. The following command will perform the signature verification using the cosign CLI:$ cosign verify-blob \\\n    --signature spin.sig \\\n    --certificate crt.pem \\\n    --certificate-identity https://github.com/spinframework/spin/.github/workflows/release.yml@refs/tags/<version> \\\n    --certificate-oidc-issuer https://token.actions.githubusercontent.com \\\n    # --certificate-github-workflow-sha <optionally, pass the commit SHA associated with the tag> \\\n    ./spin\nVerified OKYou can now move the Spin binary to the path knowing that it was indeed built by the infrastructure associated with the Spin project, and that it has not been tampered with since the build.","keywords":"","subsectionKeywords":"","url":"/v3/install#verifying-the-release-signature"},{"project":"v3","title":"Install Spin","subheading":"Building Spin From Source","content":"undefined for a detailed guide on building Spin from source:$ git clone https://github.com/spinframework/spin\n$ cd spin && make build\n$ ./target/release/spin --helpundefined$ sudo apt-get install build-essential libssl-dev pkg-configThis does not install any Spin templates or plugins. For a starter list, see the undefined.","keywords":"","subsectionKeywords":"","url":"/v3/install#building-spin-from-source"},{"project":"v3","title":"Install Spin","subheading":"Using Cargo to Install Spin","content":"If you have undefined, you can clone the repo and install it to your path.undefined$ git clone https://github.com/spinframework/spin\n$ cd spin\n$ # Check out the latest tagged release\n$ # git checkout <latest release>\n$ rustup target add wasm32-wasip1\n$ rustup target add wasm32-unknown-unknown\n$ cargo install --locked --path .\n$ spin --helpundefined$ rustup updateInstalling Spin from source does not install any Spin templates or plugins. For a starter list, see the undefined.","keywords":"","subsectionKeywords":"","url":"/v3/install#using-cargo-to-install-spin"},{"project":"v3","title":"Install Spin","subheading":"Installing Templates and Plugins","content":"Spin has a variety of templates and plugins to make it easier to create Spin applications in your favorite programming language. undefined automatically installs a starter set of templates and plugins, namely templates from the Spin repository and JavaScript and Python toolchain plugins and the Fermyon Cloud plugin.If you used a different installation method, we recommend you install these templates and plugins manually, as follows.","keywords":"","subsectionKeywords":"","url":"/v3/install#installing-templates-and-plugins"},{"project":"v3","title":"Install Spin","subheading":"Templates","content":"Rust, Go and miscellaneous other languages:$ spin templates install --git https://github.com/spinframework/spin --upgradePython:$ spin templates install --git https://github.com/spinframework/spin-python-sdk --upgradeJavaScript and TypeScript:$ spin templates install --git https://github.com/spinframework/spin-js-sdk --upgradeTo list installed templates, run:$ spin templates listFor more information please read the undefined section of the documentation.","keywords":"","subsectionKeywords":"","url":"/v3/install#templates"},{"project":"v3","title":"Install Spin","subheading":"Plugins","content":"First update the local cache by running the spin plugins update command:$ spin plugins updateThen install plugins by name.Fermyon Cloud:$ spin plugins install cloud --yesTo list available plugins, run:$ spin plugins searchFor more information, please visit the undefined section of the documentation.","keywords":"","subsectionKeywords":"","url":"/v3/install#plugins"},{"project":"v3","title":"Install Spin","subheading":"Next Steps","content":"{{suh_cards}}\n{{card_element \"sample\" \"Checklist Sample App\" \"A checklist app that persists data in a key value store\" \"https://developer.fermyon.com/hub/preview/sample_checklist\" \"Typescript,Http,Kv\" true }}\n{{card_element \"template\" \"Zola SSG Template\" \"A template for using Zola framework to create a static webpage\" \"https://developer.fermyon.com/hub/preview/template_zola_ssg\" \"rust\" true }}\n{{card_element \"sample\" \"AI-assisted News Summarizer\" \"Read an RSS newsfeed and have AI summarize it for you\" \"https://developer.fermyon.com/hub/preview/sample_newsreader_ai\" \"Typescript,Javascript,Ai\" true }}\n{{blockEnd}}","keywords":"","subsectionKeywords":"","url":"/v3/install#next-steps"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedWith JavaScript being a very popular language, Spin provides an SDK to support building components. The development of the JavaScript SDK is continually being worked on to improve user experience and add features. The SDK is based on undefined.undefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v3/javascript-components"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"Installing Templates","content":"The JavaScript/TypeScript templates can be installed from undefined using the following command:$ spin templates install --git https://github.com/spinframework/spin-js-sdk --updatewhich will install the http-js and http-ts templates:Copying remote template source\nInstalling template http-ts...\nInstalling template http-js...\nInstalled 2 template(s)\n\n+-------------------------------------------------+\n| Name      Description                           |\n+=================================================+\n| http-js   HTTP request handler using Javascript |\n| http-ts   HTTP request handler using Typescript |\n+-------------------------------------------------+","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#installing-templates"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"Structure of a JS/TS Component","content":"A new JS/TS component can be created using the following command:$ spin new -t http-ts hello-world --accept-defaultsThis creates a directory of the following structure:hello-world\n├── config\n│   └── knitwit.json\n├── package.json\n├── spin.toml\n├── src\n│   └── index.ts\n├── tsconfig.json\n└── webpack.config.jsThe source for the component is present in src/index.ts. undefined is used to bundle the component into a single .js file which will then be compiled to a .wasm module.{{ details \"Going from JavaScript to Wasm\" \"The JS source is compiled to a wasm module using the j2w node executable provided by the @fermyon/spin-sdk which is a wrapper around ComponentizeJS. The knitwit.json is the configuration file used by undefined to manage the WebAssembly dependencies of each package.\"}}","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#structure-of-a-jsts-component"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"Building and Running the Template","content":"First, the dependencies for the template need to be installed using the following commands:$ cd hello-world\n$ npm installNext step is to use the spin build command to run the build script for the component. Once a Spin compatible module is created, it can be run using spin up:$ spin build\n$ spin upspin build will execute the command in the command key under the [component.<component-name>.build] section from spin.toml for each component in your application. In this case an npm script will be run. The command in the package.json will looks something like:\"scripts\": {\n    \"build\": \"npx webpack --mode=production && npx mkdirp target && npx j2w -i dist.js -d combined-wit -n combined -o target/hello-world.wasm\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  }","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#building-and-running-the-template"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"HTTP Components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, and Javascript/TypeScript has improved support\nfor writing Spin components with the Spin JS/TS SDK.undefinedBuilding a Spin HTTP component with the JavaScript/TypeScript SDK now involves adding an event listener for the fetch event. This event listener handles incoming HTTP requests and allows you to construct and return HTTP responses.Below is a complete implementation for such a component in TypeScript:import { AutoRouter } from 'itty-router';\n\nlet router = AutoRouter();\n\nrouter\n    .get(\"/\", () => new Response(\"hello universe\"))\n    .get('/hello/:name', ({ name }) => `Hello, ${name}!`)\n\n//@ts-ignore\naddEventListener('fetch', async (event: FetchEvent) => {\n    event.respondWith(router.fetch(event.request));\n});\n","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#http-components"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"Sending Outbound HTTP Requests","content":"If allowed, Spin components can send outbound HTTP requests.\nLet's see an example of a component that makes a request to undefinedimport { AutoRouter } from 'itty-router';\n\nlet router = AutoRouter();\n\nrouter\n    .get(\"*\", getDataFromAPI)\n\nasync function getDataFromAPI(_request: Request) {\n    let response = await fetch(\n        'https://random-data-api.fermyon.app/physics/json',\n    );\n    let data = await response.json();\n    let fact = `Here is a fact: ${data.fact}`;\n    return new Response(fact);\n}\n\n//@ts-ignore\naddEventListener('fetch', async (event: FetchEvent) => {\n    event.respondWith(router.fetch(event.request));\n});\nBefore we can execute this component, we need to add the random-data-api.fermyon.app\ndomain to the application manifest allowed_outbound_hosts list containing the list of\ndomains the component is allowed to make HTTP requests to:spin_manifest_version = 2\n\n[application]\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\nname = \"hello-world\"\nversion = \"0.1.0\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nsource = \"target/hello-world.wasm\"\nexclude_files = [\"**/node_modules\"]\nallowed_outbound_hosts = [\"https://random-data-api.fermyon.app\"]\n[component.hello-world.build]\ncommand = \"npm run build\"The component can be built using the spin build command. Running the application using spin up will start the HTTP listener locally (by default on localhost:3000):$ curl -i localhost:3000\nHTTP/1.1 200 OK\ndate = \"2023-11-04T00:00:01Z\"\ncontent-type: application/json; charset=utf-8\ncontent-length: 185\nserver: spin/0.1.0\n\nHere is a fact: Reindeer grow new antlers every yearundefinedundefinedWe just built a WebAssembly component that sends an HTTP request to another\nservice, manipulates that result, then responds to the original request.\nThis can be the basis for building components that communicate with external\ndatabases or storage accounts, or even more specialized components like HTTP\nproxies or URL shorteners.","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#sending-outbound-http-requests"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"Storing Data in Redis From JS/TS Components","content":"undefinedUsing the Spin's JS SDK, you can use the Redis key/value store and to publish messages to Redis channels.Let's see how we can use the JS/TS SDK to connect to Redis:import { AutoRouter } from 'itty-router';\nimport { Redis } from '@fermyon/spin-sdk';\n\nconst encoder = new TextEncoder();\nconst redisAddress = 'redis://localhost:6379/';\n\nlet router = AutoRouter();\n\nrouter\n    .get(\"/\", () => {\n        try {\n            let db = Redis.open(redisAddress);\n            db.set('test', encoder.encode('Hello world'));\n            let val = db.get('test');\n\n            if (!val) {\n                return new Response(null, { status: 404 });\n            }\n            return new Response(val);\n        } catch (e: any) {\n            return new Response(`Error: ${JSON.stringify(e.payload)}`, { status: 500 });\n        }\n    })\n\n//@ts-ignore\naddEventListener('fetch', async (event: FetchEvent) => {\n    event.respondWith(router.fetch(event.request));\n});\nThis HTTP component demonstrates fetching a value from Redis by key, setting a key with a value, and publishing a message to a Redis channel.undefinedAs with all networking APIs, you must grant access to Redis hosts via the allowed_outbound_hosts field in the application manifest:[component.storage-demo]\nallowed_outbound_hosts = [\"redis://localhost:6379\"]","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#storing-data-in-redis-from-jsts-components"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"Storing Data in the Spin Key-Value Store","content":"Spin has a key-value store built in. For information about using it from TypeScript/JavaScript, see undefined.","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#storing-data-in-the-spin-key-value-store"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"Storing Data in SQLite","content":"For more information about using SQLite from TypeScript/Javascript, see undefined.","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#storing-data-in-sqlite"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"Storing Data in MySQL and PostgreSQL Relational Databases","content":"For more information about using relational databases from TypeScript/JavaScript, see undefined.","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#storing-data-in-mysql-and-postgresql-relational-databases"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"AI Inferencing From JS/TS Components","content":"For more information about using Serverless AI from JS/TS, see the undefined API guide.","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#ai-inferencing-from-jsts-components"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"Node.js Compatibility","content":"The SDK does not support the full specification of Node.js. A limited set of APIs can be polyfilled using the undefined library which provides a webpack plugin. It can be used by installing the  library first using:$ npm install @fermyon/wasi-extOnce installed, the plugin provided by it can be added to the webpack config:const WasiExtPlugin = require(\"wasi-ext/plugin\")\n\nmodule.exports = {\n    ...\n    plugins: [\n        new WasiExtPlugin()\n    ],\n    ...\n};This library only currently supports the following polyfills:undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#nodejs-compatibility"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"Using External NPM Libraries","content":"undefinedSome NPM packages can be installed and used in the component. If a popular library does not work, please open an issue/feature request in the undefined.","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#using-external-npm-libraries"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"Suggested Libraries for Common Tasks","content":"These are some of the suggested libraries that have been tested and confirmed to work with the SDK for common tasks.{{ details \"HTML parsers\" \"- undefined\" }}{{ details \"Parsing formdata\" \"- undefined\" }}{{ details \"Runtime schema validation\" \"- undefined\" }}{{ details \"Unique ID generator\" \"- undefined\\n- undefined\\n- undefined\" }}","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#suggested-libraries-for-common-tasks"},{"project":"v3","title":"Building Spin Components in JavaScript","subheading":"Caveats","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/javascript-components#caveats"},{"project":"v3","title":"Spin Key-Value Store","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v3/key-value-store-tutorial"},{"project":"v3","title":"Spin Key-Value Store","subheading":"Key Value Store With Spin Applications","content":"Spin applications are best suited for event-driven, stateless workloads that have low-latency requirements. Keeping track of the application's state (storing information) is an integral part of any useful product or service. For example, users (and the business) will expect to store and load data/information at all times during an application’s execution. Spin has support for applications that need data in the form of key/value pairs and are satisfied by a Basically Available, Soft State, and Eventually Consistent (BASE) model. Workload examples include general value caching, session caching, counters, and serialized application state. In this tutorial, you will learn how to do the following:undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/key-value-store-tutorial#key-value-store-with-spin-applications"},{"project":"v3","title":"Spin Key-Value Store","subheading":"Tutorial Prerequisites","content":"First, follow undefined to install Spin. To ensure you have the correct version, you can check with this command:$ spin --versionundefined","keywords":"","subsectionKeywords":"","url":"/v3/key-value-store-tutorial#tutorial-prerequisites"},{"project":"v3","title":"Spin Key-Value Store","subheading":"Python","content":"If you are planning on using Python for this tutorial, please ensure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.","keywords":"","subsectionKeywords":"","url":"/v3/key-value-store-tutorial#python"},{"project":"v3","title":"Spin Key-Value Store","subheading":"Creating a New Spin Application","content":"Let's create a Spin application that will send and retrieve data from a key value store. To make things easy, we'll start from a template using the following commands (undefined):{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}$ spin new -t http-rust spin-key-value\n\n# Reference: https://github.com/spinframework/spin-rust-sdk/tree/stable/examples/rust-key-value{{ blockEnd }}{{ startTab \"TypeScript\" }}$ spin new -t http-ts spin-key-value\n\n# Reference: https://github.com/spinframework/spin-js-sdk/tree/main/examples/spin-host-apis/spin-kv{{ blockEnd }}{{ startTab \"Python\" }}$ spin new -t http-py spin-key-value\n\n# Reference: https://github.com/spinframework/spin-python-sdk/tree/main/examples/spin-kv{{ blockEnd }}{{ startTab \"TinyGo\" }}$ spin new -t http-go spin-key-value\n\n# Reference: https://github.com/spinframework/spin-go-sdk/tree/stable/examples/key-value{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/key-value-store-tutorial#creating-a-new-spin-application"},{"project":"v3","title":"Spin Key-Value Store","subheading":"Configuration","content":"Good news - Spin will take care of setting up your Key Value store. However, in order to make sure your Spin application has permission to access the Key Value store, you must add the key_value_stores = [\"default\"] line in the [component.<component-name>] section of the spin.toml file, for each component which needs access to the Key Value store. This line is necessary to communicate to Spin that a given component has access to the default Key Value store. A newly scaffolded Spin application will not have this line; you will need to add it.undefined[component.spin_key_value]\n...\nkey_value_stores = [\"default\"]\n...undefinedEach Spin application's key_value_stores instances are implemented on a per-component basis across the entire Spin application. This means that within a multi-component Spin application (which has the same key_value_stores = [\"default\"] configuration line), each component will access that same data store. If one of your application's components creates a new key/value pair, another one of your application's components can update/overwrite that initial key/value after the fact.","keywords":"","subsectionKeywords":"","url":"/v3/key-value-store-tutorial#configuration"},{"project":"v3","title":"Spin Key-Value Store","subheading":"The Spin TOML File","content":"We will give our components access to the key value store by adding the key_value_stores = [\"default\"] in the `[component.<component-name>] section as shown below:spin_manifest_version = 2\n\n[application]\nname = \"spin-key-value\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"A simple application that exercises key-value storage.\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"spin-key-value\"\n\n[component.spin-key-value]\n...\nkey_value_stores = [\"default\"]\n...","keywords":"","subsectionKeywords":"","url":"/v3/key-value-store-tutorial#the-spin-toml-file"},{"project":"v3","title":"Spin Key-Value Store","subheading":"Write Code to Save and Load Data","content":"In this section, we use the Spin SDK to open and persist our application's data inside our default key/value store. This is a special store that every environment running Spin applications will make available for their application.","keywords":"","subsectionKeywords":"","url":"/v3/key-value-store-tutorial#write-code-to-save-and-load-data"},{"project":"v3","title":"Spin Key-Value Store","subheading":"The Spin SDK Version","content":"If you have an existing application and would like to try out the key/value feature, please check the Spin SDK reference in your existing application's configuration. It is highly recommended to upgrade Spin and the SDK versions to the latest version available.","keywords":"","subsectionKeywords":"","url":"/v3/key-value-store-tutorial#the-spin-sdk-version"},{"project":"v3","title":"Spin Key-Value Store","subheading":"Source Code","content":"Now let's use the Spin SDK to:undefinedundefinedundefinedundefinedundefined{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}use spin_sdk::{\n    http::{IntoResponse, Request, Response, Method},\n    http_component,\n    key_value::Store,\n};\n\n#[http_component]\nfn handle_request(req: Request) -> anyhow::Result<impl IntoResponse> {\n    // Open the default key-value store\n    let store = Store::open_default()?;\n\n    let (status, body) = match *req.method() {\n        Method::Post => {\n            // Add the request (URI, body) tuple to the store\n            store.set(req.path(), req.body())?;\n            println!(\n                \"Storing value in the KV store with {:?} as the key\",\n                req.path()\n            );\n            (200, None)\n        }\n        Method::Get => {\n            // Get the value associated with the request URI, or return a 404 if it's not present\n            match store.get(req.path())? {\n                Some(value) => {\n                    println!(\"Found value for the key {:?}\", req.path());\n                    (200, Some(value))\n                }\n                None => {\n                    println!(\"No value found for the key {:?}\", req.path());\n                    (404, None)\n                }\n            }\n        }\n        Method::Delete => {\n            // Delete the value associated with the request URI, if present\n            store.delete(req.path())?;\n            println!(\"Delete key {:?}\", req.path());\n            (200, None)\n        }\n        Method::Head => {\n            // Like GET, except do not return the value\n            let code = if store.exists(req.path())? {\n                println!(\"{:?} key found\", req.path());\n                200\n            } else {\n                println!(\"{:?} key not found\", req.path());\n                404\n            };\n            (code, None)\n        }\n        // No other methods are currently supported\n        _ => (405, None),\n    };\n    Ok(Response::new(status, body))\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}import { AutoRouter } from 'itty-router';\nimport { Kv } from '@fermyon/spin-sdk';\n\nconst decoder = new TextDecoder();\n\nlet router = AutoRouter();\n\nrouter\n    .all(\"*\", async (req: Request) => {\n        let store = Kv.openDefault();\n        let status = 200;\n        let body;\n\n        switch (req.method) {\n            case 'POST':\n                store.set(req.url, (await req.bytes()) || new Uint8Array().buffer);\n                break;\n            case 'GET':\n                let val;\n                val = store.get(req.url);\n                if (!val) {\n                    status = 404;\n                } else {\n                    body = decoder.decode(val);\n                }\n                break;\n            case 'DELETE':\n                store.delete(req.url);\n                break;\n            case 'HEAD':\n                if (!store.exists(req.url)) {\n                    status = 404;\n                }\n                break;\n            default:\n        }\n\n        return new Response(body, { status });\n    })\n\n//@ts-ignore\naddEventListener('fetch', async (event: FetchEvent) => {\n    event.respondWith(router.fetch(event.request));\n});\n{{ blockEnd }}{{ startTab \"Python\" }}from spin_sdk import http, key_value\nfrom spin_sdk.http import Request, Response\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        with key_value.open_default() as store:\n            match request.method:\n                case \"GET\":\n                    value = store.get(request.uri)\n                    if value:\n                        status = 200\n                        print(f\"Found key {request.uri}\")\n                    else:\n                        status = 404\n                        print(f\"Key {request.uri} not found\")\n                    return Response( status, {\"content-type\": \"text/plain\"}, value)\n                case \"POST\":\n                    store.set(request.uri, request.body)\n                    print(f\"Stored key {request.uri}\")\n                    return Response(200, {\"content-type\": \"text/plain\"})\n                case \"DELETE\":\n                    store.delete(request.uri)\n                    print(f\"Deleted key {request.uri}\")\n                    return Response(200, {\"content-type\": \"text/plain\"})\n                case \"HEAD\":\n                    if store.exists(request.uri):\n                        print(f\"Found key {request.uri}\")\n                        return Response(200, {\"content-type\": \"text/plain\"})\n                    print(f\"Key not found {request.uri}\")\n                    return Response(404, {\"content-type\": \"text/plain\"})\n                case default:\n                    return Response(405, {\"content-type\": \"text/plain\"}){{ blockEnd }}{{ startTab \"TinyGo\" }}package main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"fmt\"\n\n\tspin_http \"github.com/fermyon/spin/sdk/go/v2/http\"\n\t\"github.com/fermyon/spin/sdk/go/v2/kv\"\n)\n\nfunc init() {\n\t// handler for the http trigger\n\tspin_http.Handle(func(w http.ResponseWriter, r *http.Request) {\n\t\tstore, err := kv.OpenStore(\"default\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer store.Close()\n\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tswitch r.Method {\n\t\tcase http.MethodPost:\n\t\t\terr := store.Set(r.URL.Path, body)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Println(\"Stored the key at:\", r.URL.Path)\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\tcase http.MethodGet:\n\t\t\tvalue, err := store.Get(r.URL.Path)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfmt.Println(\"Got the key:\", r.URL.Path)\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tw.Write(value)\n\t\tcase http.MethodDelete:\n\t\t\terr := store.Delete(r.URL.Path)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Println(\"Deleted the key:\", r.URL.Path)\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\tcase http.MethodHead:\n\t\t\texists, err := store.Exists(r.URL.Path)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif exists {\n\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t\tfmt.Println(\"Found key:\", r.URL.Path)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfmt.Println(\"Didn't find the key:\", r.URL.Path)\n\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\tdefault:\n\t\t\thttp.Error(w, \"method not allowed\", http.StatusMethodNotAllowed)\n\t\t}\n\t})\n}\n\nfunc main() {}\n{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/key-value-store-tutorial#source-code"},{"project":"v3","title":"Spin Key-Value Store","subheading":"Building and Running Your Spin Application","content":"Now, let's build and run our Spin Application locally. Run the following command to build your application:$ spin build\n$ spin upundefined","keywords":"","subsectionKeywords":"","url":"/v3/key-value-store-tutorial#building-and-running-your-spin-application"},{"project":"v3","title":"Spin Key-Value Store","subheading":"Storing and Retrieving Data From Your Default Key/Value Store","content":"Once you have completed this minimal configuration and deployed your application, data will be persisted across requests. Let's begin by creating a POST request that stores a JSON key/value object:# Create a new POST request and set the key/value pair of foo:bar\n$ curl localhost:3000/test -H 'Content-Type: application/json' -d '{\"foo\":\"bar\"}'We can now use a HEAD request to confirm that our component is holding data for us. Essentially, all we want to see here is a 200 OK response when calling our components endpoint (/test). Let's give it a try:$ curl -I localhost:3000/test\n\nHTTP/1.1 200 OKPerfect, 200 OK. Now, let's create a GET request that fetches the data from our component:# Create a GET request and fetch the key/value that we stored in the previous request\n$ curl localhost:3000/test\n\n{\"foo\": \"bar\"}Great! The above command successfully returned our data as intended.Lastly, we show how to create a DELETE request that removes the data for this specific component altogether:$ curl -X DELETE localhost:3000/testNote how all of the above commands returned 200 OK responses. In these examples, we were able to POST, HEAD (check to see if data exists), GET and also DELETE data from our component.Interestingly there is one more request we can re-run before wrapping up this tutorial. If no data exists in the component's endpoint of /test (which is technically the case now that we have sent the DELETE request) the HEAD request should correctly return 404 Not Found. You can consider this a type of litmus test; let's try it out:$ curl -I localhost:3000/test\n\nHTTP/1.1 404 Not FoundAs we can see above, there is currently no data found at the /test endpoint of our application.","keywords":"","subsectionKeywords":"","url":"/v3/key-value-store-tutorial#storing-and-retrieving-data-from-your-default-keyvalue-store"},{"project":"v3","title":"Spin Key-Value Store","subheading":"(Optional) Deploy Your App To Fermyon Cloud","content":"Optionally, if you'd like to deploy your application and key value store to Fermyon Cloud here are the required steps.First, login to your Fermyon Cloud account. If you do not have one already, this will take you through the signup process for a free account.$ spin login\n\nCopy your one-time code:\n\nXXXXXXXX\n\n...and open the authorization page in your browser:\n\nhttps://cloud.fermyon.com/device-authorization\n\nWaiting for device authorization...\nDevice authorized!Now that we have our dependencies squared away, let's deploy our application to Fermyon Cloud. From your application root folder, run the following command and opt to allow Fermyon Cloud to create a key value store on your behalf:$ spin cloud deploy\nspin deploy\nUploading spin-key-value version 0.1.0-r234fe5a4 to Fermyon Cloud...\nDeploying...\nApp \"spin-key-value\" accesses a key value store labeled \"default\"\nWould you like to link an existing key value store or create a new key value store?:\n> Use an existing key value store and link app to it\n  Create a new key value store and link the app to itundefinedCongratulations, you have a Spin application and associated Key Value store running up in Fermyon Cloud! You can visit it by clicking on the Spin application's domain name generated in the CLI output, which has the following pattern: spin-key-value-<RANDOM>.fermyon.app.","keywords":"","subsectionKeywords":"","url":"/v3/key-value-store-tutorial#optional-deploy-your-app-to-fermyon-cloud"},{"project":"v3","title":"Spin Key-Value Store","subheading":"Next Steps","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/key-value-store-tutorial#next-steps"},{"project":"v3","title":"Spin on Kubernetes","subheading":"","content":"","subsectionKeywords":"","url":"/v3/kubernetes"},{"project":"v3","title":"Spin on Kubernetes","subheading":"Why Use Spin With Kubernetes?","content":"In addition to spin up Fermyon also offers Fermyon Cloud to deploy spin apps into production, so why use Spin with Kubernetes? For users that have made existing investments into Kubernetes or have requirements that their applications stay within certain clouds, not be on shared infrastructure, or run on-premise, Kubernetes provides a robust solution.There are a few options for running Spin on Kubernetes:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/kubernetes#why-use-spin-with-kubernetes"},{"project":"v3","title":"Key Value Store","subheading":"","content":"undefinedundefinedundefinedSpin provides an interface for you to persist data in a key value store managed by Spin. This key value store allows Spin developers to persist non-relational data across application invocations. To learn more about key value store use cases and how to enable your Spin application to use a key value store, check out our undefined.{{ details \"Why do I need a Spin interface? Why can't I just use my own external store?\" \"You can absolutely still use your own external store either with the Redis or Postgres APIs, or outbound HTTP. However, if you're interested in quick, non-relational local storage without any infrastructure set-up then Spin's key value store is a great option.\" }}","subsectionKeywords":"","url":"/v3/kv-store-api-guide"},{"project":"v3","title":"Key Value Store","subheading":"Using Key Value Store From Applications","content":"The Spin SDK surfaces the Spin key value store interface to your language. The following characteristics are true of keys and values:undefinedundefinedundefinedThe set of operations is common across all SDKs:| Operation  | Parameters | Returns | Behavior |\n|------------|------------|---------|----------|\n| open  | name | store  | Open the store with the specified name. If name is the string \"default\", the default store is opened, provided that the component that was granted access in the component manifest from spin.toml. Otherwise, name must refer to a store defined and configured in a undefined supplied with the application.|\n| get | store, key | value | Get the value associated with the specified key from the specified store. |\n| set | store, key, value | - | Set the value associated with the specified key in the specified store, overwriting any existing value. |\n| delete | store, key | - | Delete the tuple with the specified key from the specified store. error::invalid-store will be raised if store is not a valid handle to an open store.  No error is raised if a tuple did not previously exist for key.|\n| exists | store, key | boolean | Return whether a tuple exists for the specified key in the specified store.|\n| get-keys | store | list<keys> | Return a list of all the keys in the specified store. |\n| close | store | - | Close the specified store. |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedKey value functions are available in the spin_sdk::key_value module. The function names match the operations above. For example:use anyhow::Result;\nuse spin_sdk::{\n    http::{IntoResponse, Request, Response},\n    http_component,\n    key_value::{Store},\n};\n#[http_component]\nfn handle_request(_req: Request) -> Result<impl IntoResponse> {\n    let store = Store::open_default()?;\n    store.set(\"mykey\", b\"myvalue\")?;\n    let value = store.get(\"mykey\")?;\n    let response = value.unwrap_or_else(|| \"not found\".into());\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(response)\n        .build())\n}undefinedset undefinedundefinedget undefinedundefinedopen and close undefinedundefinedset_json and get_json undefinedundefined{{ blockEnd }}{{ startTab \"Typescript\"}}undefinedThe key value functions can be accessed after opening a store using either undefined which returns a undefined. For example:import { AutoRouter } from 'itty-router';\nimport { Kv } from '@fermyon/spin-sdk';\n\nlet router = AutoRouter();\n\nrouter\n    .get(\"/\", () => {\n        let store = Kv.openDefault()\n        store.set(\"mykey\", \"myvalue\") \n        return new Response(store.get(\"mykey\") ?? \"Key not found\");\n    })\n\n//@ts-ignore\naddEventListener('fetch', async (event: FetchEvent) => {\n    event.respondWith(router.fetch(event.request));\n});undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined and undefinedundefined{{ blockEnd }}{{ startTab \"Python\"}}undefinedThe key value functions are provided through the spin_key_value module in the Python SDK. For example:from spin_sdk import http, key_value\nfrom spin_sdk.http import Request, Response\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        with key_value.open_default() as store:\n            store.set(\"test\", bytes(\"hello world!\", \"utf-8\"))\n            val = store.get(\"test\")\n            \n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            val\n        )\nundefinedundefinedundefinedundefined{{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedKey value functions are provided by the github.com/fermyon/spin/sdk/go/v2/kv module. undefined For example:import \"github.com/fermyon/spin/sdk/go/v2/kv\"\n\nfunc example() error {\n    store, err := kv.OpenStore(\"default\")\n    if err != nil {\n        return err\n    }\n    defer store.Close()\n    previous, err := store.Get(\"mykey\")\n    return store.Set(\"mykey\", []byte(\"myvalue\"))\n}\n{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/kv-store-api-guide#using-key-value-store-from-applications"},{"project":"v3","title":"Key Value Store","subheading":"Custom Key Value Stores","content":"Spin defines a key-value store named \"default\" and provides automatic backing storage.  If you need to customize Spin with additional stores, or to change the backing storage for the default store, you can do so via the --runtime-config-file flag and the runtime-config.toml file.  See undefined for details.","keywords":"","subsectionKeywords":"","url":"/v3/kv-store-api-guide#custom-key-value-stores"},{"project":"v3","title":"Key Value Store","subheading":"Granting Key Value Store Permissions to Components","content":"By default, a given component of an app will not have access to any key value store. Access must be granted specifically to each component via the component manifest:[component.example]\n# Pass in 1 or more key value stores, based on how many you'd like your component to have access to\nkey_value_stores = [\"<store 1>\", \"<store 2>\"]For example, a component could be given access to the default store using key_value_stores = [\"default\"].","keywords":"","subsectionKeywords":"","url":"/v3/kv-store-api-guide#granting-key-value-store-permissions-to-components"},{"project":"v3","title":"Language Support Overview","subheading":"","content":"This page contains information about language support for Spin features:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefined| Feature | SDK Supported? |\n|-----|-----|\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| undefined | Supported |{{ blockEnd }}{{ startTab \"TypeScript\"}}undefined| Feature | SDK Supported? |\n|-----|-----|\n| undefined |\n| undefined | Supported |\n| Redis | Not Supported |\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| Authoring Custom Triggers | Not Supported |{{ blockEnd }}{{ startTab \"Python\"}}undefined| Feature | SDK Supported? |\n|-----|-----|\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| MySQL | Supported |\n| PostgreSQL |  Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Not Supported |\n| undefined |\n| Authoring Custom Triggers | Not Supported |{{ blockEnd }}{{ startTab \"TinyGo\"}}undefined| Feature | SDK Supported? |\n|-----|-----|\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Supported |\n| undefined | Not Supported |\n| undefined |\n| Authoring Custom Triggers | Not Supported |{{ blockEnd }}{{ blockEnd }}","subsectionKeywords":"","url":"/v3/language-support-overview"},{"project":"v3","title":"Managing Plugins","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedPlugins are a way to extend the functionality of Spin. Spin provides commands for installing and removing them, so you don't need to use separate installation tools. When you have installed a plugin into Spin, you can call it as if it were a Spin subcommand. For example, Fermyon Cloud can be accessed with a plugin called cloud, and you run it via the spin cloud command.","subsectionKeywords":"","url":"/v3/managing-plugins"},{"project":"v3","title":"Managing Plugins","subheading":"Installing Plugins","content":"To install plugins, use the spin plugins install command. You can install plugins by name from a curated repository, or other plugins from a URL or file system.","keywords":"","subsectionKeywords":"","url":"/v3/managing-plugins#installing-plugins"},{"project":"v3","title":"Managing Plugins","subheading":"Installing Well Known Plugins","content":"The Spin maintainers curate a catalogue of \"known\" plugins. You can install plugins from this catalogue by name:$ spin plugins install cloudSpin checks that the plugin is available for your version of Spin and your operating system, and prompts you to confirm the installation. To skip the prompt, pass the --yes flag.undefined","keywords":"","subsectionKeywords":"","url":"/v3/managing-plugins#installing-well-known-plugins"},{"project":"v3","title":"Managing Plugins","subheading":"Installing a Specific Version of a Plugin","content":"To install a specific version of a plugin, pass the --version flag:$ spin plugins install cloud --version 0.9.1","keywords":"","subsectionKeywords":"","url":"/v3/managing-plugins#installing-a-specific-version-of-a-plugin"},{"project":"v3","title":"Managing Plugins","subheading":"Installing a Plugin From a URL","content":"If the plugin you want has been published on the Web but has not been added to the catalogue, you can install it from its manifest URL. The manifest is the JSON document that links to the binaries for different operating systems and processors. For example:$ spin plugins install --url https://github.com/spinframework/spin-befunge-sdk/releases/download/v1.4.0/befunge2wasm.json","keywords":"","subsectionKeywords":"","url":"/v3/managing-plugins#installing-a-plugin-from-a-url"},{"project":"v3","title":"Managing Plugins","subheading":"Installing a Plugin From a File","content":"If the plugin you want is in your local file system, you can install it from its manifest file path. The manifest is the JSON document that links to the binaries for different operating systems and processors. For example:$ spin plugins install --file ~/dev/spin-befunge-sdk/befunge2wasm.json","keywords":"","subsectionKeywords":"","url":"/v3/managing-plugins#installing-a-plugin-from-a-file"},{"project":"v3","title":"Managing Plugins","subheading":"Running a Plugin","content":"You run plugins in the same way as built-in Spin subcommands. For example:$ spin cloud --help","keywords":"","subsectionKeywords":"","url":"/v3/managing-plugins#running-a-plugin"},{"project":"v3","title":"Managing Plugins","subheading":"Viewing Available Plugins","content":"To see what plugins are available in the catalogue, run spin plugins search:$ spin plugins search\nbefunge2wasm 1.4.0 [incompatible]\ncloud 0.8.0 [installed]\ncloud 0.9.0\ntrigger-sqs 0.1.0The annotations by the plugins show their status and compatibility:| Annotation                      | Meaning |\n|---------------------------------|---------|\n| [incompatible]                | The plugin does not run on your operating system or processor. |\n| [installed]                   | You have the plugin already installed and available to run. |\n| [requires other Spin version] | The plugin can run on your operating system and processor, but is not compatible with the version of Spin you are running. The annotation indicates which versions of Spin it is compatible with. |","keywords":"","subsectionKeywords":"","url":"/v3/managing-plugins#viewing-available-plugins"},{"project":"v3","title":"Managing Plugins","subheading":"Viewing Installed Plugins","content":"To see only the plugins you have installed, run spin plugins list --installed.","keywords":"","subsectionKeywords":"","url":"/v3/managing-plugins#viewing-installed-plugins"},{"project":"v3","title":"Managing Plugins","subheading":"Uninstalling Plugins","content":"You can uninstall plugins using spin plugins uninstall with the plugin name:$ spin plugins uninstall befunge2wasm","keywords":"","subsectionKeywords":"","url":"/v3/managing-plugins#uninstalling-plugins"},{"project":"v3","title":"Managing Plugins","subheading":"Refreshing the Catalogue","content":"The first time you install a plugin from the catalogue, Spin creates a local cache of the catalogue. It continues to use this local cache for future install, list and upgrade commands; this is similar to OS package managers such as apt, and avoids rate limiting on the catalogue. However, this means that in order to see new catalogue entries - new plugins or new versions - you must first update the cache.To update your local cache of the catalogue, run spin plugins update.","keywords":"","subsectionKeywords":"","url":"/v3/managing-plugins#refreshing-the-catalogue"},{"project":"v3","title":"Managing Plugins","subheading":"Upgrading Plugins","content":"To upgrade a plugin to the latest version, first run spin plugins update (to refresh the catalogue), then spin plugins upgrade.The spin plugins upgrade command has the same options as the spin plugins install command (according to whether the plugin comes from the catalogue, a URL, or a file). For more information, see the command help by running spin plugins upgrade --help.undefinedThe following example shows how to upgrade one plugin at a time (i.e. the cloud plugin):$ spin plugins update\n$ spin plugins upgrade cloudThe following example shows how to upgrade all installed plugins at once:$ spin plugins update\n$ spin plugins upgrade --allundefinedThe following example shows additional upgrade options. Specifically, how to upgrade using the path to a remote plugin manifest and how to upgrade using the path to a local plugin manifest:$ spin plugins upgrade --url https://github.com/spinframework/spin-befunge-sdk/releases/download/v1.7.0/befunge2wasm.json\n$ spin plugins upgrade --file ~/dev/spin-befunge-sdk/befunge2wasm.json","keywords":"","subsectionKeywords":"","url":"/v3/managing-plugins#upgrading-plugins"},{"project":"v3","title":"Managing Plugins","subheading":"Downgrading Plugins","content":"By default, Spin will only undefined plugins. Pass the --downgrade flag and specify the --version if you want Spin to roll back to an earlier version. The following abridged example (which doesn't list the full console output for simplicity) lists the versions of plugins, downgrades the cloud to an older version (0.9.0) and then lists the versions again to show the results:$ spin plugins update\n$ spin plugins list\n// --snip--\ncloud 0.9.0\ncloud 0.9.1 [installed]\n$ spin plugins upgrade cloud --downgrade --version 0.9.0\n$ spin plugins list\n// --snip--\ncloud 0.9.0 [installed]\ncloud 0.9.1After downgrading, the [installed] indicator is aligned with the 0.9.0 version of cloud, as intended in the example.","keywords":"","subsectionKeywords":"","url":"/v3/managing-plugins#downgrading-plugins"},{"project":"v3","title":"Managing Plugins","subheading":"Next Steps","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v3/managing-plugins#next-steps"},{"project":"v3","title":"Managing Templates","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedTemplates are a Spin tool for scaffolding new applications and components. You can use them via the spin new and spin add commands. For more information about creating applications with templates, see undefined.","subsectionKeywords":"","url":"/v3/managing-templates"},{"project":"v3","title":"Managing Templates","subheading":"Installing Templates","content":"undefinedTo install templates, use the spin templates install command. You can install templates from a Git repository, or while undefined you can install them from a local directory.","keywords":"","subsectionKeywords":"","url":"/v3/managing-templates#installing-templates"},{"project":"v3","title":"Managing Templates","subheading":"Installing From the Spin Git Repository","content":"To install templates from the Spin Git repository, run spin templates install --git:$ spin templates install --git https://github.com/spinframework/spinIf you prefer a shorter command, you can just pass the repository id instead of the full URL:$ spin templates install --git fermyon/spinThe above command installs undefined templates in the repository.undefined","keywords":"","subsectionKeywords":"","url":"/v3/managing-templates#installing-from-the-spin-git-repository"},{"project":"v3","title":"Managing Templates","subheading":"Installing From a Specific Branch","content":"By default, if you install templates from a Git repository, Spin tries to find a repo tag that matches the version of Spin, and installs from that tag.  Failing this, it installs from HEAD.  If you would like to install from a specific tag or branch, pass the --branch option:$ spin templates install --git https://github.com/spinframework/spin --branch spin/templates/v0.8","keywords":"","subsectionKeywords":"","url":"/v3/managing-templates#installing-from-a-specific-branch"},{"project":"v3","title":"Managing Templates","subheading":"Installing From a Local Directory","content":"To install templates from your local file system, run spin templates install --dir.undefined# Expects to find a directory ~/dev/spin-befunge-sdk/templates\n$ spin templates install --dir ~/dev/spin-befunge-sdkSee undefined for more details on this layout.","keywords":"","subsectionKeywords":"","url":"/v3/managing-templates#installing-from-a-local-directory"},{"project":"v3","title":"Managing Templates","subheading":"Installing From a Remote Tarball","content":"To install templates from a remote tarball, run spin templates install --tar.undefined$ spin templates install --tar https://github.com/spinframework/spin/archive/refs/tags/v9.8.7.tar.gz","keywords":"","subsectionKeywords":"","url":"/v3/managing-templates#installing-from-a-remote-tarball"},{"project":"v3","title":"Managing Templates","subheading":"Viewing Your Installed Templates","content":"To see what templates you have installed, run spin templates list.You can use the --verbose option to see additional information such as where they were installed from.","keywords":"","subsectionKeywords":"","url":"/v3/managing-templates#viewing-your-installed-templates"},{"project":"v3","title":"Managing Templates","subheading":"Uninstalling Templates","content":"You can uninstall templates using spin templates uninstall with the template name:$ spin templates uninstall redis-befungeundefined","keywords":"","subsectionKeywords":"","url":"/v3/managing-templates#uninstalling-templates"},{"project":"v3","title":"Managing Templates","subheading":"Upgrading Templates","content":"When you upgrade Spin, you will typically want to upgrade your templates to match.  This means new applications and components will get dependencies that match the Spin version you are using.  To do this, run spin templates upgrade:$ spin templates upgrade\nSelect repos to upgrade. Use Space to select/deselect and Enter to confirm selection.\n  [x] https://github.com/spinframework/spin-python-sdk\n  [ ] https://github.com/spinframework/spin (at spin/templates/v1.0)\n> [x] https://github.com/spinframework/spin-js-sdkUse the cursor keys and the space bar to select the repositories you want to upgrade, then hit Enter to upgrade the selected repositories.undefinedIf you want to upgrade undefined repositories without being prompted, run spin templates upgrade --all.As mentioned above, if you want to check which templates come from which repositories use --verbose i.e. spin templates list --verbose.","keywords":"","subsectionKeywords":"","url":"/v3/managing-templates#upgrading-templates"},{"project":"v3","title":"Managing Templates","subheading":"Upgrading Templates From a Local Directory","content":"spin templates upgrade only upgrades from Git repositories.  If you want to upgrade and your templates are in a local directory, run the spin templates install command with the --upgrade flag:$ spin templates install --dir ~/dev/spin-befunge-sdk --upgrade","keywords":"","subsectionKeywords":"","url":"/v3/managing-templates#upgrading-templates-from-a-local-directory"},{"project":"v3","title":"Managing Templates","subheading":"Next Steps","content":"undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/managing-templates#next-steps"},{"project":"v3","title":"Spin Application Manifest (Version 1) Reference","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedThis page describes version 1 of the Spin manifest file, typically called spin.toml.undefined","subsectionKeywords":"","url":"/v3/manifest-reference-v1"},{"project":"v3","title":"Spin Application Manifest (Version 1) Reference","subheading":"Format","content":"The manifest is a TOML file, and follows standard TOML syntax.  See the undefined for information about the TOML syntax.","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference-v1#format"},{"project":"v3","title":"Spin Application Manifest (Version 1) Reference","subheading":"Manifest Fields","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| spin_manifest_version | Required   | String      | The version of the file format that the rest of the manifest follows. Currently, this value must be \"1\". | \"1\" |\n| name                  | Required   | String      | The name of the application. This may be any string of alphanumeric characters, hyphens and underscores. | \"hello-world\" |\n| version               | Required   | String      | The version of the application. The must be a string of the form major.minor.patch, where each element is a number. | \"1.0.5\" |\n| description           | Optional   | String      | A human-readable description of the application. | \"The best app for all your world-greeting needs\" |\n| authors               | Optional   | Array of strings | The authors of the applications. If present, this must ba an array, even if it has only one entry. | [\"Jane Q Hacker (<dev@example.com>)\"] |\n| trigger               | Required   | Table       | The trigger for the application - that is, the kind of event that the application responds to. The table must contain the type field, and may contain others depending on the value of type. See undefined for details. | { type = \"http\" } |\n| variables             | Optional   | Table       | Dynamic configuration variables which the user can set when they run the application. See undefined below. | [variables]<br />message = { default = \"hello\" } |\n| component             | Required   | Table array | A manifest must contain at least one component table. component is always an array, even if there is only one component, so always use double square brackets.  See undefined below. | [[component]]<br />id = \"hello\" |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference-v1#manifest-fields"},{"project":"v3","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  trigger  Table","content":"The trigger table specifies the events that the application responds to.  The type field is always required, but the other fields depend on the type.  This section describes the built-in http and redis trigger types.undefinedtrigger = { type = \"http\" }","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference-v1#the-trigger-table"},{"project":"v3","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  trigger  Table for HTTP Applications","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| type                  | Required   | String      | Always \"http\" for HTTP applications. | \"http\" |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference-v1#the-trigger-table-for-http-applications"},{"project":"v3","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  trigger  Table for Redis Applications","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| type                  | Required   | String      | Always \"redis\" for Redis applications. | \"redis\" |\n| address               | Required   | String      | The address of the Redis instance the components are using the message subscriptions. Use the redis: URL scheme. | \"redis://localhost:6379\" |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference-v1#the-trigger-table-for-redis-applications"},{"project":"v3","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  variables  Table","content":"The keys of variables table are user-defined.  The value of each key is another table with the fields shown in the following table.undefined[variables]\nvessel = { default = \"teapot\" }\ntoken = { required = true, secret = true }| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| default               | Optional   | String      | The value of the variable if no value is supplied at runtime. If specified, the value must be a string. If not specified, required must be true. | \"teapot\" |\n| required              | Optional   | Boolean     | Whether a value must be supplied at runtime. If not specified, required defaults to false, and default must be provided | false |\n| secret                | Optional   | Boolean     | If set, this variable should be treated as sensitive. | false |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference-v1#the-variables-table"},{"project":"v3","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  component  Tables","content":"component is a table array, meaning each component is introduced with double-bracket syntax.  Subtables are written using single-bracket syntax or inline JSON syntax.  For example:[[component]]\nid = \"hello\"\nsource = \"hello.wasm\"\n[component.trigger]\nroute = \"/hello\"Each table in the component array contains the following fields:| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| id                    | Required   | String      | An identifier for this component, unique within the application. This may be any string of alphanumeric characters, hyphens and underscores. | \"cart-api\" |\n| description           | Optional   | String      | A human-readable description of the component. | \"The shopping cart API\" |\n| source                | Required   | String or table | The Wasm module which should handle the component. This must be built to work with the application trigger. It can be in one of the following formats: | |\n|                         |            | String      | * The path to a Wasm file (relative to the manifest file) | dist/cart.wasm |\n|                         |            | Table       | * The URL of a Wasm file downloadable over HTTP. This must be a table containing a url field for the Wasm file, and a digest field contains a SHA256 hex digest, used to check integrity. | { url = \"https://example.com/example.wasm\", digest = \"sha256:6503...2375\" } |\n| files                 | Optional   | Array of strings and/or tables | The undefined. This is an array, and each element of the array is either: | [ \"images/*.jpg\", { source = \"assets/images\", destination = \"/pictures\" } ] |\n|                         |            | String      | * A file path or glob pattern, relative to the manifest file. The matching file or files will be available in the Wasm module at the same relative paths. | \"images/*.jpg\" |\n|                         |            | Table       | * A directory to be made available to the Wasm module at a specific path. This must be a table containing a source field for the directory relative to the manifest file, and a destination field containing the absolute path at which to make it available. | { source = \"assets/images\", destination = \"/pictures\" } |\n| exclude_files         | Optional   | Array of strings | Any files or glob patterns that should undefined be available to the Wasm module at runtime, even though they match a files entry. | [assets/images/test/**/*.*] |\n| allowed_http_hosts    | Optional   | Array of strings | The host names or addresses to which the Wasm module is allowed to send HTTP requests. If the name includes a port, the Wasm module can send requests only to that port; otherwise, the Wasm module can send requests only to the default port for the scheme it uses. The special string insecure:allow-all permits the module to send HTTP requests to undefined host, but is intended for development use only; some deployment environments may decline to honour it. | [\"example.com\", \"localhost:8081\"] |\n| allowed_outbound_hosts | Optional  | Array of strings | The addresses to which the Wasm component is allowed to send network requests. This applies to the outbound HTTP, outbound Redis, MySQL and PostgreSQL APIs. (It does not apply to built-in storage services such as key-value and SQLite.) Each entry must contain both a scheme, a name (or IP address) and a port in scheme://name:port format. For known schemes, you may omit the port if it is the default for the scheme. Use * for wildcards. If this field is omitted, no outbound access is permitted, undefined that, for backward compatibility, a Spin 1 component may use Redis, MySQL or PostgreSQL to undefined host. If this field is present and empty, however, no outbound access if permitted, regardless of the component's Spin version. | [\"mysql://db.example.com\", \"*://example.com:4567\", \"http://127.0.0.1:*\"] |\n| key_value_stores      | Optional   | Array of strings | An array of key-value stores that the Wasm module is allowed to read or write. A store named default is provided by the Spin runtime, though modules must still be permitted to access it. In current versions of Spin, \"default\" is the only store allowed. | [\"default\"] |\n| environment           | Optional   | Table       | Environment variables to be set for the Wasm module. This is a table. The table keys are user-defined; the values must be strings. | { DB_URL = \"mysql://spin:spin@localhost/dev\" } |\n| trigger               | Required   | Table       | Specifies how this component is triggered. This is a table, whose contents of are trigger-specific; see below. | [component.trigger]<br />route = \"/...\" |\n| build                 | Optional   | Table       | The command that spin build uses to build this component. See undefined below. | [component.build]<br />command = \"npm run build\" |\n| config                | Optional   | Table       | Dynamic configuration values to be made available to this component. The table keys are user-defined; the values must be strings, and may use template notation as described under undefined. | [component.config]<br />api_base_url = \"https://{{ api_host }}/v1\" |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference-v1#the-component-tables"},{"project":"v3","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  component.trigger  Table for HTTP Applications","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| route                 | Required   | String      | The route which this component handles. Requests to the route will cause the component to execute. This may be an exact route (/example), which matches on the given path, or a wildcard route indicated by the suffix /... (/example/...), which matches any route under this prefix. If two routes overlap, requests are directed to the matching route with the longest prefix - see undefined for details and examples. | \"/api/cart/...\" |\n| executor              | Optional   | Table       | How Spin should invoke the component. If present, this is a table.  The type key is required and may have the values \"spin\" or \"wagi\". If omitted. the default is { type = \"spin\"}. See undefined for details. | { type = \"wagi\" } |\n|                         |            |             | If type = \"spin\" there are no other keys defined. In this case, Spin calls the component using a standard Wasm component interface. Components built using Spin SDKs or Spin interface files use this convention. | { type = \"spin\" } |\n|                         |            |             | If type = \"wagi\", Spin calls the component's \"main\" (_start) function using undefined. Components built using languages or toolchains that do not support Wasm interfaces will need to be called in this way. In this case, the following additional keys may be set:<br/><br/>* argv (optional): The string representation of the argv list that should be passed into the handler. ${SCRIPT_NAME} will be replaced with the script name, and ${ARGS} will be replaced with the query parameters of the request, formatted as arguments. The default is to follow the CGI specification, and pass ${SCRIPT_NAME} ${ARGS}<br/><br/>* entrypoint (optional): The name of the function to call as the entry point to this handler. By default, it is _start (which in most languages translates to main in the source code).<br/><br/>See undefined for details. | { type = \"wagi\" } |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference-v1#the-componenttrigger-table-for-http-applications"},{"project":"v3","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  component.trigger  Table for Redis Applications","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| channel               | Required   | String      | The Redis channel which this component handles. Messages on this channel will cause the component to execute. | \"purchases\" |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference-v1#the-componenttrigger-table-for-redis-applications"},{"project":"v3","title":"Spin Application Manifest (Version 1) Reference","subheading":"The  component.build  Table","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| command               | Required   | String      | The command to execute on spin build. | \"cargo build --target wasm32-wasip1 --release\" |\n| workdir               | Optional   | String      | The directory in which to execute command, relative to the manifest file. The default is the directory containing the manifest file. An example of where this is needed is a multi-component application where each component is its own source tree in its own directory. | \"my-project\" |\n| watch                 | Optional   | Array of strings | The files or glob patterns which spin watch should monitor to determine if the component Wasm file needs to be rebuilt. These are relative to workdir, or to the directory containing the manifest file if workdir is not present. | [\"src/**/*.rs\", \"Cargo.toml\"] |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference-v1#the-componentbuild-table"},{"project":"v3","title":"Spin Application Manifest (Version 1) Reference","subheading":"Next Steps","content":"undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference-v1#next-steps"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedThis page describes the contents of the Spin manifest file, typically called spin.toml.undefined","subsectionKeywords":"","url":"/v3/manifest-reference"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"Manifest Format","content":"The manifest is a TOML file, and follows standard TOML syntax.  See the undefined for information about the TOML syntax. Here is an example Spin application manifest (spin.toml) that was generated using spin new -t http-rust spin-manifest-example-in-rust:spin_manifest_version = 2\n\n[application]\nname = \"spin-manifest-example-in-rust\"\nversion = \"0.1.0\"\nauthors = [\"Fermyon Engineering <engineering@fermyon.com>\"]\ndescription = \"An example application to generate a Spin manifest file, in this case, via the HTTP Rust template.\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"spin-manifest-example-in-rust\"\n\n[component.spin-manifest-example-in-rust]\nsource = \"target/wasm32-wasip1/release/spin_manifest_example_in_rust.wasm\"\nallowed_outbound_hosts = []\n[component.spin-manifest-example-in-rust.build]\ncommand = \"cargo build --target wasm32-wasip1 --release\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#manifest-format"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"Using Variables in the Manifest","content":"The following fields allow you to use undefined in their values:undefinedundefinedundefinedundefinedSpin resolves manifest expressions at application load time. Subsequent changes to variables do not update expression-based values.The only variables permitted in manifest expressions are application variables.undefined","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#using-variables-in-the-manifest"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"Manifest Fields","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| spin_manifest_version | Required   | Number      | The version of the file format that the rest of the manifest follows. For manifests using this format, this value must be 2. | 2 |\n| application           | Required   | Table       | Information about the application and application-global options. See undefined below. | [application]<br />name = \"greetings\"<br />version = \"1.0.0\" |\n| variables             | Optional   | Table       | Dynamic configuration variables which the user can set when they run the application. See undefined below. | [variables]<br />message = { default = \"hello\" } |\n| trigger               | Required   | Table       | Associates triggers and conditions to the components that handle them - for example, mapping a HTTP route to a handling component. See undefined below. | [[trigger.http]]<br />component = \"greeter\"<br />route = \"/greet\" |\n| component             | Required   | Table       | The WebAssembly components that make up the application, together with whatever configuration and resources they depend on, such as asset files or storage access. See undefined below. | [component.greeter]<br />source = \"greeting_manager.wasm\"<br />files = [\"confetti.jpg\"] |undefined","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#manifest-fields"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"The  application  Table","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| name                  | Required   | String      | The name of the application. This may be any string of alphanumeric characters, hyphens and underscores. | \"hello-world\" |\n| version               | Optional   | String      | The version of the application. The must be a string of the form major.minor.patch, where each element is a number. | \"1.0.5\" |\n| description           | Optional   | String      | A human-readable description of the application. | \"The best app for all your world-greeting needs\" |\n| authors               | Optional   | Array of strings | The authors of the applications. If present, this must ba an array, even if it has only one entry. | [\"Jane Q Hacker (<dev@example.com>)\"] |\n| trigger               | Optional   | Table       | Application-global trigger settings. See undefined below. | [application.trigger.redis]<br />address = \"redis.example.com\" |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#the-application-table"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"The  application.trigger  Table","content":"The application.trigger should contain only one key, the trigger type whose settings you want to override. This is usually written inline as part of the TOML table header, e.g. [application.trigger.redis].undefined","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#the-applicationtrigger-table"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"The  application.trigger.redis  Table","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| address               | Required   | String      | The address of the Redis instance to which the components subscribe for messages, for triggers that do not specify an address themselves. Use the redis: URL scheme. | \"redis://localhost:6379\" |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#the-applicationtriggerredis-table"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"The  variables  Table","content":"The keys of the variables table are user-defined.  The value of each key is another table with the fields shown in the following table.undefined[variables]\nvessel = { default = \"teapot\" }\ntoken = { required = true, secret = true }| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| default               | Optional   | String      | The value of the variable if no value is supplied at runtime. If specified, the value must be a string. If not specified, required must be true. | \"teapot\" |\n| required              | Optional   | Boolean     | Whether a value must be supplied at runtime. If not specified, required defaults to false, and default must be provided | false |\n| secret                | Optional   | Boolean     | If set, this variable should be treated as sensitive. | false |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#the-variables-table"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"The  trigger  Table","content":"The trigger table contains only one key, the trigger type to which your application responds. The value of this key is a table array. In practice, the trigger table is written using table array syntax with the trigger type inlined into each entry. For example:[[trigger.http]]\nroute = \"/users\"\ncomponent = \"user-manager\"\n\n[[trigger.http]]\nroute = \"/reports\"\ncomponent = \"report\"Each array entry contains a mix of common fields and trigger-specific fields.","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#the-trigger-table"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"Common Fields for All  trigger.(type)  Tables","content":"| Name                    | Required?  | Type            | Value    | Example   |\n|-------------------------|------------|-----------------|----------|-----------|\n| component             | Required   | String or table | The component to run when a trigger event matching the trigger setting occurs (for example, when Spin receives an HTTP request matching the trigger's route). It can be in one of the following formats: |  |\n|                         |            | String          | * A key in the component table | \"user-manager\" |\n|                         |            | Table           | * Specifies an unnamed component to be associated with the trigger setting. This allows simple components to be written inline instead of needing a separate section. Such a table follows undefined format. | { source = \"reports.wasm\" }` |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#common-fields-for-all-triggertype-tables"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"Additional Fields for  trigger.http  Tables","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| route                 | Required   | String or table     | The route which this component handles. Requests to the route will cause the component to execute. | |\n|                         |            | String     | This may be an exact route (/example), which matches only the given path, or may include wildcards (/example/:id or /example/...). If two routes overlap, requests are directed to the matching route with the longest prefix. See undefined for details and examples. | \"/api/cart/...\" |\n|                         |            | Table     | If the component is a private endpoint used for undefined then use the table value shown here.  | { private = true }|\n| executor              | Optional   | Table       | How Spin should invoke the component. If present, this is a table.  The type key is required and may have the values \"spin\" or \"wagi\". If omitted. the default is { type = \"spin\"}. See undefined for details. | { type = \"wagi\" } |\n|                         |            |             | If type = \"spin\" there are no other keys defined. In this case, Spin calls the component using a standard Wasm component interface. Components built using Spin SDKs or Spin interface files use this convention. | { type = \"spin\" } |\n|                         |            |             | If type = \"wagi\", Spin calls the component's \"main\" (_start) function using undefined. Components built using languages or toolchains that do not support Wasm interfaces will need to be called in this way. In this case, the following additional keys may be set:<br/><br/>* argv (optional): The string representation of the argv list that should be passed into the handler. ${SCRIPT_NAME} will be replaced with the script name, and ${ARGS} will be replaced with the query parameters of the request, formatted as arguments. The default is to follow the CGI specification, and pass ${SCRIPT_NAME} ${ARGS}<br/><br/>* entrypoint (optional): The name of the function to call as the entry point to this handler. By default, it is _start (which in most languages translates to main in the source code).<br/><br/>See undefined for details. | { type = \"wagi\" } |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#additional-fields-for-triggerhttp-tables"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"Additional Fields for  trigger.redis  Tables","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| address               | Optional   | String      | The address of the Redis instance to which the trigger subscribes. Use the redis: URL scheme. If omitted, defaults to application.trigger.redis.address. | \"redis://localhost:6379\" |\n| channel               | Required   | String      | The Redis channel which this component handles. Messages on this channel will cause the component to execute. | \"purchases\" |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#additional-fields-for-triggerredis-tables"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"The  component  Table","content":"The keys of the component table, usually written as part of the table syntax e.g. [component.my-component], are user-defined.  (In the preceding example, the key is my-component). Component names must be kebab-cased, i.e. the only permitted separator is a hyphen.The value of each key is a table with the following fields.| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| description           | Optional   | String      | A human-readable description of the component. | \"The shopping cart API\" |\n| source                | Required   | String or table | The Wasm module which should handle the component. This must be built to work with the application trigger. It can be in one of the following formats: | |\n|                         |            | String      | * The path to a Wasm file (relative to the manifest file) | dist/cart.wasm |\n|                         |            | Table       | * The URL of a Wasm file downloadable over HTTP. This must be a table containing a url field for the Wasm file, and a digest field contains a SHA256 hex digest, used to check integrity. | { url = \"https://example.com/example.wasm\", digest = \"sha256:6503...2375\" } |\n|                         |            | Table (Highly Experimental)       | * The registry, package and version of a component from a registry. This experimental source configuration must be a table containing a registry domain field, a package field and a version field. | { registry = \"registrytest-abcd.fermyon.app\", package = \"component:hello-world\", version=\"0.0.1\" } or { registry = \"ttl.sh\", package = \"user:registrytest\", version=\"1.0.0\" } |\n| files                 | Optional   | Array of strings and/or tables | The undefined. This is an array, and each element of the array is either: | [ \"images/*.jpg\", { source = \"assets/images\", destination = \"/pictures\" } ] |\n|                         |            | String      | * A file path or glob pattern, relative to the manifest file. The matching file or files will be available in the Wasm module at the same relative paths. | \"images/*.jpg\" |\n|                         |            | Table       | * A file or directory to be made available to the Wasm module at a specific path. This must be a table containing a source field for the file or directory relative to the manifest file, and a destination field containing the absolute path at which to make it available. | { source = \"assets/images\", destination = \"/pictures\" } |\n| exclude_files         | Optional   | Array of strings | Any files or glob patterns that should undefined be available to the Wasm module at runtime, even though they match a files entry. | [assets/images/test/**/*.*] |\n| allowed_http_hosts    | Optional   | Array of strings | The host names or addresses to which the Wasm component is allowed to send HTTP requests. This is retained to simplify transition from the undefined; new applications should use allow_outbound_hosts instead. | [\"example.com\", \"localhost:8081\"] |\n| allowed_outbound_hosts | Optional  | Array of strings | The addresses to which the Wasm component is allowed to send network requests. This applies to the outbound HTTP, outbound Redis, MySQL and PostgreSQL APIs. (It does not apply to built-in storage services such as key-value and SQLite.) Each entry must contain both a scheme, a name (or IP address) and a port in scheme://name:port format. For known schemes, you may omit the port if it is the default for the scheme. Use * for wildcards. If this field is omitted or an empty list, no outbound access is permitted. | [\"mysql://db.example.com\", \"*://example.com:4567\", \"http://127.0.0.1:*\"] |\n| key_value_stores      | Optional   | Array of strings | An array of key-value stores that the Wasm module is allowed to read or write. A store named default is provided by the Spin runtime, though modules must still be permitted to access it. In current versions of Spin, \"default\" is the only store allowed. | [\"default\"] |\n| environment           | Optional   | Table       | Environment variables to be set for the Wasm module. This is a table. The table keys are user-defined; the values must be strings. | { DB_URL = \"mysql://spin:spin@localhost/dev\" } |\n| build                 | Optional   | Table       | The command that spin build uses to build this component. See undefined below. | [component.cart.build]<br />command = \"npm run build\" |\n| variables             | Optional   | Table       | Dynamic configuration values to be made available to this component. The table keys are user-defined; the values must be strings, and may use template notation as described under undefined. | [component.cart.variables]<br />api_base_url = \"https://{{ api_host }}/v1\" |\n| dependencies_inherit_configuration | Optional | Boolean | If true, dependencies can invoke Spin APIs with the same permissions as the main component. If false, dependencies have no permissions (e.g. network, key-value stores, SQLite databases). The default is false. | false |\n| dependencies          | Optional   | Table       | Specifies how to satisfy Wasm Component Model imports of this component. See undefined. | [component.cart.dependencies]<br />\"example:calculator/adder\" = { registry = \"example.com\", package = \"example:adding-calculator\", version = \"1.0.0\" } |undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#the-component-table"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"The  component.(id).build  Table","content":"| Name                    | Required?  | Type        | Value    | Example   |\n|-------------------------|------------|-------------|----------|-----------|\n| command               | Required   | String      | The command to execute on spin build. | \"cargo build --target wasm32-wasip1 --release\" |\n| workdir               | Optional   | String      | The directory in which to execute command, relative to the manifest file. The default is the directory containing the manifest file. An example of where this is needed is a multi-component application where each component is its own source tree in its own directory. | \"my-project\" |\n| watch                 | Optional   | Array of strings | The files or glob patterns which spin watch should monitor to determine if the component Wasm file needs to be rebuilt. These are relative to workdir, or to the directory containing the manifest file if workdir is not present. | [\"src/**/*.rs\", \"Cargo.toml\"] |","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#the-componentidbuild-table"},{"project":"v3","title":"Spin Application Manifest Reference","subheading":"Next Steps","content":"undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/manifest-reference#next-steps"},{"project":"v3","title":"Migrating an Application from Spin 2.x to Spin 3.x","subheading":"","content":"Most applications will not require changes. The following changes may affect application authors:undefinedundefinedundefinedundefinedundefinedundefinedThe following change will not affect most application authors, but may affect you if you work directly with the low-level WASI interfaces:undefinedIf you're affected by these or other changes and you're looking for help, please reach out on the undefined for support.","subsectionKeywords":"","url":"/v3/migration-v2-v3"},{"project":"v3","title":"MQTT Messaging","subheading":"","content":"undefinedundefinedundefinedSpin provides an experimental interface for you to send messages using the MQTT protocol.{{ details \"Why do I need a Spin interface? Why can't I just use my language's MQTT library?\" \"Few MQTT libraries have been updated to work over the WASI 0.2 sockets interface. The Spin interface means Wasm modules can bypass this limitation by asking Spin to make the MQTT connection on their behalf.\" }}undefined","subsectionKeywords":"","url":"/v3/mqtt-outbound"},{"project":"v3","title":"MQTT Messaging","subheading":"Sending MQTT Messages From Applications","content":"The Spin SDK surfaces the Spin MQTT interface to your language. The set of operations defined in Spin's API is as follows:| Operation    | Parameters          | Returns | Behavior |\n|--------------|---------------------|---------|----------|\n| open       | address, username, password, keep-alive | connection resource | Opens a connection to the specified MQTT server. The host must be listed in allowed_outbound_hosts. Other operations must be called through a connection. |\n| publish    | topic, payload, QoS | -       | Publishes the payload (a binary blob) as a message to the specified topic. |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedMQTT functions are available in the spin_sdk::mqtt module.To access an MQTT server, use the Connection::open function.let connection = spin_sdk::mqtt::Connection::open(&address, &username, &password, keep_alive_secs)?;You can then call the Connection::publish function to send MQTT messages:let cat_picture: Vec<u8> = request.body().to_vec();\nconnection.publish(\"pets\", &cat_picture, spin_sdk::mqtt::Qos::AtLeastOnce)?;For full details of the MQTT API, see the undefined;You can find a complete Rust code example for using outbound MQTT from an HTTP component in the undefined.{{ blockEnd }}{{ startTab \"TypeScript\"}}undefinedTo access an MQTT server, use the Mqtt.open function.let connection = Mqtt.open(address, username, password, keepAliveSecs);You can then call the publish method on the connection to send MQTT messages:let catPicture = new Uint8Array(await req.arraybuffer());\nconnection.publish(\"pets\", catPicture, QoS.AtleastOnce);For full details of the MQTT API, see the undefinedYou can find a complete Rust code example for using outbound MQTT from an HTTP component in the undefined.{{ blockEnd }}{{ startTab \"Python\"}}MQTT is not available in the current version of the Python SDK.{{ blockEnd }}{{ startTab \"TinyGo\"}}MQTT is not available in the current version of the Go SDK.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/mqtt-outbound#sending-mqtt-messages-from-applications"},{"project":"v3","title":"MQTT Messaging","subheading":"Granting Network Permissions to Components","content":"By default, Spin components are not allowed to make outgoing network requests, including MQTT. This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing. To grant a component permission to make network requests to a particular host, use the allowed_outbound_hosts field in the component manifest, specifying the host and allowed port:[component.uses-mqtt]\nallowed_outbound_hosts = [\"mqtt://messaging.example.com:1883\"]","keywords":"","subsectionKeywords":"","url":"/v3/mqtt-outbound#granting-network-permissions-to-components"},{"project":"v3","title":"MQTT Messaging","subheading":"Configuration-Based Permissions","content":"You can use undefined in the allowed_outbound_hosts field. However, this feature is not yet available on Fermyon Cloud.","keywords":"","subsectionKeywords":"","url":"/v3/mqtt-outbound#configuration-based-permissions"},{"project":"v3","title":"MQTT Messaging","subheading":"Known Issues","content":"The MQTT API is experimental and subject to change.  The following issues are known:undefined","keywords":"","subsectionKeywords":"","url":"/v3/mqtt-outbound#known-issues"},{"project":"v3","title":"Observing Applications","subheading":"","content":"undefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v3/observing-apps"},{"project":"v3","title":"Observing Applications","subheading":"Application Logs","content":"Spin handles application logs by default, storing output and error messages from file system-run applications in the .spin/logs directory alongside the manifest file's location. Users have the option to direct logs to a specific folder using the --log-dir flag of the spin up command. Additionally, if users wish to prevent stdout and stderr from being written to disk, they can specify an empty string for the --log-dir flag, i.e. spin up --log-dir \"\" - effectively disabling log storage. See the undefined section for more details.","keywords":"","subsectionKeywords":"","url":"/v3/observing-apps#application-logs"},{"project":"v3","title":"Observing Applications","subheading":"OpenTelemetry (OTel)","content":"Spin now has support for the undefined observability standard. You can learn more about observability undefined. When configured, Spin will emit telemetry about your Spin App in the form of OTel undefined: traces, metrics, and logs.","keywords":"","subsectionKeywords":"","url":"/v3/observing-apps#opentelemetry-otel"},{"project":"v3","title":"Observing Applications","subheading":"The  otel  Plugin for Spin","content":"We have a plugin that makes it easy to use OpenTelemetry with Spin. If you would like to examine the source code, you can visit the undefined. Otherwise, follow these instructions:undefined","keywords":"","subsectionKeywords":"","url":"/v3/observing-apps#the-otel-plugin-for-spin"},{"project":"v3","title":"Observing Applications","subheading":"Supported Observability Stacks","content":"The otel plugin for Spin currently supports the following observability stacks:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/observing-apps#supported-observability-stacks"},{"project":"v3","title":"Observing Applications","subheading":"Using the  otel  Plugin for Spin","content":"Setting up an observability stack is as easy as executing either spin otel setup or spin otel setup --aspire in the folder where your Spin app remains.The otel plugin comes with a handy spin otel up command, which you can use to start a Spin app and instruct it to emit telemetry data to your observability stack of choice.As your observability stack of choice is executed using traditional containers, you may want to stop them once you don't need them anymore. To do so, run spin otel cleanup.To see all available commands of the otel plugin, you can run spin otel --help.","keywords":"","subsectionKeywords":"","url":"/v3/observing-apps#using-the-otel-plugin-for-spin"},{"project":"v3","title":"Observing Applications","subheading":"Configuring your own observability stack","content":"Follow this portion of the guide if you want to use Spin and OTel, but want to have more control than what the OTel plugin offers.","keywords":"","subsectionKeywords":"","url":"/v3/observing-apps#configuring-your-own-observability-stack"},{"project":"v3","title":"Observing Applications","subheading":"Configure the Docker compose stack","content":"In order to view the telemetry data you need to run an OTel compliant undefined and the proper backends for each signal type. If you have Docker on your system you can easily start all the observability tools you need with the following commands:cd  ~\ngit clone git@github.com:fermyon/spin.git\ncd spin/hack/o11y-stack\ndocker compose up -dThis will start the following services:undefinedundefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/observing-apps#configure-the-docker-compose-stack"},{"project":"v3","title":"Observing Applications","subheading":"Configuring Spin","content":"To have Spin export OTel telemetry to the collector you need to set the following environment variable:OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318 spin upThis will enable all OTel signals. If you only want to enable specific signals you can set the following environment variables individually:undefinedundefinedundefinedFor example this would enable exporting of traces and metrics:OTEL_EXPORTER_OTLP_TRACES_ENDPOINT=http://localhost:4318/v1/traces OTEL_EXPORTER_OTLP_METRICS_ENDPOINT=http://localhost:4318/v1/metrics spin upStoring lots of trace data can get expensive. You may want to sample traces to reduce the amount of data stored. You can set the following environment variable to control the sampling rate:OTEL_TRACES_SAMPLER=traceidratio OTEL_TRACES_SAMPLER_ARG={desired_ratio} OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318 spin upUnder high request loads Spin will start dropping OTel data. If keeping all of this data is important to you there are undefined you can set:OTEL_BSP_MAX_CONCURRENT_EXPORTS=4 OTEL_BSP_MAX_QUEUE_SIZE=4096 OTEL_BSP_SCHEDULE_DELAY=1000 OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318 spin upSpin supports a wide array of OTel configuration options beyond what we've covered here. You can read more about them undefined and undefined.","keywords":"","subsectionKeywords":"","url":"/v3/observing-apps#configuring-spin"},{"project":"v3","title":"Observing Applications","subheading":"Traces","content":"After sending some requests to your Spin app, navigate to Jaeger undefined to view the traces.undefinedSpin supports both inbound and outbound undefined. This allows you to include Spin in your distributed traces that span all your services.","keywords":"","subsectionKeywords":"","url":"/v3/observing-apps#traces"},{"project":"v3","title":"Observing Applications","subheading":"Metrics","content":"Navigate to undefined to view the metrics in Grafana. Make sure to choose the Prometheus data source from the top left dropdown menu.","keywords":"","subsectionKeywords":"","url":"/v3/observing-apps#metrics"},{"project":"v3","title":"Observing Applications","subheading":"Logs","content":"Navigate to undefined to view the logs in Grafana. Make sure to choose the Loki data source from the top left dropdown menu.Spin will still emit application logs as described in the undefined section. However, it will also send the logs to the OTel collector.","keywords":"","subsectionKeywords":"","url":"/v3/observing-apps#logs"},{"project":"v3","title":"Building Spin components in other languages","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedWebAssembly is becoming undefined, and as language toolchains add support for the\nundefined,\nbuilding Spin components will also become supported.As a general rule:undefinedundefinedundefined","subsectionKeywords":"","url":"/v3/other-languages"},{"project":"v3","title":"Building Spin components in other languages","subheading":"C/C++","content":"C and C++ are both broadly supported in the WebAssembly ecosystem. WASI/Wagi support means that both can be used to write Spin apps.undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/other-languages#cc"},{"project":"v3","title":"Building Spin components in other languages","subheading":"C# and .NET Languages","content":".NET has experimental support for WASI, so many (if not all) .NET languages, including C# and F#, can be used to write Spin applications.undefined","keywords":"","subsectionKeywords":"","url":"/v3/other-languages#c-and-net-languages"},{"project":"v3","title":"Building Spin components in other languages","subheading":"Grain","content":"undefined, a new functional programming language, has WASI/Wagi support and can be used to write Spin apps.undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/other-languages#grain"},{"project":"v3","title":"Building Spin components in other languages","subheading":"Ruby","content":"Upstream undefined officially supports WebAssembly and WASI, and we here at Fermyon have successfully run Ruby apps in Spin.undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/other-languages#ruby"},{"project":"v3","title":"Building Spin components in other languages","subheading":"Zig","content":"Zig is a low-level systems language that has support for Wasm and WASI, and can be used to write Spin apps.undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/other-languages#zig"},{"project":"v3","title":"Creating Spin Plugins","subheading":"","content":"undefinedundefinedundefinedSpin plugins add new functionality or subcommands to Spin without modifying the\nSpin codebase. They make Spin easily extensible while keeping it lightweight.\nSpin plugins can add new triggers to Spin (such as the undefined),\nadd deployment integrations (such as\nundefined),\nand more.This document will cover what Spin plugins are, how to use a plugin, and how to\ncreate a plugin.","subsectionKeywords":"","url":"/v3/plugin-authoring"},{"project":"v3","title":"Creating Spin Plugins","subheading":"What Are Spin Plugins?","content":"A Spin plugin is an executable that is added to Spin's plugins directory\n($XDG_DATA_HOME/spin/plugins) upon a spin plugins install <plugin-name>. The\nplugin is then ready to be used. If the plugin is an extension to the Spin CLI,\nit can now be executed directly as a subcommand: spin <plugin-name>. If the\nplugin is a trigger plugin, it will be executed during spin up when an app\nusing that trigger is run.While for now plugins are assumed to be executables, in the future, support for\nplugging in WebAssembly modules may be desirable.","keywords":"","subsectionKeywords":"","url":"/v3/plugin-authoring#what-are-spin-plugins"},{"project":"v3","title":"Creating Spin Plugins","subheading":"How to Find and Use a Spin Plugin","content":"Spin maintains a centralized catalogue of available Spin plugins in the undefined. During plugin\ninstallation, if it does not already exist, Spin fetches the remote catalogue\nand creates a local snapshot. To ensure that the local snapshot is up to date,\nit is best to run spin plugins update before installing any plugins.To list available plugins, run spin plugins search. Now, decide which plugin to\ninstall. For example, the kube plugin, which is needed in order to deploy\napplications to undefined, can be installed by running:$ spin plugins install kubeWith the plugin installed, you can now call spin kube to run it.To upgrade installed plugins to newer versions, run spin plugin update to\nfetch the latest plugins to the local catalogue and spin plugin upgrade to perform the\nupgrade on the installed plugins.","keywords":"","subsectionKeywords":"","url":"/v3/plugin-authoring#how-to-find-and-use-a-spin-plugin"},{"project":"v3","title":"Creating Spin Plugins","subheading":"Authoring a Spin Plugin","content":"Spin plugins are implemented as a manifest that points to one or more .tar.gz archives which contain the plugin executables. So, to create a plugin you must:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/plugin-authoring#authoring-a-spin-plugin"},{"project":"v3","title":"Creating Spin Plugins","subheading":"Environment Variables Available to the Plugin Executable","content":"Your plugin may need to know information about the instance of Spin it's running in. For example, suppose your plugin wants to call spin build. The trouble is that you don't know if it's on the user's system PATH. Suppose, further, that your plugin would prefer to call spin build -c (to build only a specific component) if it's available but can fall back to spin build (to build everything) if it's not. The -c option only exists in Spin 1.4 and above, so this optimization requires that you know which version of Spin you're running in.To help with this, when a user uses Spin to run your plugin, Spin sets a number of environment variables on the plugin process. Your code can use these environment variables to find out things like the path to the Spin binary and which version of Spin it is. When your plugin runs, the parent Spin process will set these to the right values for the undefined instance of Spin. In the example above, when your plugin wants to run spin build, it can consult the SPIN_BIN_PATH environment variable for the program path, and be confident that the SPIN_VERSION environment variable matches the Spin binary at that location.The variables Spin sets are:| Name               | Meaning                                                                                                               | Example |\n|--------------------|-----------------------------------------------------------------------------------------------------------------------|---------|\n| SPIN_BIN_PATH      | The path to the Spin executable that the user is running. Use this if your plugin issues commands using the Spin CLI. | /Users/alice/.cargo/bin/spin |\n| SPIN_BRANCH        | The Git branch from which the Spin executable was built.                                                              | main |\n| SPIN_BUILD_DATE    | The date on which the Spin executable was built, in yyyy-mm-dd format.                                                | 2023-05-15 |\n| SPIN_COMMIT_DATE   | The date of the Git commit from which the Spin executable was built, in yyyy-mm-dd format.                            | 2023-05-15 |\n| SPIN_COMMIT_SHA    | The SHA of the Git commit from which the Spin executable was built.                                                   | 49fb11b |\n| SPIN_DEBUG         | Whether the Spin executable is a debug build.                                                                         | false |\n| SPIN_TARGET_TRIPLE | The processor and operating system for which the Spin executable was built, in Rust target-triple format.             | aarch64-apple-darwin |\n| SPIN_VERSION       | The version of Spin. This can be used to detect features availability, or to determine pre-stable command syntax.     | 1.3.0 |\n| SPIN_VERSION_MAJOR | The major version of Spin.                                                                                            | 1 |\n| SPIN_VERSION_MINOR | The minor version of Spin.                                                                                            | 3 |\n| SPIN_VERSION_PRE   | The prerelease version string, or empty if this is a released version of Spin.                                        | pre0 |undefined","keywords":"","subsectionKeywords":"","url":"/v3/plugin-authoring#environment-variables-available-to-the-plugin-executable"},{"project":"v3","title":"Creating Spin Plugins","subheading":"Packaging a Plugin","content":"After creating your plugin executable, package it along with its license as a\ntar.gz archive. Note that the name field in the plugin manifest must match\nboth the binary and license name. See the undefined\nfor more details on naming conventions.Refer to the aptly named undefined for an\nexample of how to build a plugin.","keywords":"","subsectionKeywords":"","url":"/v3/plugin-authoring#packaging-a-plugin"},{"project":"v3","title":"Creating Spin Plugins","subheading":"Creating a Spin Plugin Manifest","content":"A Spin plugin manifest is a JSON file that conforms to the undefined.\nA manifest defines a plugin’s name, version, license, homepage (i.e. GitHub\nrepo), compatible Spin version, and gives a short description of the plugin. It\nalso lists the URLs of the tar archives of the plugin for various operating\nsystems and platforms. The URL can point to the local path to the file by using\nthe file scheme file://, for example, file:///tmp/my-plugin.tar.gz.To ensure your plugin manifest is valid, follow the steps in the undefined.","keywords":"","subsectionKeywords":"","url":"/v3/plugin-authoring#creating-a-spin-plugin-manifest"},{"project":"v3","title":"Creating Spin Plugins","subheading":"Installing a Local Plugin","content":"By default, Spin will look in the plugins catalogue for a plugin. However, when\ndeveloping and testing a plugin, it is unlikely to be in the the catalogue. For\nboth installs and upgrades, the --file or --url flags can be used to point\nto specific local or remote plugin manifests. For example, a local manifest\ncalled practice.json can be installed and run as follows:$ spin plugin install --file practice.json\n$ spin practiceundefined","keywords":"","subsectionKeywords":"","url":"/v3/plugin-authoring#installing-a-local-plugin"},{"project":"v3","title":"Creating Spin Plugins","subheading":"Contributing a Plugin","content":"If you think the community would benefit from your newly created plugin, create\na PR to add it to the undefined!","keywords":"","subsectionKeywords":"","url":"/v3/plugin-authoring#contributing-a-plugin"},{"project":"v3","title":"Building Spin Components in Python","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedWith <a href=\"https://www.python.org/\" target=\"_blank\">Python</a> being a very popular language, Spin provides support for building components with Python; undefined. The development of the Python SDK is continually being worked on to improve user experience and also add new features.undefinedundefinedundefined","subsectionKeywords":"","url":"/v3/python-components"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Prerequisite","content":"Ensure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.","keywords":"","subsectionKeywords":"","url":"/v3/python-components#prerequisite"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Componentize-Py","content":"The Python SDK is built using undefined. It is a undefined project that allows converting a Python application to a WebAssembly component. It can be installed using the following command:$ pip3 install componentize-py==0.13.3undefined","keywords":"","subsectionKeywords":"","url":"/v3/python-components#componentize-py"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Spin's Python HTTP Request Handler Template","content":"Spin's Python HTTP Request Handler Template can be installed from undefined using the following command:$ spin templates install --git https://github.com/spinframework/spin-python-sdk --updateThe above command will install the http-py template and produce an output similar to the following:Copying remote template source\nInstalling template http-py...\nInstalled 1 template(s)\n\n+---------------------------------------------+\n| Name      Description                       |\n+=============================================+\n| http-py   HTTP request handler using Python |\n+---------------------------------------------+undefined For more information about managing Spin templates, see the undefined.","keywords":"","subsectionKeywords":"","url":"/v3/python-components#spins-python-http-request-handler-template"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Creating a New Python Component","content":"A new Python component can be created using the following command:$ spin new -t http-py hello-world --accept-defaults","keywords":"","subsectionKeywords":"","url":"/v3/python-components#creating-a-new-python-component"},{"project":"v3","title":"Building Spin Components in Python","subheading":"System Housekeeping (Use a Virtual Environment)","content":"Once the component is created, we can change into the hello-world directory, create and activate a virtual environment and then install the component's requirements:$ cd hello-worldCreate a virtual environment directory (we are still inside the Spin app directory):# python<version> -m venv <virtual-environment-name>\n$ python3 -m venv venv-dirActivate the virtual environment (this command depends on which operating system you are using):# macOS command to activate\n$ source venv-dir/bin/activateIf you are using Windows, use the following commands:C:\\Work> python3 -m venv venv\nC:\\Work> venv\\Scripts\\activateThe (venv-dir) will prefix your terminal prompt now:(venv-dir) user@123-456-7-8 hello-world %","keywords":"","subsectionKeywords":"","url":"/v3/python-components#system-housekeeping-use-a-virtual-environment"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Requirements","content":"The requirements.txt, by default, contains the references to the spin-sdk and componentize-py packages. These can be installed in your virtual environment using the following command:$ pip3 install -r requirements.txt \nCollecting spin-sdk==3.1.0 (from -r requirements.txt (line 1))\n  Using cached spin_sdk-3.1.0-py3-none-any.whl.metadata (16 kB)\nCollecting componentize-py==0.13.3 (from -r requirements.txt (line 2))\n  Using cached componentize_py-0.13.3-cp37-abi3-macosx_10_12_x86_64.whl.metadata (3.4 kB)\nUsing cached spin_sdk-3.1.0-py3-none-any.whl (94 kB)\nUsing cached componentize_py-0.13.3-cp37-abi3-macosx_10_12_x86_64.whl (38.8 MB)\nInstalling collected packages: spin-sdk, componentize-py\nSuccessfully installed componentize-py-0.13.3 spin-sdk-3.1.0","keywords":"","subsectionKeywords":"","url":"/v3/python-components#requirements"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Structure of a Python Component","content":"The hello-world directory structure created by the Spin http-py template is shown below:├── app.py\n├── spin.toml\n└── requirements.txt The spin.toml file will look similar to the following:spin_manifest_version = 2\n\n[application]\nname = \"hello-world\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nsource = \"app.wasm\"\n[component.hello-world.build]\ncommand = \"componentize-py -w spin-http componentize app -o app.wasm\"","keywords":"","subsectionKeywords":"","url":"/v3/python-components#structure-of-a-python-component"},{"project":"v3","title":"Building Spin Components in Python","subheading":"A Simple HTTP Components Example","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request and must return an HTTP response at the end of their execution. Components can be built in any language that compiles to WASI. If you would like additional information about building HTTP applications you may find undefined useful.Building a Spin HTTP component using the Python SDK means defining a top-level class named IncomingHandler which inherits from undefined, overriding the handle_request method. Here is an example of the default Python code which the previous spin new created for us; a simple example of a request/response:from spin_sdk.http import IncomingHandler, Request, Response\n\nclass IncomingHandler(IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(\"Hello from Python!\", \"utf-8\")\n        )The important things to note in the implementation above:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/python-components#a-simple-http-components-example"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Building and Running the Application","content":"All you need to do is run the spin build command from within the project's directory; as shown below:$ spin buildEssentially, we have just created a new Spin compatible module which can now be run using the spin up command, as shown below:$ spin upWith Spin running our application in our terminal, we can now go ahead (grab a new terminal) and call the Spin application via an HTTP request:$ curl -i localhost:3000\n\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 25\n\nHello from Python!","keywords":"","subsectionKeywords":"","url":"/v3/python-components#building-and-running-the-application"},{"project":"v3","title":"Building Spin Components in Python","subheading":"A HTTP Request Parsing Example","content":"The following snippet shows how you can access parts of the request e.g. the request.method and the request.body:import json\nfrom spin_sdk import http\nfrom spin_sdk.http import Request, Response\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        # Access the request.method\n        if request.method == 'POST':\n            # Read the request.body as a string\n            json_str = request.body.decode('utf-8')\n            # Create a JSON object representation of the request.body\n            json_object = json.loads(json_str)\n            # Access a value in the JSON object\n            name = json_object['name']\n            # Print the variable to console logs\n            print(name)\n            # Print the type of the variable to console logs\n            print(type(name))\n            # Print the available methods of the variable to the console logs\n            print(dir(name))\n        return Response(200,\n                    {\"content-type\": \"text/plain\"},\n                    bytes(f\"Practicing reading the request object\", \"utf-8\"))","keywords":"","subsectionKeywords":"","url":"/v3/python-components#a-http-request-parsing-example"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Building and Running the Application","content":"All you need to do is run the spin build --up command from within the project's directory; as shown below:$ spin build --upWith Spin running our application in our terminal, we can now go ahead (grab a new terminal) and call the Spin application via an HTTP request:$ curl --header \"Content-Type: application/json\" \\\n  --request POST \\\n  --data '{\"name\":\"Python\"}' \\\n  http://localhost:3000/\n\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 37\ndate: Mon, 15 Apr 2024 04:26:00 GMT\n\nPracticing reading the request objectThe response \"Practicing reading the request object\" is returned as expected. In addition, if we check the terminal where Spin is running, we will see that the console logs printed the following:The value of the variable called name:PythonThe name variable type (in this case a Python string):<class 'str'>The methods available to that type:['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__',\n... abbreviated ...\n'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']undefined","keywords":"","subsectionKeywords":"","url":"/v3/python-components#building-and-running-the-application"},{"project":"v3","title":"Building Spin Components in Python","subheading":"An Outbound HTTP Example","content":"This next example will create an outbound request, to obtain a random fact about animals, which will be returned to the calling code. If you would like to try this out, you can go ahead and update your existing app.py file from the previous step; using the following source code:from spin_sdk import http   \nfrom spin_sdk.http import Request, Response, send\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        resp = send(Request(\"GET\", \"https://random-data-api.fermyon.app/animals/json\", {}, None))\n\n        return  Response(200,\n                    {\"content-type\": \"text/plain\"},\n                    bytes(f\"Here is an animal fact: {str(resp.body, 'utf-8')}\", \"utf-8\"))\n","keywords":"","subsectionKeywords":"","url":"/v3/python-components#an-outbound-http-example"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Configuring Outbound Requests","content":"The Spin framework protects your code from making outbound requests to just any URL. For example, if we try to run the above code undefined, we will correctly get the following error AssertionError: HttpError::DestinationNotAllowed. To allow our component to request the random-data-api.fermyon.app domain, all we have to do is add that domain to the specific component of the application that is making the request. Here is an example of an updated spin.toml file where we have added allowed_outbound_hosts:spin_manifest_version = 2\n\n[application]\nname = \"hello-world\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nsource = \"app.wasm\"\nallowed_outbound_hosts = [\"https://random-data-api.fermyon.app\"]\n[component.hello-world.build]\ncommand = \"componentize-py -w spin-http componentize app -o app.wasm\"\nwatch = [\"*.py\", \"requirements.txt\"]","keywords":"","subsectionKeywords":"","url":"/v3/python-components#configuring-outbound-requests"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Building and Running the Application","content":"Run the spin build --up command from within the project's directory; as shown below:$ spin build --upWith Spin running our application in our terminal, we can now go ahead (grab a new terminal) and call the Spin application via an HTTP request:$ curl -i localhost:3000\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 99\ndate: Mon, 15 Apr 2024 04:52:45 GMT\n\nHere is an animal fact: {\"timestamp\":1713156765221,\"fact\":\"Bats are the only mammals that can fly\"}","keywords":"","subsectionKeywords":"","url":"/v3/python-components#building-and-running-the-application"},{"project":"v3","title":"Building Spin Components in Python","subheading":"An Outbound Redis Example","content":"In this final example, we talk to an existing Redis instance. You can find the official undefined. We also gave a quick run-through on setting up Redis with Spin in our previous article called undefined, so please take a look at that blog if you need a hand.","keywords":"","subsectionKeywords":"","url":"/v3/python-components#an-outbound-redis-example"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Configuring Outbound Redis","content":"After installing Redis on localhost, we add two entries to the spin.toml file:undefinedundefinedspin_manifest_version = 2\n\n[application]\nname = \"hello-world\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nid = \"hello-world\"\nsource = \"app.wasm\"\nvariables = { redis_address = \"redis://127.0.0.1:6379\" }\nallowed_outbound_hosts = [\"redis://127.0.0.1:6379\"]\n[component.hello-world.build]\ncommand = \"spin py2wasm app -o app.wasm\"If you are still following along, please go ahead and update your app.py file one more time, as follows:from spin_sdk import http, redis, variables\nfrom spin_sdk.http import Request, Response\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        with redis.open(variables.get(\"redis_address\")) as db:\n            db.set(\"foo\", b\"bar\")\n            value = db.get(\"foo\")\n            db.incr(\"testIncr\")\n            db.sadd(\"testSets\", [\"hello\", \"world\"])\n            content = db.smembers(\"testSets\")\n            db.srem(\"testSets\", [\"hello\"])\n            assert value == b\"bar\", f\"expected \\\"bar\\\", got \\\"{str(value, 'utf-8')}\\\"\"\n\n        return Response(200,\n                    {\"content-type\": \"text/plain\"},\n                    bytes(f\"Executed outbound Redis commands: {request.uri}\", \"utf-8\"))","keywords":"","subsectionKeywords":"","url":"/v3/python-components#configuring-outbound-redis"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Building and Running the Application","content":"Run the spin build --up command from within the project's directory; as shown below:$ spin build --upIn a new terminal, make the request via the curl command, as shown below:$ curl -i localhost:3000\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 35\ndate: Mon, 15 Apr 2024 05:53:17 GMT\n\nExecuted outbound Redis commands: /If we go into our Redis CLI on localhost we can see that the value foo which was set in the Python source code ( redis_set(redis_address, \"foo\", b\"bar\") ) is now correctly set to the value of bar:redis-cli\n127.0.0.1:6379> get foo\n\"bar\"","keywords":"","subsectionKeywords":"","url":"/v3/python-components#building-and-running-the-application"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Storing Data in the Spin Key-Value Store","content":"Spin has a key-value store built in. For information about using it from Python, see undefined.","keywords":"","subsectionKeywords":"","url":"/v3/python-components#storing-data-in-the-spin-key-value-store"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Storing Data in SQLite","content":"For more information about using SQLite from Python, see undefined.","keywords":"","subsectionKeywords":"","url":"/v3/python-components#storing-data-in-sqlite"},{"project":"v3","title":"Building Spin Components in Python","subheading":"AI Inferencing From Python Components","content":"For more information about using Serverless AI from Python, see the undefined API guide.","keywords":"","subsectionKeywords":"","url":"/v3/python-components#ai-inferencing-from-python-components"},{"project":"v3","title":"Building Spin Components in Python","subheading":"Troubleshooting","content":"If you bump into issues when installing the requirements.txt. For example:error: externally-managed-environment\n× This environment is externally managedPlease note, this error is specific to Homebrew-installed Python installations and occurs because installing a undefined Python package requires you to either:undefinedundefinedWe recommend installing a virtual environment using venv, as shown in the undefined above.For all Python examples, please ensure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.","keywords":"","subsectionKeywords":"","url":"/v3/python-components#troubleshooting"},{"project":"v3","title":"Taking Spin for a spin","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedLet's get Spin and take it from nothing to a \"hello world\" application!","keywords":"quickstart","subsectionKeywords":"","url":"/v3/quickstart"},{"project":"v3","title":"Taking Spin for a spin","subheading":"Install Spin","content":"{{ tabs \"os\" }}{{ startTab \"Linux\"}}Download the spin binary along with a starter set of templates and plugins using the install.sh script hosted on this site:Then move the spin binary somewhere in your path, so you can run it from anywhere. For example:$ sudo mv ./spin /usr/local/bin/spin{{ blockEnd }}{{ startTab \"macOS\"}}Download the spin binary along with a starter set of templates and plugins using the install.sh script hosted on this site:Then move the spin binary somewhere in your path, so you can run it from anywhere. For example:$ sudo mv ./spin /usr/local/bin/spin{{ blockEnd }}{{ startTab \"Windows\"}}Download <a href=\"https://github.com/spinframework/spin/releases/latest\" class=\"spin-install\" id=\"spin-install-windows\">the Windows binary release of Spin</a> from GitHub.Unzip the binary release and place the spin.exe in your system path.{{ blockEnd }}\n{{ blockEnd }}undefined","keywords":"","subsectionKeywords":"","url":"/v3/quickstart#install-spin"},{"project":"v3","title":"Taking Spin for a spin","subheading":"Install the Prerequisites","content":"","keywords":"","subsectionKeywords":"","url":"/v3/quickstart#install-the-prerequisites"},{"project":"v3","title":"Taking Spin for a spin","subheading":"Install a Template","content":"undefinedThe quickest and most convenient way to start a new application is to install and use a Spin template for your preferred language.{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}$ spin templates install --git https://github.com/spinframework/spin --update\nCopying remote template source\nInstalling template redis-rust...\nInstalling template http-rust...\n... other templates omitted ...\n+------------------------------------------------------------------------+\n| Name                Description                                        |\n+========================================================================+\n| ... other templates omitted ...                                        |\n| http-rust           HTTP request handler using Rust                    |\n| redis-rust          Redis message handler using Rust                   |\n| ... other templates omitted ...                                        |\n+------------------------------------------------------------------------+Note: The Rust templates are in a repo that contains several other languages; they will all be installed together.{{ blockEnd }}{{ startTab \"TypeScript\" }}$ spin templates install --git https://github.com/spinframework/spin-js-sdk --update\nCopying remote template source\nInstalling template http-js...\nInstalling template http-ts...\n+------------------------------------------------------------------------+\n| Name                Description                                        |\n+========================================================================+\n| http-js             HTTP request handler using Javascript              |\n| http-ts             HTTP request handler using Typescript              |\n+------------------------------------------------------------------------+{{ blockEnd }}{{ startTab \"Python\" }}$ spin templates install --git https://github.com/spinframework/spin-python-sdk --update\nCopying remote template source\nInstalling template http-py...\n+---------------------------------------------+\n| Name      Description                       |\n+=============================================+\n| http-py   HTTP request handler using Python |\n+---------------------------------------------+{{ blockEnd }}{{ startTab \"TinyGo\" }}$ spin templates install --git https://github.com/spinframework/spin --update\nCopying remote template source\nInstalling template redis-go...\nInstalling template http-go...\n+------------------------------------------------------------------------+\n| Name                Description                                        |\n+========================================================================+\n| ... other templates omitted ...                                        |\n| http-go             HTTP request handler using (Tiny)Go                |\n| redis-go            Redis message handler using (Tiny)Go               |\n| ... other templates omitted ...                                        |\n+------------------------------------------------------------------------+Note: The Go templates are in a repo that contains several other languages; they will all be installed together.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/quickstart#install-a-template"},{"project":"v3","title":"Taking Spin for a spin","subheading":"Install the Tools","content":"Some languages require additional tool support for Wasm:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}You'll need the wasm32-wasip1 target for Rust:$ rustup target add wasm32-wasip1undefined{{ blockEnd }}{{ startTab \"TypeScript\" }}You will need npm installed and on the path.  npm will install any additional build tools as part of building the application.undefined{{ blockEnd }}{{ startTab \"Python\" }}Ensure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.You'll install all the required Python tools as part of building the application.  We'll cover that in the Build Your Application section below.  For now, there's nothing to do here!undefined{{ blockEnd }}{{ startTab \"TinyGo\" }}You'll need the TinyGo compiler, as the standard Go compiler does not yet support WASI exports.  See the undefined.undefined{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/quickstart#install-the-tools"},{"project":"v3","title":"Taking Spin for a spin","subheading":"Create Your First Application","content":"{{suh_cards}}\n{{card_element \"sample\" \"Checklist Sample App\" \"A checklist app that persists data in a key value store\" \"https://developer.fermyon.com/hub/preview/sample_checklist\" \"Typescript,Http,Kv\" true }}\n{{card_element \"sample\" \"AI-assisted News Summarizer\" \"Read an RSS newsfeed and have AI summarize it for you\" \"https://developer.fermyon.com/hub/preview/sample_newsreader_ai\" \"Typescript,Javascript,Ai\" true }}\n{{card_element \"template\" \"Zola SSG Template\" \"A template for using Zola framework to create a static webpage\" \"https://developer.fermyon.com/hub/preview/template_zola_ssg\" \"rust\" true }}\n{{blockEnd}}Now you are ready to create your first Spin application:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}Use the spin new command and the http-rust template to scaffold a new Spin application:$ spin new\nPick a template to start your application with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-csharp (HTTP request handler using C# (EXPERIMENTAL))\n  http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n> http-rust (HTTP request handler using Rust)\n  http-swift (HTTP request handler using SwiftWasm)\n  http-zig (HTTP request handler using Zig)\n  redis-go (Redis message handler using (Tiny)Go)\n  redis-rust (Redis message handler using Rust)\n\nEnter a name for your new application: hello_rust\nProject description: My first Rust Spin application\nHTTP path: /...This command created a directory with the necessary files needed to build and run a Rust Spin application.  Change to that directory, and look at the files.  It looks very much like a normal Rust library project:$ cd hello_rust\n$ tree\n.\n├── .gitignore\n├── Cargo.toml\n├── spin.toml\n└── src\n    └── lib.rsThe additional spin.toml file is the manifest file, which tells Spin what events should trigger what components.  In this case our trigger is HTTP, for a Web application, and we have only one component, at the route /....  This is a wildcard that matches any route:spin_manifest_version = 2\n\n[application]\nname = \"hello_rust\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first Rust Spin application\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-rust\"\n\n[component.hello-rust]\nsource = \"target/wasm32-wasip1/release/hello_rust.wasm\"\nallowed_outbound_hosts = []\n[component.hello-rust.build]\ncommand = \"cargo build --target wasm32-wasip1 --release\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]This represents a simple Spin HTTP application (triggered by an HTTP request).  It has:undefinedundefinedundefinedNow let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in Rust — a regular Rust function that\ntakes an HTTP request as a parameter and returns an HTTP response, and it is\nannotated with the http_component macro which identifies it as the entry point\nfor HTTP requests:use spin_sdk::http::{IntoResponse, Request, Response};\nuse spin_sdk::http_component;\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn handle_hello_rust(req: Request) -> anyhow::Result<impl IntoResponse> {\n    println!(\"Handling request to {:?}\", req.header(\"spin-full-url\"));\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, Fermyon\")\n        .build())\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}Use the spin new command and the http-ts template to scaffold a new Spin application.  (If you prefer JavaScript to TypeScript, the http-js template is very similar.):$ spin new\nPick a template to start your application with:\n  http-js (HTTP request handler using Javascript)\n> http-ts (HTTP request handler using Typescript)\nEnter a name for your new application: hello_typescript\nProject description: My first TypeScript Spin application\nHTTP path: /...This command created a directory with the necessary files needed to build and run a TypeScript Spin application.  Change to that directory, and look at the files.  It looks similar to a lot of NPM projects:$ cd hello_typescript\n$ tree\n.\n├── config\n│   └── knitwit.json\n├── package.json\n├── spin.toml\n├── src\n│   └── index.ts\n├── tsconfig.json\n└── webpack.config.jsThe additional spin.toml file is the manifest file, which tells Spin what events should trigger what components.  In this case our trigger is HTTP, for a Web application, and we have only one component, at the route /....  This is a wildcard that matches any route:spin_manifest_version = 2\n\n[application]\nname = \"hello_typescript\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first TypeScript Spin application\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-typescript\"\n\n[component.hello-typescript]\nsource = \"dist/hello-typescript.wasm\"\nexclude_files = [\"**/node_modules\"]\n[component.hello-typescript.build]\ncommand = \"npm run build\"This represents a simple Spin HTTP application (triggered by an HTTP request).  It has:undefinedundefinedundefinedNow let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in TypeScript — A function is attached to the fetch event listener which receives and responds to the HTTP request.❯ cat hello-world/src/index.ts \nimport { AutoRouter } from 'itty-router';\n\nlet router = AutoRouter();\n\nrouter\n    .get(\"/\", () => new Response(\"hello universe\"))\n    .get('/hello/:name', ({ name }) => `Hello, ${name}!`)\n\n//@ts-ignore\naddEventListener('fetch', async (event: FetchEvent) => {\n    event.respondWith(router.fetch(event.request));\n});{{ blockEnd }}{{ startTab \"Python\"}}You can install the Spin template for Python HTTP handlers from the undefined using the following command:$ spin templates install --git https://github.com/spinframework/spin-python-sdk --updateThe above command will install the http-py template and produce an output similar to the following:Copying remote template source\nInstalling template http-py...\nInstalled 1 template(s)\n\n+---------------------------------------------+\n| Name      Description                       |\n+=============================================+\n| http-py   HTTP request handler using Python |\n+---------------------------------------------+undefined For more information about managing Spin templates, see the undefined.This command created a directory with the necessary files needed to build and run a Python Spin application.  Change to that directory, and look at the files.  It contains a minimal Python application:$ spin new -t http-py hello-python --accept-defaultsOnce the component is created, we can change into the hello-python directory, create and activate a virtual environment and then install the component's requirements:$ cd hello-pythonCreate a virtual environment directory (we are still inside the Spin app directory):# python<version> -m venv <virtual-environment-name>\n$ python3 -m venv venv-dirActivate the virtual environment (this command depends on which operating system you are using):# macOS & Linux command to activate\n$ source venv-dir/bin/activateIf you are using Windows, use the following commands:C:\\Work> python3 -m venv venv\nC:\\Work> venv\\Scripts\\activateThe (venv-dir) will prefix your terminal prompt now:(venv-dir) user@123-456-7-8 hello-python %The requirements.txt, by default, contains the references to the spin-sdk and componentize-py packages. These can be installed in your virtual environment using the following command:$ pip3 install -r requirements.txt \nCollecting spin-sdk==3.1.0 (from -r requirements.txt (line 1))\n  Using cached spin_sdk-3.1.0-py3-none-any.whl.metadata (16 kB)\nCollecting componentize-py==0.13.3 (from -r requirements.txt (line 2))\n  Using cached componentize_py-0.13.3-cp37-abi3-macosx_10_12_x86_64.whl.metadata (3.4 kB)\nUsing cached spin_sdk-3.1.0-py3-none-any.whl (94 kB)\nUsing cached componentize_py-0.13.3-cp37-abi3-macosx_10_12_x86_64.whl (38.8 MB)\nInstalling collected packages: spin-sdk, componentize-py\nSuccessfully installed componentize-py-0.13.3 spin-sdk-3.1.0","keywords":"","subsectionKeywords":"","url":"/v3/quickstart#create-your-first-application"},{"project":"v3","title":"Taking Spin for a spin","subheading":"Structure of a Python Component","content":"The hello-python directory structure created by the Spin http-py template is shown below:├── app.py\n├── spin.toml\n└── requirements.txt The additional spin.toml file is the manifest file, which tells Spin what events should trigger what components.  In this case our trigger is HTTP, for a Web application, and we have only one component, at the route /....  This is a wildcard that matches any route.spin_manifest_version = 2\n\n[application]\nname = \"hello-python\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first Python Spin application\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-python\"\n\n[component.hello-python]\nsource = \"app.wasm\"\n[component.hello-python.build]\ncommand = \"componentize-py -w spin-http componentize app -o app.wasm\"This represents a simple Spin HTTP application (triggered by an HTTP request).  It has:undefinedundefinedundefinedNow let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in Python — a regular function named handle_request that\ntakes an HTTP request as a parameter and returns an HTTP response.from spin_sdk.http import IncomingHandler, Request, Response\n\nclass IncomingHandler(IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(\"Hello from the Python SDK!\", \"utf-8\")\n        ){{ blockEnd }}{{ startTab \"TinyGo\"}}Use the spin new command and the http-go template to scaffold a new Spin application.$ spin new\nPick a template to start your application with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-empty (HTTP application with no components)\n> http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n  http-php (HTTP request handler using PHP)\n  http-rust (HTTP request handler using Rust)\nEnter a name for your new application: hello_go\nDescription: My first Go Spin application\nHTTP path: /...This command created a directory with the necessary files needed to build and run a Go Spin application using the TinyGo compiler.  Change to that directory, and look at the files.  It looks very much like a normal Go project:$ cd hello_go\n$ tree\n.\n├── go.mod\n├── go.sum\n├── main.go\n└── spin.tomlThe additional spin.toml file is the manifest file, which tells Spin what events should trigger what components.  In this case our trigger is HTTP, for a Web application, and we have only one component, at the route /....  This is a wildcard that matches any route.spin_manifest_version = 2\n\n[application]\nname = \"hello_go\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first Go Spin application\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-go\"\n\n[component.hello-go]\nsource = \"main.wasm\"\nallowed_outbound_hosts = []\n[component.hello-go.build]\ncommand = \"tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"This represents a simple Spin HTTP application (triggered by an HTTP request).  It has:undefinedundefinedundefinedNow let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in Go. Notice where the work is done.  The\nmain function is empty (and Spin never calls it).  Instead, the init function\nsets up a callback, and passes that callback to spinhttp.Handle to register it as\nthe handler for HTTP requests.  You can learn more about this structure\nin the undefined.package main\n\nimport (\n        \"fmt\"\n        \"net/http\"\n\n        spinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n)\n\nfunc init() {\n        spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n                w.Header().Set(\"Content-Type\", \"text/plain\")\n                fmt.Fprintln(w, \"Hello Fermyon!\")\n        })\n}\n\nfunc main() {}{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/quickstart#structure-of-a-python-component"},{"project":"v3","title":"Taking Spin for a spin","subheading":"Build Your Application","content":"The Spin template creates starter source code.  Now you need to turn that into a Wasm module.  The template puts build instructions for each component into the manifest.  Use the spin build command to run them:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}$ spin build\nExecuting the build command for component hello-rust: cargo build --target wasm32-wasip1 --release\n    Updating crates.io index\n    Updating git repository `https://github.com/spinframework/spin`\n    Updating git repository `https://github.com/bytecodealliance/wit-bindgen`\n   Compiling anyhow v1.0.69\n   Compiling version_check v0.9.4\n   # ...\n   Compiling spin-sdk v0.10.0 \n   Compiling hello-rust v0.1.0 (/home/ivan/testing/start/hello_rust)\n    Finished release [optimized] target(s) in 11.94s\nFinished building all Spin componentsIf the build fails, check:undefinedundefinedundefinedundefinedIf you would like to know what build command Spin runs for a component, you can find it in the manifest, in the component.(id).build section:[component.hello-rust.build]\ncommand = \"cargo build --target wasm32-wasip1 --release\"You can always run this command manually; spin build is a shortcut to save you having to remember it.{{ blockEnd }}{{ startTab \"TypeScript\"}}As normal for NPM projects, before you build for the first time, you must run npm install:$ npm install\n\nadded 141 packages, and audited 142 packages in 13s\n\n20 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilitiesThen run spin build:$ spin build\nExecuting the build command for component hello-typescript: npm run build\n\n> hello-typescript@1.0.0 build\n> knitwit --out-dir build/wit/knitwit --out-world combined && npx webpack --mode=production && npx mkdirp target && npx j2w -i dist.js -d combined-wit -n combined -o target/hello-typescript.wasm\n\nasset spin.js 4.57 KiB [emitted] (name: main)\nruntime modules 670 bytes 3 modules\n./src/index.ts 2.85 KiB [built] [code generated]\nwebpack 5.75.0 compiled successfully in 1026 ms\n\nFinished building all Spin componentsIf you would like to know what build command Spin runs for a component, you can find it in the manifest, in the component.(id).build section:[component.hello-typescript.build]\ncommand = [\"npm install\", \"npm run build\"]You can always run this command manually; spin build is a shortcut.{{ blockEnd }}{{ startTab \"Python\"}}As a standard practice for Python, create and activate a virtual env:If you are on a Mac/linux based operating system use the following commands:$ python3 -m venv venv\n$ source venv/bin/activateIf you are using Windows, use the following commands:C:\\Work> python3 -m venv venv\nC:\\Work> venv\\Scripts\\activateInstall componentize-py and spin-sdk packages$ pip3 install -r requirements.txtThen run:$ spin build\nExecuting the build command for component hello-python: \"componentize-py -w spin-http componentize app -o app.wasm\"\nFinished building all Spin componentsIf the build fails, check:undefinedundefinedundefinedIf you would like to know what build command Spin runs for a component, you can find it in the manifest, in the component.(id).build section:[component.hello-python.build]\ncommand = \"componentize-py -w spin-http componentize app -o app.wasm\"You can always run this command manually; spin build is a shortcut.{{ blockEnd }}{{ startTab \"TinyGo\"}}$ spin build\nExecuting the build command for component hello-go: tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\ngo: downloading github.com/fermyon/spin/sdk/go v0.10.0\nFinished building all Spin componentsIf the build fails, check:undefinedundefinedundefinedundefinedIf you would like to know what build command Spin runs for a component, you can find it in the manifest, in the component.(id).build section:[component.hello-go.build]\ncommand = \"tinygo build -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"You can always run this command manually; spin build is a shortcut to save you having to remember it.{{ blockEnd }}{{ blockEnd }}undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/quickstart#build-your-application"},{"project":"v3","title":"Taking Spin for a spin","subheading":"Run Your Application","content":"Now that you have created the application and built the component, you can undefined\nthe application (pun intended):$ spin up\nServing http://127.0.0.1:3000\nAvailable Routes:\n  hello-typescript: http://127.0.0.1:3000 (wildcard)undefinedundefinedSpin instantiates all components from the application manifest, and\ncreates the router configuration for the HTTP trigger according to the routes in the manifest. The\ncomponent can now be invoked by making requests to http://localhost:3000/\n(or any path under that, since it's a wildcard):$ curl -i localhost:3000\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 14\ndate = \"2023-11-04T00:00:01Z\"\n\nHello, FermyonundefinedYou'll also see any logging (stdout/stderr) from the generated code printed to the console where Spin is running. For more details, see the undefined.Congratulations! You just created, built and ran your first Spin application!","keywords":"","subsectionKeywords":"","url":"/v3/quickstart#run-your-application"},{"project":"v3","title":"Taking Spin for a spin","subheading":"Deploy Your Application to Fermyon Cloud","content":"spin up runs your application locally. Now it's time to put it on the Web via undefined.undefined","keywords":"","subsectionKeywords":"","url":"/v3/quickstart#deploy-your-application-to-fermyon-cloud"},{"project":"v3","title":"Taking Spin for a spin","subheading":"Log in to Fermyon Cloud","content":"Before deploying your application to Fermyon Cloud, you have to log in, using the spin login command. This generates a code to authorize your current device against the Fermyon Cloud, and prints a link that will take you to where you enter the code. (You will need to be logged into your GitHub account; if you're not, it will prompt you to log in.) Follow the instructions in the prompt to complete the authorization process.spin login prints a confirmation message when authorization completes:$ spin login\n\nCopy your one-time code:\n\nXXXXXXXX\n\n...and open the authorization page in your browser:\n\nhttps://cloud.fermyon.com/device-authorization\n\nWaiting for device authorization...\nDevice authorized!","keywords":"","subsectionKeywords":"","url":"/v3/quickstart#log-in-to-fermyon-cloud"},{"project":"v3","title":"Taking Spin for a spin","subheading":"Deploy the Application","content":"Now let's deploy the application:$ spin deployThe deployment process prints progress information as your application uploads and is rolled out to the cloud:Uploading hello_typescript version 0.1.0+XXXXXXXX to Fermyon Cloud...\nDeploying...\nWaiting for application to become ready... ready\nAvailable Routes:\n  hello-typescript: https://hello-typescript-XXXXXXXX.fermyon.app (wildcard)You can Ctrl+Click on the link in the terminal to visit the web application you just deployed.undefinedCongratulations again - you've now deployed your first Spin application to undefined!","keywords":"","subsectionKeywords":"","url":"/v3/quickstart#deploy-the-application"},{"project":"v3","title":"Taking Spin for a spin","subheading":"Next Steps","content":"undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/quickstart#next-steps"},{"project":"v3","title":"Relational Database Storage","subheading":"","content":"undefinedundefinedSpin provides two interfaces for relational (SQL) databases:undefinedundefinedThis page covers the \"bring your own database\" scenario.  See undefined for the built-in service.{{ details \"Why do I need a Spin interface? Why can't I just use my language's database libraries?\" \"The current version of the WebAssembly System Interface (WASI) doesn't provide a sockets interface, so database libraries that depend on sockets can't be built to Wasm. The Spin interface means Wasm modules can bypass this limitation by asking Spin to make the database connection on their behalf.\" }}","subsectionKeywords":"","url":"/v3/rdbms-storage"},{"project":"v3","title":"Relational Database Storage","subheading":"Using MySQL and PostgreSQL From Applications","content":"The Spin SDK surfaces the Spin MySQL and PostgreSQL interfaces to your language. The set of operations is the same across both databases:| Operation  | Parameters                 | Returns             | Behavior |\n|------------|----------------------------|---------------------|----------|\n| open     | address                    | connection resource | Opens a connection to the specified database. The host must be listed in allowed_outbound_hosts. Other operations must be called through a connection. |\n| query    | statement, SQL parameters  | database records    | Runs the specified statement against the database, returning the query results as a set of rows. |\n| execute  | statement, SQL parameters  | integer (not MySQL) | Runs the specified statement against the database, returning the number of rows modified by the statement.  (MySQL does not return the modified row count.) |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedMySQL functions are available in the spin_sdk::mysql module, and PostgreSQL functions in the spin_sdk::pg module. The function names match the operations above. This example shows MySQL:// For PostgreSQL, use `spin_sdk::pg` or `spin_sdk::pg3`\nuse spin_sdk::mysql::{self, Connection, Decode, ParameterValue};\n\nlet connection = Connection::open(&address)?;\n\nlet params = vec![ParameterValue::Int32(id)];\n// For PostgreSQL, use `$1` placeholder syntax\nlet rowset = connection.query(\"SELECT id, name FROM pets WHERE id = ?\", &params)?;\n\nmatch rowset.rows.first() {\n    None => /* no rows matched query */,\n    Some(row) => {\n        let name = String::decode(&row[1])?;\n    }\n}undefinedundefinedundefinedundefinedundefinedundefinedYou can find complete examples for using relational databases in the Spin repository on GitHub (undefined, undefined).For full information about the MySQL and PostgreSQL APIs, see undefined.{{ blockEnd }}{{ startTab \"TypeScript\"}}undefinedThe code below is an undefined. There is also an outbound undefined available.// https://itty.dev/itty-router/routers/autorouter\nimport { AutoRouter } from 'itty-router';\nimport { Mysql } from '@fermyon/spin-sdk';\n\n// Connects as the root user without a password \nconst DB_URL = \"mysql://root:@127.0.0.1/spin_dev\"\n\n/*\n Run the following commands to setup the instance:\n create database spin_dev;\n use spin_dev;\n create table test(id int, val int);\n insert into test values (4,4);\n*/\n\nlet router = AutoRouter();\n\nrouter\n    .get(\"/\", () => {\n        let conn = Mysql.open(DB_URL);\n        conn.execute('delete from test where id=?', [4]);\n        conn.execute('insert into test values (4,5)', []);\n        let ret = conn.query('select * from test', []);\n\n        return new Response(JSON.stringify(ret, null, 2));\n    })\n\n//@ts-ignore\naddEventListener('fetch', async (event: FetchEvent) => {\n    event.respondWith(router.fetch(event.request));\n});{{ blockEnd }}{{ startTab \"Python\"}}undefinedThe code below is an undefined. There is also an outbound undefined available.from spin_sdk import http\nfrom spin_sdk.http import Request, Response\nfrom spin_sdk import mysql\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        with mysql.open(\"mysql://root:@127.0.0.1/spin_dev\") as db:\n            print(db.query(\"select * from test\", []))\n        \n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(\"Hello from Python!\", \"utf-8\")\n        ){{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedMySQL functions are available in the github.com/fermyon/spin/sdk/go/v2/mysql package, and PostgreSQL in github.com/fermyon/spin/sdk/go/v2/pg. undefinedThe package follows the usual Go database API. Use Open to return a connection to the database of type *sql.DB - see the undefined for usage information.  For example:package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\n\tspinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n\t\"github.com/fermyon/spin/sdk/go/v2/pg\"\n)\n\ntype Pet struct {\n\tID        int64\n\tName      string\n\tPrey      *string // nullable field must be a pointer\n\tIsFinicky bool\n}\n\nfunc init() {\n\tspinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n\n\t\t// addr is the environment variable set in `spin.toml` that points to the\n\t\t// address of the Mysql server.\n\t\taddr := os.Getenv(\"DB_URL\")\n\n\t\t// For MySQL, use `mysql.Open`\n\t\tdb := pg.Open(addr)\n\t\tdefer db.Close()\n\n\t\t// For MySQL, use `?` placeholder syntax\n\t\t_, err := db.Query(\"INSERT INTO pets VALUES ($1, 'Maya', $2, $3);\", int32(4), \"bananas\", true)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\trows, err := db.Query(\"SELECT * FROM pets\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tvar pets []*Pet\n\t\tfor rows.Next() {\n\t\t\tvar pet Pet\n\t\t\tif err := rows.Scan(&pet.ID, &pet.Name, &pet.Prey, &pet.IsFinicky); err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t}\n\t\t\tpets = append(pets, &pet)\n\t\t}\n\t\tjson.NewEncoder(w).Encode(pets)\n\t})\n}\n\nfunc main() {}{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/rdbms-storage#using-mysql-and-postgresql-from-applications"},{"project":"v3","title":"Relational Database Storage","subheading":"Granting Network Permissions to Components","content":"By default, Spin components are not allowed to make outgoing network requests, including MySQL or PostgreSQL. This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing. To grant a component permission to make network requests to a particular host, use the allowed_outbound_hosts field in the component manifest, specifying the host and allowed port:[component.uses-db]\nallowed_outbound_hosts = [\"postgres://postgres.example.com:5432\"]","keywords":"","subsectionKeywords":"","url":"/v3/rdbms-storage#granting-network-permissions-to-components"},{"project":"v3","title":"Relational Database Storage","subheading":"Configuration-Based Permissions","content":"You can use undefined in the allowed_outbound_hosts field. However, this feature is not yet available on Fermyon Cloud.","keywords":"","subsectionKeywords":"","url":"/v3/rdbms-storage#configuration-based-permissions"},{"project":"v3","title":"Redis Storage","subheading":"","content":"undefinedundefinedSpin provides an interface for you to read and write the Redis key/value store, and to publish Redis pub-sub messages.{{ details \"Why do I need a Spin interface? Why can't I just use my language's Redis library?\" \"The current version of the WebAssembly System Interface (WASI) doesn't provide a sockets interface, so Redis libraries that depend on sockets can't be built to Wasm. The Spin interface means Wasm modules can bypass this limitation by asking Spin to make the Redis connection on their behalf.\" }}","subsectionKeywords":"","url":"/v3/redis-outbound"},{"project":"v3","title":"Redis Storage","subheading":"Using Redis From Applications","content":"The Spin SDK surfaces the Spin Redis interface to your language. The set of operations is common across all SDKs:| Operation    | Parameters | Returns | Behavior |\n|--------------|---------------------|---------|----------|\n| open       | address    | connection resource | Opens a connection to the specified Redis instance. The host must be listed in allowed_outbound_hosts. Other operations must be called through a connection. (Exception: for JavaScript, do not call open, and pass the address to each data operation - see the language guides below.) |\n| Single value operations                      |\n| get        | key        | bytes   | Returns the value of key. If the key does not exist, returns a zero-length array. |\n| set        | key, bytes | -       | Sets the value of key, overwriting any existing value. |\n| incr       | key        | integer | Increments the value at key by 1. If the key does not exist, its value is set to 0 first (and immediately incremented to 1). If the current value isn't an integer, or a string that represents an integer, it errors and the value is not changed. |\n| del        | list of keys | -     | Removes the specified keys. Keys that don't exist are ignored (they do undefined cause an error). |\n| Set value operations                         |\n| sadd       | key, list of strings | integer | Adds the strings to the set of values of key, and returns the number of newly added values. If the key does not exist, its value is set to the set of values |\n| smembers   | key        | list of strings | Returns the set of values of key. if the key does not exist, this is an empty set. |\n| srem       | key, list of strings | integer | Removes the strings from the set of values of key, and returns the number of newly removed values. If the key does not exist, this does nothing. |\n| Pub-sub operations                           |\n| publish    | channel, bytes | - | Publishes a message to the specified channel, with the specified payload bytes. |\n| General operations                           |\n| execute    | command, list of argument values | list of results | Executes the specified command with the specified arguments. This is a general-purpose 'escape hatch' if you need a command that isn't covered by the built-in operations. |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedRedis functions are available in the spin_sdk::redis module.To access a Redis instance, use the Connection::open function.let connection = spin_sdk::redis::Connection::open(&address)?;You can then call functions on the Connection to work with the Redis instance:connection.set(\"my-key\", &\"my-value\".into());\nlet data = connection.get(\"my-key\")?;For full details of the Redis API, see the undefined;undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedYou can find a complete Rust code example for using outbound Redis from an HTTP component in the undefined. Please also see this, related, undefined.{{ blockEnd }}{{ startTab \"TypeScript\"}}undefinedRedis functions are available on undefined. The function names match the operations above. For example:import { Redis } from \"@fermyon/spin-sdk\"\n\nlet db = Redis.open(\"redis://localhost:6379\")\nlet value = db.get(key);undefinedundefinedundefinedundefinedundefinedundefinedYou can find a complete TypeScript example for using outbound Redis from an HTTP component in the undefined. Please also see this, related, undefined.{{ blockEnd }}{{ startTab \"Python\"}}undefinedRedis functions are available in undefined. The function names are prefixed redis_. You must pass the Redis instance address to undefined operation as its first parameter. For example:from spin_sdk import redis\nwith redis.open(\"redis://localhost:6379\") as db:\n    val = db.get(\"test\")undefinedundefinedundefinedundefinedundefinedundefinedYou can find a complete Python code example for using outbound Redis from an HTTP component in the undefined. Please also see this, related, undefined.{{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedRedis functions are available in the github.com/fermyon/spin/sdk/go/v2/redis package. undefined The function names are TitleCased. For example:import (\n\t\"github.com/fermyon/spin/sdk/go/v2/redis\"\n)\n\nrdb := redis.NewClient(addr)\npayload, err := rdb.Get(key)undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedYou can find a complete TinyGo example for using outbound Redis from an HTTP component in the undefined. Please also see this, related, undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/redis-outbound#using-redis-from-applications"},{"project":"v3","title":"Redis Storage","subheading":"Granting Network Permissions to Components","content":"By default, Spin components are not allowed to make outgoing network requests, including Redis. This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing. To grant a component permission to make network requests to a particular host, use the allowed_outbound_hosts field in the component manifest, specifying the host and allowed port:[component.uses-redis]\nallowed_outbound_hosts = [\"redis://redis.example.com:6379\"]","keywords":"","subsectionKeywords":"","url":"/v3/redis-outbound#granting-network-permissions-to-components"},{"project":"v3","title":"Redis Storage","subheading":"Configuration-Based Permissions","content":"You can use undefined in the allowed_outbound_hosts field. However, this feature is not yet available on Fermyon Cloud.","keywords":"","subsectionKeywords":"","url":"/v3/redis-outbound#configuration-based-permissions"},{"project":"v3","title":"The Spin Redis trigger","subheading":"","content":"undefinedundefinedundefinedundefinedPub-sub (publish-subscribe) messaging is a popular architecture for asynchronous message processing. Spin has built-in support to creating and running applications in response to messages on undefined.The Redis trigger in Spin subscribes to messages from a given Redis instance, and dispatches those messages to components for handling.undefinedundefined","subsectionKeywords":"","url":"/v3/redis-trigger"},{"project":"v3","title":"The Spin Redis trigger","subheading":"Specifying a Redis Trigger","content":"A Redis trigger maps a Redis channel to a component. For example:[[trigger.redis]]\naddress = \"redis://notifications.example.com:6379\" # the Redis instance that the trigger subscribes to (optional - see below)\nchannel = \"messages\"          # the channel that the trigger subscribes to\ncomponent = \"my-application\"  # the name of the component to handle this routeSuch a trigger says that Redis messages on the specified undefined should be handled by the specified undefined. The component field works the same way across all triggers - see undefined for the details.undefinedYou can use undefined in the address and channel fields.","keywords":"","subsectionKeywords":"","url":"/v3/redis-trigger#specifying-a-redis-trigger"},{"project":"v3","title":"The Spin Redis trigger","subheading":"Setting a Default Server","content":"In many applications, all components listen to the same Redis server (on different channels, of course). For this case, it is more convenient to specify the server at the application level instead of on each component. This is done via the [application.trigger.redis] section of manifest:[application.trigger.redis]\naddress = \"redis://notifications.example.com:6379\"undefinedYou can use undefined in the address field.","keywords":"","subsectionKeywords":"","url":"/v3/redis-trigger#setting-a-default-server"},{"project":"v3","title":"The Spin Redis trigger","subheading":"Redis Trigger Authentication","content":"By default, Spin does not authenticate to Redis. You can work around this by providing a password in the redis:// URL.  For example: address = \"redis://:p4ssw0rd@localhost:6379\"undefinedundefinedAs mentioned above, you can use undefined in Redis address fields. This can be particularly useful for credentials, allowing you to pass credentials in via undefined rather than including them in spin.toml.","keywords":"","subsectionKeywords":"","url":"/v3/redis-trigger#redis-trigger-authentication"},{"project":"v3","title":"The Spin Redis trigger","subheading":"Redis Components","content":"Spin runs Redis components using the undefined.  In this model, the Wasm module exports a well-known interface that Spin calls to handle the Redis message.","keywords":"","subsectionKeywords":"","url":"/v3/redis-trigger#redis-components"},{"project":"v3","title":"The Spin Redis trigger","subheading":"The Message Handler","content":"The exact signature of the Redis handler, and how a function is identified to be exported as the handler, will depend on your language.{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedIn Rust, the handler is identified by the #[spin_sdk::redis_component] attribute.  It takes a bytes::Bytes, representing the raw payload of the Redis message, and returns an anyhow::Result indicating success or an error with details.  This example just logs the payload as a string:use anyhow::Result;\nuse bytes::Bytes;\nuse spin_sdk::redis_component;\nuse std::str::from_utf8;\n\n/// A simple Spin Redis component.\n#[redis_component]\nfn on_message(message: Bytes) -> Result<()> {\n    println!(\"{}\", from_utf8(&message)?);\n    Ok(())\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}The JavaScript/TypeScript SDK doesn't currently support Redis components.  Please undefined if this is important to you.{{ blockEnd }}{{ startTab \"Python\"}}In Python, the handler needs to implement the undefined class, and override the handle_message method:from spin_sdk.wit import exports\nclass InboundRedis(exports.InboundRedis):\n    def handle_message(self, message: bytes):\n        print(message){{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedIn Go, you register the handler as a callback in your program's init function.  Call redis.Handle (from the Spin SDK redis package), passing your handler as the sole argument.  Your handler takes a single byte slice ([]byte) argument, and may return an error or nil.undefinedThis example just logs the payload as a string:package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/fermyon/spin/sdk/go/v2/redis\"\n)\n\nfunc init() {\n\tredis.Handle(func(payload []byte) error {\n\t\tfmt.Println(string(payload))\n\t\treturn nil\n\t})\n}\n\nfunc main() {}{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/redis-trigger#the-message-handler"},{"project":"v3","title":"The Spin Redis trigger","subheading":"Inside Redis Components","content":"For the most part, you'll build Redis component modules using a language SDK (see the Language Guides section), such as a Rust crate or Go package.  If you're interested in what happens inside the SDK, or want to implement Redis components in another language, read on!The Redis component interface is defined using a WebAssembly Interface (WIT) file.  (undefined).  You can find the latest WITs for Spin Redis components at undefined.In particular, the entry point for Spin Redis components is defined in undefined:interface inbound-redis {\n  use redis-types.{payload, error}\n\n  // The entrypoint for a Redis handler.\n  handle-message: func(message: payload) -> result<_, error>\n}This is the interface that all Redis components must implement, and\nwhich is used by Spin when instantiating and invoking the component.\nHowever, it is implemented internally by the Spin SDK - you don't need to implement it directly.","keywords":"","subsectionKeywords":"","url":"/v3/redis-trigger#inside-redis-components"},{"project":"v3","title":"Spin Apps in Registries","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v3/registry-tutorial"},{"project":"v3","title":"Spin Apps in Registries","subheading":"Spin Registry Support","content":"With Spin's registry support, you can package and save your Spin application as an artifact in a registry like undefined or undefined and then run your Spin app from these registries.","keywords":"","subsectionKeywords":"","url":"/v3/registry-tutorial#spin-registry-support"},{"project":"v3","title":"Spin Apps in Registries","subheading":"Prerequisites","content":"First, follow undefined to ensure you have the latest version of Spin installed (this tutorial refers to Spin 1.0 and above). You can check the Spin version using the following command:$ spin --version","keywords":"","subsectionKeywords":"","url":"/v3/registry-tutorial#prerequisites"},{"project":"v3","title":"Spin Apps in Registries","subheading":"Publishing and Running Spin Applications Using Registries (Video)","content":"The following video shows you how to push a Spin app to GHCR, and then run that artifact with Spin or with Docker. The video also contains additional information about signing and verifying your GHCR artifacts.The rest of this page shows you how to use GHCR artifacts locally with Spin.","keywords":"","subsectionKeywords":"","url":"/v3/registry-tutorial#publishing-and-running-spin-applications-using-registries-video"},{"project":"v3","title":"Spin Apps in Registries","subheading":"Set Up Your GHCR Instance","content":"To use a GHCR instance, you need to set up authentication. Follow undefined to generate a personal access token and then use it to sign into your GHCR. You should see the following message to confirm your login attempt to GHCR was successful:> Login Succeeded","keywords":"","subsectionKeywords":"","url":"/v3/registry-tutorial#set-up-your-ghcr-instance"},{"project":"v3","title":"Spin Apps in Registries","subheading":"Push a Spin App to GHCR","content":"Let's use this full-stack undefined to walk through this tutorial. If you have a Spin app already feel free to navigate to that directory and skip the step below.Fork and clone the app undefined:$ git clone https://github.com/USERNAME/spin-react-fullstack.gitNow, switch to that directory and rebuild the application:$ cd spin-react-fullstack\n$ spin buildNow we're ready to push the application. Run the spin registry push command to push your application to the registry:$ spin registry push ghcr.io/USERNAME/spin-react-fullstack:v1undefinedYou now have a Spin application stored in your registry. You can see the artifact under packages in the undefined.","keywords":"","subsectionKeywords":"","url":"/v3/registry-tutorial#push-a-spin-app-to-ghcr"},{"project":"v3","title":"Spin Apps in Registries","subheading":"Pull a Spin App From GHCR","content":"Now that we've successfully pushed a Spin app, let's see if we can pull it. To do so, run the following command:$ spin registry pull ghcr.io/USERNAME/spin-react-fullstack:v1","keywords":"","subsectionKeywords":"","url":"/v3/registry-tutorial#pull-a-spin-app-from-ghcr"},{"project":"v3","title":"Spin Apps in Registries","subheading":"Run a Spin App From GHCR","content":"Lastly, let's run this Spin application:$ spin up -f ghcr.io/USERNAME/spin-react-fullstack:v1","keywords":"","subsectionKeywords":"","url":"/v3/registry-tutorial#run-a-spin-app-from-ghcr"},{"project":"v3","title":"Spin Apps in Registries","subheading":"Deploy a Spin App from GHCR (or any registry)","content":"You can deploy a Spin app from any registry such as GHCR or DockerHub using the CLI command spin deploy -f <remote-reference-here>undefined","keywords":"","subsectionKeywords":"","url":"/v3/registry-tutorial#deploy-a-spin-app-from-ghcr-or-any-registry"},{"project":"v3","title":"Spin Apps in Registries","subheading":"Conclusion","content":"Congratulations on completing this tutorial! You have now successfully built, pushed, pulled, and run a Spin app using GHCR. Behind the scenes, Spin uses undefined project to distribute Spin apps across container registries. To learn more about how this feature works, take a look at undefined and undefined.","keywords":"","subsectionKeywords":"","url":"/v3/registry-tutorial#conclusion"},{"project":"v3","title":"Spin Apps in Registries","subheading":"Next Steps","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v3/registry-tutorial#next-steps"},{"project":"v3","title":"Running Spin Applications","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedOnce you have created and built your application, it's ready to run.  To run an application, use the spin up command.","subsectionKeywords":"","url":"/v3/running-apps"},{"project":"v3","title":"Running Spin Applications","subheading":"Specifying the Application to Run","content":"By default, spin up looks for a file named spin.toml in the current directory.If your manifest is named something different, or isn't in your current directory, use the -f (--from) flag. You also use -f to run remote applications.| -f Value                      | spin up Behavior  |\n|---------------------------------|---------------------|\n| File name: -f demo.toml       | Runs the specified manifest file |\n| Directory name: -f demo/      | Looks for a spin.toml file in that directory and runs that |\n| Registry reference: -f ghcr.io/fermyon/example:v1 | Pulls the application from the registry and runs that |undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/running-apps#specifying-the-application-to-run"},{"project":"v3","title":"Running Spin Applications","subheading":"Specifying the Wasm File to Run","content":"The spin up --from (spin up -f) option can point to a pre-existing Wasm binary executable instead of an application's manifest:$ spin up --from mymodule.wasmPlease note that the uses for performing spin up using just a Wasm file are very limited outside of basic testing of the Wasm file. This is because Wasm files run in this way have no access to application-level configuration that allows storage, outbound HTTP and so on. Only incoming HTTP handlers are supported.","keywords":"","subsectionKeywords":"","url":"/v3/running-apps#specifying-the-wasm-file-to-run"},{"project":"v3","title":"Running Spin Applications","subheading":"Testing HTTP Applications","content":"By default, HTTP applications listen on localhost:3000.  You can override this with the --listen option.  Spin prints links to the application components to make it easy to open them in the browser or copy them to curl commands for testing.","keywords":"","subsectionKeywords":"","url":"/v3/running-apps#testing-http-applications"},{"project":"v3","title":"Running Spin Applications","subheading":"Application Output","content":"By default, Spin prints application output, and any of its own error messages, to the console.To hide application output, pass the --quiet flag:$ spin up --quietTo limit application output to specific components, pass the --follow flag:$ spin up --follow cart --follow cart-api","keywords":"","subsectionKeywords":"","url":"/v3/running-apps#application-output"},{"project":"v3","title":"Running Spin Applications","subheading":"Persistent Logs","content":"By default:undefinedundefinedTo control logging, pass the --log-dir flag.  The logs will be saved to the specified directory (no matter whether the application is local or remote):$ spin up --log-dir ~/dev/bugbashIf you prefer undefined to have the stdout and stderr of your application's components written to disk (as in the example above), you can pass the --log-dir flag with an empty string, like this:$ spin up --log-dir \"\"","keywords":"","subsectionKeywords":"","url":"/v3/running-apps#persistent-logs"},{"project":"v3","title":"Running Spin Applications","subheading":"Trigger-Specific Options","content":"Some trigger types support additional spin up flags.  For example, HTTP applications can have a --listen flag to specify an address and port to listen on.  See the undefined and undefined pages for more details.","keywords":"","subsectionKeywords":"","url":"/v3/running-apps#trigger-specific-options"},{"project":"v3","title":"Running Spin Applications","subheading":"Monitoring Applications for Changes","content":"Spin's watch command rebuilds and restarts Spin applications whenever files change. You can use the spin watch command in place of the spin build and spin up commands, to build, run and then keep your Spin application running without manual intervention while staying on the latest code and files.undefinedBy default, Spin watch monitors:undefinedundefinedundefinedundefinedIf any of these change, Spin will rebuild the application if necessary, then restart the application with the new files.undefinedThe following spin.toml configuration (belonging to a Spin http-rust application) is configured to ensure that the application is both undefined (via cargo build --target wasm32-wasip1 --release) and undefined whenever changes occur in any Rust source (.rs) files, the Cargo.toml file or the spin.toml file, itself. When changes occur in either the Wasm binary file (target/wasm32-wasip1/release/test.wasm) or the text file (my-files/changing-file.txt) the application is only undefined using the initial spin up command:[component.test]\n// -- snip\nfiles = [\"my-files/changing-file.txt\"]\nsource = \"target/wasm32-wasi/release/test.wasm\"\n[component.test.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\n# Example watch configuration for a Rust application\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]If the build section specifies a workdir, then watch patterns are relative to that directory. Otherwise, watch patterns are relative to the directory containing the spin.toml file.If you would prefer Spin watch to only rerun the application (without a rebuild) when changes occur, you can use the --skip-build option when running the spin watch command.  In this case, Spin will ignore the component.(id).build.watch section, and monitor only the spin.toml, component.source and component.files.The table below outlines exactly which files spin watch will monitor for changes depending on how you run the command. spin watch uses the configuration found on every component in your application.| Files                   | spin watch monitors for changes              | spin watch --skip-build monitors for changes |\n| ----------------------- | ---------------------------------------------- | ---------------------------------------------- |\n| Application manifest spin.toml   | Yes                                 | Yes                                            |\n| Component build.watch | Yes                                            | No                                             |\n| Component files       | Yes                                            | Yes                                            |\n| Component source      | No (Yes if the component has no build command) | YesSpin watch waits up to 100 milliseconds before responding to filesystem events, then processes all events that occurred in that interval together. This is so that if you make several changes close together (for example, using a Save All command), you get them all processed in one rebuild/reload cycle, rather than going through a cycle for each one. You can override the interval by passing in the --debounce option; e.g. spin watch --debounce 1000 will make Spin watch respond to filesystem events at most once per second.undefinedPassing the --clear flag clears the screen anytime a rebuild or rerun occurs. Spin watch does not clear the screen between rebuild and rerun as this provides you with an opportunity to see any warnings.For additional information about Spin's watch feature, please see the undefined blog article.undefined","keywords":"","subsectionKeywords":"","url":"/v3/running-apps#monitoring-applications-for-changes"},{"project":"v3","title":"Running Spin Applications","subheading":"Splitting an Application Across Environments","content":"You can run a subset of the components in an application by using the --component-id (-c) flag. Set the flag multiple times to select multiple components.undefinedThis supports undefined - that is, splitting an application across environments while still distributing it as a single unit. For example, suppose your application contains the following layers:undefinedundefinedundefinedYou could deploy the application across the environments by using --component-id. For example:# on the US data centre edge nodes\n$ spin up -f registry.example.com/app:1.1.0 -c ui -c api -c assets\n\n# on the European data centre edge nodes\n$ spin up -f registry.example.com/app:1.1.0 -c ui -c api -c assets \n\n# on the European data centre core nodes\n$ spin up -f registry.example.com/app:1.1.0 -c database\n\n# in the LLM environment\n$ spin up -f registry.example.com/app:1.1.0 -c chat-engine -c sentiment-analyzerundefinedIf you run a subset which includes a component that uses undefined, then you must also include all chaining targets in the subset - Spin checks this at load time. (Wildcard service chaining - the *.spin.internal host - means that undefined components are potential chaining targets, so you will not be able to use selective deployment if any component uses wildcard service chaining.) undefined will work only if the target route maps to a component in the subset, but this is not checked at load time - instead, self-requests to unselected components will fail at request time with 404 Not Found.","keywords":"","subsectionKeywords":"","url":"/v3/running-apps#splitting-an-application-across-environments"},{"project":"v3","title":"Running Spin Applications","subheading":"The Always Build Option","content":"Some people find it frustrating having to remember to build their applications before running spin up. If you want to undefined build your projects when you run them, set the SPIN_ALWAYS_BUILD environment variable in your profile or session. If this is set, spin up runs undefined before starting your applications.","keywords":"","subsectionKeywords":"","url":"/v3/running-apps#the-always-build-option"},{"project":"v3","title":"Running Spin Applications","subheading":"Next Steps","content":"undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/running-apps#next-steps"},{"project":"v3","title":"Building Spin components in Rust","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedSpin aims to have best-in-class support for building components in Rust, and\nwriting such components should be familiar for Rust developers.undefinedundefinedundefinedundefined","subsectionKeywords":"","url":"/v3/rust-components"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Prerequisites","content":"","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#prerequisites"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Install the Templates","content":"You don't need the Spin Rust templates to work on Rust components, but they speed up creating new applications and components.  You can install them as follows:$ spin templates install --git https://github.com/spinframework/spin --update\nCopying remote template source\nInstalling template redis-rust...\nInstalling template http-rust...\n... other templates omitted ...\n+------------------------------------------------------------------------+\n| Name                Description                                        |\n+========================================================================+\n| ... other templates omitted ...                                        |\n| http-rust           HTTP request handler using Rust                    |\n| redis-rust          Redis message handler using Rust                   |\n| ... other templates omitted ...                                        |\n+------------------------------------------------------------------------+Note: The Rust templates are in a repo that contains several other languages; they will all be installed together.","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#install-the-templates"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Install the Tools","content":"To build Spin components, you'll need the wasm32-wasip1 target for Rust.$ rustup target add wasm32-wasip1undefinedIf you don't have the target installed, then when you try to build a Spin component, you'll see an error similar to this:error[E0463]: can't find crate for `core`\n  |\n  = note: the `wasm32-wasip1` target may not be installed\n  = help: consider downloading the target with `rustup target add wasm32-wasip1`\n\nFor more information about this error, try `rustc --explain E0463`.Check that you have the WASI target installed by running rustup target list --installed, or follow the instructions in the message and run rustup target add wasm32-wasip1. This is the most common source of problems when starting out with Rust in Spin!undefined","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#install-the-tools"},{"project":"v3","title":"Building Spin components in Rust","subheading":"HTTP Components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, but Rust has improved support\nfor writing Spin components with the Spin Rust SDK.undefinedBuilding a Spin HTTP component using the Rust SDK means writing a single function decorated with the undefined attribute. The function can have one of two forms:undefinedundefineduse spin_sdk::http::{Request, Response, IntoResponse};\nuse spin_sdk::http_component;\n\n/// A simple Spin HTTP component.\n#[http_component]\nasync fn handle_hello_rust(_req: Request) -> anyhow::Result<impl IntoResponse> {\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, Fermyon\")\n        .build())\n}The important things to note in the implementation above:undefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#http-components"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Redis Components","content":"Besides the HTTP trigger, Spin has built-in support for a Redis trigger —\nwhich will connect to a Redis instance and will execute Spin components for\nnew messages on the configured channels.undefinedWriting a Redis component in Rust also takes advantage of the SDK:use anyhow::Result;\nuse bytes::Bytes;\nuse spin_sdk::redis_component;\n\n/// A simple Spin Redis component.\n#[redis_component]\nfn on_message(message: Bytes) -> Result<()> {\n    println!(\"{}\", std::str::from_utf8(&message)?);\n    Ok(())\n}undefinedundefinedundefinedThe component can be built with Cargo by executing:$ cargo build --target wasm32-wasip1 --releaseThe manifest for a Redis application must contain the address of the Redis\ninstance the trigger must connect to:spin_manifest_version = 2\nname = \"spin-redis\"\nversion = \"0.1.0\"\n\n[application.trigger.redis]\naddress = \"redis://localhost:6379\"\n\n[[trigger.redis]]\nchannel = \"messages\"\ncomponent = { source = \"target/wasm32-wasip1/release/spinredis.wasm\" }This application will connect to redis://localhost:6379, and for every new\nmessage on the messages channel, the echo-message component will be executed:# first, start redis-server on the default port 6379\n$ redis-server --port 6379\n# then, start the Spin application\n$ spin up --file spin.toml\n# the application log file will output the following\nINFO spin_redis_engine: Connecting to Redis server at redis://localhost:6379\nINFO spin_redis_engine: Subscribed component 0 (echo-message) to channel: messagesFor every new message on the  messages channel:$ redis-cli\n127.0.0.1:6379> publish messages \"Hello, there!\"Spin will instantiate and execute the component we just built, which will emit the println! message to the application log file:INFO spin_redis_engine: Received message on channel \"messages\"\nHello, there!undefined","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#redis-components"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Sending Outbound HTTP Requests","content":"If allowed, Spin components can send outbound HTTP requests.\nLet's see an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:use anyhow::Result;\nuse spin_sdk::{\n    http::{IntoResponse, Request, Method, Response},\n    http_component,\n};\n\n#[http_component]\nasync fn send_outbound(_req: Request) -> Result<impl IntoResponse> {\n    // Create the outbound request object\n    let req = Request::builder()\n        .method(Method::Get)\n        .uri(\"https://random-data-api.fermyon.app/animals/json\")\n        .build();\n\n    // Send the request and await the response\n    let res: Response = spin_sdk::http::send(req).await?;\n\n    println!(\"{:?}\", res);  // log the response\n    Ok(res)\n}undefinedBefore we can execute this component, we need to add the random-data-api.fermyon.app\ndomain to the component's allowed_outbound_hosts list in the application manifest. This contains the list of\ndomains the component is allowed to make network requests to:# spin.toml\nspin_manifest_version = 2\n\n[application]\nname = \"animal-facts\"\nversion = \"1.0.0\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"get-animal-fact\"\n\n[component.get-animal-fact]\nsource = \"get-animal-fact/target/wasm32-wasip1/release/get_animal_fact.wasm\"\nallowed_outbound_hosts = [\"https://random-data-api.fermyon.app\"]Running the application using spin up will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /outbound:$ curl -i localhost:3000\nHTTP/1.1 200 OK\ndate: Fri, 27 Oct 2023 03:54:36 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 185\nspin-component: get-animal-fact\n\n{\"timestamp\":1684299253331,\"fact\":\"Reindeer grow new antlers every year\"}   undefinedundefinedWe just built a WebAssembly component that sends an HTTP request to another\nservice, manipulates that result, then responds to the original request.\nThis can be the basis for building components that communicate with external\ndatabases or storage accounts, or even more specialized components like HTTP\nproxies or URL shorteners.undefined","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#sending-outbound-http-requests"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Routing in a Component","content":"The Rust SDK undefined that makes it easier to handle routing within a component:use anyhow::Result;\nuse spin_sdk::{\n    http::{IntoResponse, Params, Request, Response, Router},\n    http_component,\n};\n\n/// A Spin HTTP component that internally routes requests.\n#[http_component]\nfn handle_route(req: Request) -> Response {\n    let mut router = Router::new();\n    router.get(\"/goodbye/:planet\", api::goodbye_planet);\n    router.any_async(\"/*\", api::echo_wildcard);\n    router.handle(req)\n}\n\nmod api {\n    use super::*;\n\n    // /goodbye/:planet\n    pub fn goodbye_planet(_req: Request, params: Params) -> Result<impl IntoResponse> {\n        let planet = params.get(\"planet\").expect(\"PLANET\");\n        Ok(Response::new(200, planet.to_string()))\n    }\n\n    // /*\n    pub async fn echo_wildcard(_req: Request, params: Params) -> Result<impl IntoResponse> {\n        let capture = params.wildcard().unwrap_or_default();\n        Ok(Response::new(200, capture.to_string()))\n    }\n}Handlers within a Router can be sync or async. Use Router's \"plain\" methods (e.g. get, post) to assign synchronous handlers, and its \"async\" methods (e.g. get_async, post_async) for asynchronous handlers.  You can mix sync and async handlers in the same Router, and can use handle or handle_async to invoke Router processing, regardless of whether invididual handlers are sync or async.undefined","keywords":"","subsectionKeywords":"  async ","url":"/v3/rust-components#routing-in-a-component"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Storing Data in Redis From Rust Components","content":"Using the Spin's Rust SDK, you can use the Redis key/value store and to publish\nmessages to Redis channels. This can be used from both HTTP and Redis triggered\ncomponents.Let's see how we can use the Rust SDK to connect to Redis:use anyhow::Context;\nuse spin_sdk::{\n    http::{responses::internal_server_error, IntoResponse, Request, Response},\n    http_component,\n    redis::Connection,\n};\n\n// The environment variable set in `spin.toml` that points to the\n// address of the Redis server that the component will publish\n// a message to.\nconst REDIS_ADDRESS_ENV: &str = \"REDIS_ADDRESS\";\n\n// The environment variable set in `spin.toml` that specifies\n// the Redis channel that the component will publish to.\nconst REDIS_CHANNEL_ENV: &str = \"REDIS_CHANNEL\";\n\n/// This HTTP component demonstrates fetching a value from Redis\n/// by key, setting a key with a value, and publishing a message\n/// to a Redis channel. The component is triggered by an HTTP\n/// request served on the route configured in the `spin.toml`.\n#[http_component]\nfn publish(_req: Request) -> anyhow::Result<impl IntoResponse> {\n    let address = std::env::var(REDIS_ADDRESS_ENV)?;\n    let channel = std::env::var(REDIS_CHANNEL_ENV)?;\n\n    // Establish a connection to Redis\n    let conn = Connection::open(&address)?;\n\n    // Get the message to publish from the Redis key \"mykey\"\n    let payload = conn\n        .get(\"mykey\")\n        .context(\"Error querying Redis\")?\n        .context(\"'mykey' was unexpectedly empty\")?;\n\n    // Set the Redis key \"spin-example\" to value \"Eureka!\"\n    conn.set(\"spin-example\", &\"Eureka!\".to_owned().into_bytes())\n        .context(\"Error executing Redis set command\")?;\n\n    // Set the Redis key \"int-key\" to value 0\n    conn.set(\"int-key\", &format!(\"{:x}\", 0).into_bytes())\n        .context(\"Error executing Redis set command\")?;\n    let int_value = conn\n        .incr(\"int-key\")\n        .context(\"Error executing Redis incr command\")?;\n    assert_eq!(int_value, 1);\n\n    // Publish to Redis\n    match conn.publish(&channel, &payload) {\n        Ok(()) => Ok(Response::builder().status(200).build()),\n        Err(_e) => Ok(internal_server_error())\n    }\n}As with all networking APIs, you must grant access to Redis hosts via the allowed_outbound_hosts field in the application manifest:[component.redis-test]\nenvironment = { REDIS_ADDRESS = \"redis://127.0.0.1:6379\", REDIS_CHANNEL = \"messages\" }\n# Note this contains only the host and port - do not include the URL!\nallowed_outbound_hosts = [\"redis://127.0.0.1:6379\"]This HTTP component can be paired with a Redis component, triggered on new\nmessages on the messages Redis channel.undefined","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#storing-data-in-redis-from-rust-components"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Storing Data in the Spin Key-Value Store","content":"Spin has a key-value store built in. For information about using it from Rust, see undefined.","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#storing-data-in-the-spin-key-value-store"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Serializing Objects to the Key-Value Store","content":"The Spin key-value API stores and retrieves only lists of bytes. The Rust SDK provides helper functions that allow you to store and retrieve undefined serializable values in a typed way. The underlying storage format is JSON (and is accessed via the get_json and set_json helpers).To make your objects serializable, you will also need a reference to serde. The relevant Cargo.toml entries look like this:[dependencies]\n// --snip --\nserde = { version = \"1.0.163\", features = [\"derive\"] }\n// --snip --We configure our application to provision the default key_value_stores by adding the following line to our application's manifest (the spin.toml file), at the component level:[component.redis-test]\nkey_value_stores = [\"default\"]The Rust code below shows how to store and retrieve serializable objects from the key-value store (note how the example below implements Serde's derive feature):use anyhow::Context;\nuse serde::{Deserialize, Serialize};\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n    key_value::Store,\n};\n\n// Define a serializable User type\n#[derive(Serialize, Deserialize)]\nstruct User {\n    fingerprint: String,\n    location: String,\n}\n\n#[http_component]\nfn handle_request(_req: Request) -> anyhow::Result<Response> {\n    // Open the default key-value store\n    let store = Store::open_default()?;\n\n    // Create an instance of a User object and populate the values\n    let user = User {\n        fingerprint: \"0x1234\".to_owned(),\n        location: \"Brisbane\".to_owned(),\n    };\n    // Store the User object using the \"my_json\" key\n    store.set_json(\"my_json\", &user)?;\n    // Retrieve the user object from the key-value store, using the \"my_json\" key\n    let retrieved_user: User = store.get_json(\"my_json\")?.context(\"user not found\")?;\n    // Return the user's fingerprint as the response body\n    Ok(Response::builder()\n        .status(200)\n        .body(retrieved_user.fingerprint)\n        .build())\n}undefinedOnce built and running (using spin build and spin up) you can test the above example in your browser (by visiting localhost:3000) or via curl, as shown below:$ curl localhost:3000\nHTTP/1.1 200 OK\n\n0x1234For more information on the Rust key-value API see undefined.","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#serializing-objects-to-the-key-value-store"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Storing Data in SQLite","content":"For more information about using SQLite from Rust, see undefined.","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#storing-data-in-sqlite"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Storing Data in Relational Databases","content":"Spin provides clients for MySQL and PostgreSQL. For information about using them from Rust, see undefined.","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#storing-data-in-relational-databases"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Using External Crates in Rust Components","content":"In Rust, Spin components are regular libraries that contain a function\nannotated using the http_component macro, compiled to the wasm32-wasip1 target.\nThis means that any undefined that compiles to wasm32-wasip1 can\nbe used when implementing the component.","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#using-external-crates-in-rust-components"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Using the  http  crate","content":"If you're already familiar with the popular undefined, you may wish to use that instead of using the HTTP types included in the Spin SDK. Generally, the http crate's types can be used anywhere the Spin SDK HTTP types can be used. For example, the first basic HTTP component can be rewritten to use the http crate like so:use http::{Request, Response};\nuse spin_sdk::http::IntoResponse;\nuse spin_sdk::http_component;\n\n/// A simple Spin HTTP component.\n#[http_component]\nasync fn handle_hello_rust(_req: Request<()>) -> anyhow::Result<impl IntoResponse> {\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, Fermyon\")?)\n}Of course, you'll need to remember to add the http crate to your Cargo.toml:[dependencies]\n// --snip --\nhttp = \"0.2.9\"\n// --snip --","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#using-the-http-crate"},{"project":"v3","title":"Building Spin components in Rust","subheading":"AI Inferencing From Rust Components","content":"For more information about using Serverless AI from Rust, see the undefined API guide.","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#ai-inferencing-from-rust-components"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Troubleshooting","content":"If you bump into issues building and running your Rust component, here are some common causes of problems:undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#troubleshooting"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Manually Creating New Projects With Cargo","content":"The recommended way of creating new Spin projects is by starting from a template.\nThis section shows how to manually create a new project with Cargo.When creating a new Spin project with Cargo, you should use the --lib flag:$ cargo init --libA Cargo.toml with standard Spin dependencies looks like this:[package]\nname = \"your-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\n# Required to have a `cdylib` (dynamic library) to produce a Wasm module.\ncrate-type = [ \"cdylib\" ]\n\n[dependencies]\n# Useful crate to handle errors.\nanyhow = \"1\"\n# The Spin SDK.\nspin-sdk = { git = \"https://github.com/spinframework/spin\" }","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#manually-creating-new-projects-with-cargo"},{"project":"v3","title":"Building Spin components in Rust","subheading":"Read the Rust Spin SDK Documentation","content":"Although you learned a lot by following the concepts and samples shown here, you can dive even deeper and read the undefined.","keywords":"","subsectionKeywords":"","url":"/v3/rust-components#read-the-rust-spin-sdk-documentation"},{"project":"v3","title":"Built With Spin","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedSpin can be used to build many different types of applications. The following blog articles show how different applications are built with Spin.","subsectionKeywords":"","url":"/v3/see-what-people-have-built-with-spin"},{"project":"v3","title":"Built With Spin","subheading":"AI-powered bookmarking app with Python and WebAssembly","content":"undefined.","keywords":"","subsectionKeywords":"","url":"/v3/see-what-people-have-built-with-spin#ai-powered-bookmarking-app-with-python-and-webassembly"},{"project":"v3","title":"Built With Spin","subheading":"Like Button","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v3/see-what-people-have-built-with-spin#like-button"},{"project":"v3","title":"Built With Spin","subheading":"Social App","content":"The 'Building a Social App with Spin' series covers the process and decision-making of building an authenticated, dynamic, database-backed application and API, right the way from downloading Spin and setting up the project to deploying the finished application to the cloud.undefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/see-what-people-have-built-with-spin#social-app"},{"project":"v3","title":"Built With Spin","subheading":"Static Content Server","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v3/see-what-people-have-built-with-spin#static-content-server"},{"project":"v3","title":"Built With Spin","subheading":"Bots","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v3/see-what-people-have-built-with-spin#bots"},{"project":"v3","title":"Built With Spin","subheading":"URL Shortener and QR Code Generator","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v3/see-what-people-have-built-with-spin#url-shortener-and-qr-code-generator"},{"project":"v3","title":"Built With Spin","subheading":"Content Management System (CMS)","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v3/see-what-people-have-built-with-spin#content-management-system-cms"},{"project":"v3","title":"Built With Spin","subheading":"The Finicky Whiskers Game","content":"The 'Finicky Whiskers' series covers the journey of creating a game with an architecture designed to undefined and showcase how WebAssembly modules can be started, executed, and shut down in the blink of an eye.undefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/see-what-people-have-built-with-spin#the-finicky-whiskers-game"},{"project":"v3","title":"Built With Spin","subheading":"Accessing External APIs","content":"Chances are whatever you are building will want to talk to other endpoints on the web. If so, Spin's HTTP library can help. The following article explains how to access external APIs from within Spin applications.undefined","keywords":"","subsectionKeywords":"","url":"/v3/see-what-people-have-built-with-spin#accessing-external-apis"},{"project":"v3","title":"Built With Spin","subheading":"SQLite Storage Using Javascript","content":"Check out our undefined blog article that provides an SQLite database example (using Javascript).","keywords":"","subsectionKeywords":"","url":"/v3/see-what-people-have-built-with-spin#sqlite-storage-using-javascript"},{"project":"v3","title":"Built With Spin","subheading":"Next Steps","content":"undefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/see-what-people-have-built-with-spin#next-steps"},{"project":"v3","title":"Serverless AI API","subheading":"","content":"undefinedundefinedundefinedThe nature of AI and LLM workloads on already trained models lends itself very naturally to a serverless-style architecture. As a framework for building and deploying serverless applications, Spin provides an interface for you to perform AI inference within Spin applications.","subsectionKeywords":"","url":"/v3/serverless-ai-api-guide"},{"project":"v3","title":"Serverless AI API","subheading":"Using Serverless AI From Applications","content":"","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-api-guide#using-serverless-ai-from-applications"},{"project":"v3","title":"Serverless AI API","subheading":"Configuration","content":"By default, a given component of a Spin application will not have access to any Serverless AI models. Access must be provided explicitly via the Spin application's manifest (the spin.toml file).  For example, an individual component in a Spin application could be given access to the llama2-chat model by adding the following ai_models configuration inside the specific [component.(name)] section:// -- snip --\n\n[component.please-send-the-codes]\nai_models = [\"codellama-instruct\"]\n\n// -- snip --undefined","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-api-guide#configuration"},{"project":"v3","title":"Serverless AI API","subheading":"File Structure","content":"By default, the Spin framework will expect any already trained model files (which are configured as per the previous section) to be downloaded by the user and made available inside a .spin/ai-models/ file path of a given application.\nWithin the .spin/ai-models directory, models of the same architecture (e.g. llama) must be grouped under a directory with the same name as the architecture.\nWithin an architecture directory, each individual model (e.g. llama2-chat, codellama-instruct) must be placed under a folder with the same name as the model.  So for any given model, that files for the model are placed in the directory .spin/ai-models/<architecture>/<model>.  For example:code-generator-rs/.spin/ai-models/llama/codellama-instruct/safetensors\ncode-generator-rs/.spin/ai-models/llama/codellama-instruct/config.json\ncode-generator-rs/.spin/ai-models/llama/codellama-instruct/tokenizer.jsonSee the undefined documentation for more concrete examples of implementing the Fermyon Serverless AI API, in your favorite language.undefined","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-api-guide#file-structure"},{"project":"v3","title":"Serverless AI API","subheading":"Serverless AI Interface","content":"The Spin SDK surfaces the Serverless AI interface to a variety of different languages. See the undefined to see if your specific language is supported.The set of operations is common across all supporting language SDKs:| Operation | Parameters | Returns | Behavior |\n|:-----|:----------------|:-------|:----------------|\n| infer               | modelstring<br /> promptstring                    | string | The infer is performed on a specific model.<br /> <br />The name of the model is the first parameter provided (i.e. llama2-chat, codellama-instruct, or other; passed in as a string).<br /> <br />The second parameter is a prompt; passed in as a string.<br />                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n| infer_with_options  | modelstring<br /> promptstring<br /> paramslist | string | The infer_with_options is performed on a specific model.<br /> <br />The name of the model is the first parameter provided (i.e. llama2-chat, codellama-instruct, or other; passed in as a string).<br /><br /> The second parameter is a prompt; passed in as a string.<br /><br /> The third parameter is a mix of float and unsigned integers relating to inferencing parameters in this order: <br /><br />- max-tokens (unsigned 32 integer) Note: the backing implementation may return less tokens. <br /> Default is 100<br /><br /> - repeat-penalty (float 32) The amount the model should avoid repeating tokens. <br /> Default is 1.1<br /><br /> - repeat-penalty-last-n-token-count (unsigned 32 integer) The number of tokens the model should apply the repeat penalty to. <br /> Default is 64<br /><br /> - temperature (float 32) The randomness with which the next token is selected. <br /> Default is 0.8<br /><br /> - top-k (unsigned 32 integer) The number of possible next tokens the model will choose from. <br /> Default is 40<br /><br /> - top-p (float 32) The probability total of next tokens the model will choose from. <br /> Default is 0.9<br /><br /> The result from infer_with_options is a string |\n| generate-embeddings | modelstring<br /> promptlist<string>              | string | The generate-embeddings is performed on a specific model.<br /> <br />The name of the model is the first parameter provided (i.e. all-minilm-l6-v2, passed in as a string).<br /> <br />The second parameter is a prompt; passed in as a list of strings.<br /><br /> The result from generate-embeddings is a two-dimension array containing float32 type values only                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedTo use Serverless AI functions, the llm module from the Spin SDK provides the methods. The following snippet is from the undefined:use spin_sdk::{\n    http::{IntoResponse, Request, Response},\n    llm,\n};\n\n// -- snip --\n\nfn handle_code(req: Request) -> anyhow::Result<impl IntoResponse> {\n    // -- snip --\n\n    let result = llm::infer_with_options(\n        llm::InferencingModel::CodellamaInstruct,\n        &prompt,\n        llm::InferencingParams {\n            max_tokens: 400,\n            repeat_penalty: 1.1,\n            repeat_penalty_last_n_token_count: 64,\n            temperature: 0.8,\n            top_k: 40,\n            top_p: 0.9,\n        },\n    )?;\n\n    // -- snip --\t\n}\nundefinedThe infer_with_options examples, operation:undefinedundefinedundefinedundefined{{ blockEnd }}{{ startTab \"Typescript\"}}undefinedTo use Serverless AI functions, undefined from the Spin SDK provides two methods: infer and generateEmbeddings. For example:import { AutoRouter } from 'itty-router';\nimport { Llm } from '@fermyon/spin-sdk';\n\nlet router = AutoRouter();\n\nrouter\n    .get(\"/\", () => {\n       let embeddings = Llm.generateEmbeddings(Llm.EmbeddingModels.AllMiniLmL6V2, [\"someString\"])\n        console.log(embeddings.embeddings)\n        let result = Llm.infer(Llm.InferencingModels.Llama2Chat, prompt)\n\n        return new Response(result.text);\n    })\n\n//@ts-ignore\naddEventListener('fetch', async (event: FetchEvent) => {\n    event.respondWith(router.fetch(event.request));\n});undefinedinfer operation:undefinedundefinedundefinedundefinedgenerateEmbeddings operation:undefinedundefinedundefined{{ blockEnd }}{{ startTab \"Python\"}}undefinedfrom spin_sdk import http\nfrom spin_sdk.http import Request, Response\nfrom spin_sdk import llm\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        prompt=\"You are a stand up comedy writer. Tell me a joke.\"\n        result = llm.infer(\"llama2-chat\", prompt)\n        return Response(200,\n                        {\"content-type\": \"application/json\"},\n                        bytes(result.text, \"utf-8\"))undefinedundefined:undefinedundefined{{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedServerless AI functions are available in the github.com/fermyon/spin/sdk/go/v2/llm package. See undefined for reference documentation. For example:package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\tspinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n\t\"github.com/fermyon/spin/sdk/go/v2/llm\"\n)\n\nfunc init() {\n\tspinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n\t\tresult, err := llm.Infer(\"llama2-chat\", \"What is a good prompt?\", nil)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Prompt tokens:    %d\\n\", result.Usage.PromptTokenCount)\n\t\tfmt.Printf(\"Generated tokens: %d\\n\", result.Usage.GeneratedTokenCount)\n\t\tfmt.Fprintf(w, \"%s\\n\", result.Text)\n\n\t\tembeddings, err := llm.GenerateEmbeddings(\"all-minilm-l6-v2\", []string{\"Hello world\"})\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Prompt Tokens: %d\\n\", embeddings.Usage.PromptTokenCount)\n\t\tfmt.Printf(\"%v\\n\", embeddings.Embeddings)\n\t})\n}undefinedinfer operation:undefinedundefinedundefinedundefinedgenerateEmbeddings operation:undefinedundefinedundefined{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-api-guide#serverless-ai-interface"},{"project":"v3","title":"Serverless AI API","subheading":"Troubleshooting","content":"","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-api-guide#troubleshooting"},{"project":"v3","title":"Serverless AI API","subheading":"Error \"Local LLM operations are not supported in this version of Spin\"","content":"If you see \"Local LLM operations are not supported in this version of Spin\", then your copy of Spin has been built without local LLM support.undefinedMost Spin builds support local LLMs as described above. However, the models built into Spin do not build on some combinations of platforms (for example, there are known problems with the aarch64/musl combination). This may cause some environments that embed Spin to disable the local LLM feature altogether. (For examples, some versions of the containerd-spin-shim did this.) In such cases, you will see the error above.In such cases, you can:undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-api-guide#error-local-llm-operations-are-not-supported-in-this-version-of-spin"},{"project":"v3","title":"Build your first AI app using Serverless AI Inferencing","subheading":"","content":"undefinedundefinedundefinedundefinedThis tutorial will show you how to use Fermyon Serverless AI to quickly build your first AI-enabled serverless application that can run on Fermyon Cloud.\nIn this tutorial we will:undefinedundefinedundefinedHere's a video walkthrough of this tutorial","subsectionKeywords":"","url":"/v3/serverless-ai-hello-world"},{"project":"v3","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Tutorial Prerequisites","content":"","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-hello-world#tutorial-prerequisites"},{"project":"v3","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Spin","content":"You will need to undefined. Serverless AI is supported on Spin v1.5 and above\nIf you already have Spin installed, undefined if required.","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-hello-world#spin"},{"project":"v3","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Dependencies","content":"undefined\nThe above installation script automatically installs the latest SDKs for Rust, which enables Serverless AI functionality.undefinedTo enable Serverless AI functionality via TypeScript/Javascript, please ensure you have the latest TypeScript/JavaScript template installed:$ spin templates install --git https://github.com/spinframework/spin-js-sdk --upgradeundefinedEnsure that you have Python 3.10 or later installed on your system. You can check your Python version by running:python3 --versionIf you do not have Python 3.10 or later, you can install it by following the instructions undefined.To enable Serverless AI functionality via Python, please ensure you have the latest Python template installed:$ spin templates install --git https://github.com/spinframework/spin-python-sdk --updateAs a standard practice for Python, create and activate a virtual env:If you are on a Mac/linux based operating system use the following commands:$ python3 -m venv venv\n$ source venv/bin/activateIf you are using Windows, use the following commands:C:\\Work> python3 -m venv venv\nC:\\Work> venv\\Scripts\\activate","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-hello-world#dependencies"},{"project":"v3","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Licenses","content":"undefined","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-hello-world#licenses"},{"project":"v3","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Serverless AI Inferencing With Spin","content":"Now, let's write your first Serverless AI application with Spin.","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-hello-world#serverless-ai-inferencing-with-spin"},{"project":"v3","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Creating a New Spin Application","content":"{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}The Rust code snippets below are taken from the undefined.$ spin new -t http-rust\nEnter a name for your new application: hello-world\nDescription: My first Serverless AI app\nHTTP path: /...{{ blockEnd }}{{ startTab \"Python\" }}The Python code snippets below are taken from the undefined.# Create new app\n$ spin new -t http-py hello-world --accept-defaults\n# Change into app directory\n$ cd hello-world\nEnter a name for your new application: hello-world\nDescription: My first Serverless AI app\nHTTP path: /...Create a virtual environment directory (we are still inside the Spin app directory):# python<version> -m venv <virtual-environment-name>\n$ python3 -m venv venv-dirActivate the virtual environment (this command depends on which operating system you are using):# macOS command to activate\n$ source venv-dir/bin/activateThe (venv-dir) will prefix your terminal prompt now:(venv-dir) user@123-456-7-8 hello-world %The requirements.txt, by default, contains the references to the spin-sdk and componentize-py packages. These can be installed in your virtual environment using the following command:$ pip3 install -r requirements.txt {{ blockEnd }}{{ startTab \"TypeScript\" }}The TypeScript code snippets below are taken from the undefined.$ spin new -t http-ts\nEnter a name for your new application: hello-world\nDescription: My first Serverless AI app\nHTTP path: /...{{ blockEnd }}\n{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-hello-world#creating-a-new-spin-application"},{"project":"v3","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Configuring Your Application","content":"The spin.toml file is the manifest file which tells Spin what events should trigger what components. Configure the [component.hello-world] section of our application's manifest explicitly naming our model of choice. For this example, we specify the llama2-chat value for our ai_models configuration:ai_models = [\"llama2-chat\"]This is what your spin.toml file should look like, based on whether you’re using Rust, TypeScript or Python:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}spin_manifest_version = 2\n\n[application]\nname = \"hello-world\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first Serverless AI app\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nsource = \"target/wasm32-wasip1/release/hello_world.wasm\"\nallowed_outbound_hosts = []\nai_models = [\"llama2-chat\"]\n[component.hello-world.build]\ncommand = \"cargo build --target wasm32-wasip1 --release\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]{{ blockEnd }}{{ startTab \"TypeScript\" }}spin_manifest_version = 2\n\n[application]\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"My first Serverless AI app\"\nname = \"hello-world\"\nversion = \"0.1.0\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nsource = \"target/hello-world.wasm\"\nexclude_files = [\"**/node_modules\"]\nai_models = [\"llama2-chat\"]\n[component.hello-world.build]\ncommand = \"npm run build\"{{ blockEnd }}{{ startTab \"Python\" }}spin_manifest_version = 2\n\n[application]\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"\"\nname = \"hello-world\"\nversion = \"0.1.0\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"hello-world\"\n\n[component.hello-world]\nsource = \"app.wasm\"\nai_models = [\"llama2-chat\"]\n[component.hello-world.build]\ncommand = \"componentize-py -w spin-http componentize app -o app.wasm\"\nwatch = [\"*.py\", \"requirements.txt\"]{{ blockEnd }}\n{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-hello-world#configuring-your-application"},{"project":"v3","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Source Code","content":"Now let's use the Spin SDK to access the model from our app. Executing inference from a LLM is a single line of code. Add the Llm and the InferencingModels to your app and use the Llm.infer to execute an inference. Here’s how the code looks:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}use spin_sdk::{http::{IntoResponse, Request, Response}, http_component, llm};\n\n#[http_component]\nfn hello_world(_req: Request) -> anyhow::Result<impl IntoResponse> {\n   let model = llm::InferencingModel::Llama2Chat;\n   let inference = llm::infer(model, \"Can you tell me a joke about cats\");\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(format!(\"{:?}\", inference))\n        .build())\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}\nimport { AutoRouter } from 'itty-router';\nimport { Llm } from '@fermyon/spin-sdk';\n\nconst  model = InferencingModels.Llama2Chat\n\nlet router = AutoRouter();\n\nrouter\n    .get(\"/\", () => {\n        const out = Llm.infer(model, prompt)\n\n        return new Response(out.text);\n    })\n\n//@ts-ignore\naddEventListener('fetch', async (event: FetchEvent) => {\n    event.respondWith(router.fetch(event.request));\n});\n{{ blockEnd }}{{ startTab \"Python\"}}from spin_sdk import http\nfrom spin_sdk.http import Request, Response\nfrom spin_sdk import llm\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        res = llm.infer_with_options(\"llama2-chat\", \"Can you tell me a joke about cats?\", llm.LLMInferencingParams(temperature=0.5))\n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(res.text, \"utf-8\")\n        )\n\n{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-hello-world#source-code"},{"project":"v3","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Building and Deploying Your Spin Application","content":"Now that you have written your first Serverless AI app, it’s time to build and deploy it. To build your app run the following commands from inside your app’s folder (where the spin.toml file is located):{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}$ spin build{{ blockEnd }}{{ startTab \"TypeScript\" }}\n$ npm install\n$ spin build\n{{ blockEnd }}\n{{ startTab \"Python\" }}$ spin build{{ blockEnd }}Now that your app is built, there are three ways to test your Serverless AI app. One way to test the app is to run inferencing locally. This means running a LLM on your CPU. This is not as optimal compared to deploying to Fermyon’s Serverless AI, which uses high-powered GPUs in the cloud. To know more about this method, including downloading LLMs to your local machine, check out undefined on Building a Sentiment Analysis API using Serverless AI.Here are the two other methods for testing your app:undefinedYou can deploy the app to the cloud by using the spin deploy command. In case you have not logged into your account before deploying your application, you need to grant access via a one-time token. Follow the instructions in the prompt to complete the auth process.Once you have logged in and the app is deployed, you will see a URL, upon successful deployment. The app is now deployed and can be accessed by anyone with the URL:$ spin deploy\n\n>Uploading hello-world version 0.1.0+ra01f74e2...\nDeploying...\nWaiting for application to become ready...... ready\nAvailable Routes:\nhello-world: https://hello-world-XXXXXX.fermyon.app (wildcard)The app’s manifest file reads the line ai_models = [\"llama2-chat\"] and uses that model in the cloud. For any changes to take effect in the app, it needs to be re-deployed to the cloud.undefinedTo avoid having to deploy the app for every change, you can use the undefined to deploy locally, with the LLM running in the cloud. While the app is hosted locally (running on localhost), every inferencing request is sent to the LLM that is running in the cloud. Follow the steps to use the cloud-gpu plugin.undefined: This plugin works only with spin v1.5.1 and above.First, install the plugin using the command:$ spin plugins install -u https://github.com/spinframework/spin-cloud-gpu/releases/download/canary/cloud-gpu.json -yLet’s initialize the plugin. This command essentially deploys the Spin app to a Cloud GPU proxy and generates a runtime-config:$ spin cloud-gpu init\n\n[llm_compute]\ntype = \"remote_http\"\nurl = \"https://fermyon-cloud-gpu-<AUTO_GENERATED_STRING>.fermyon.app\"\nauth_token = \"<AUTO_GENERATED_TOKEN>\"In the root of your Spin app directory, create a file named runtime-config.toml and paste the runtime-config generated in the previous step.Now you are ready to test the Serverless AI app locally, using a GPU that is running in the cloud. To deploy the app locally you can use spin up (or spin watch) but with the following flag:$ spin up --runtime-config-file <path/to/runtime-config.toml>\n\nLogging component stdio to  \".spin/logs/\"\nServing http://127.0.0.1:3000\nAvailable Routes:\nhello-world: http://127.0.0.1:3000 (wildcard)","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-hello-world#building-and-deploying-your-spin-application"},{"project":"v3","title":"Build your first AI app using Serverless AI Inferencing","subheading":"Next Steps","content":"This was just a small example of what Serverless AI Inferencing can do. To check out more detailed code samples:undefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/serverless-ai-hello-world#next-steps"},{"project":"v3","title":"Application Structure","subheading":"","content":"A Spin application can contain multiple components. If more than one component is built from source, you should consider how to organise the application project.undefinedThe discussion on this page assumes that you know from the start that you are going to need to build multiple components. If you've already started a project, you may need to move some existing code around when you add your second built-from-source component. For information about this, see undefined or undefined.undefined","keywords":"structure","subsectionKeywords":"","url":"/v3/spin-application-structure"},{"project":"v3","title":"Application Structure","subheading":"Recommended Application Structure","content":"If we start with a blank canvas and use the http-empty template we will get a new Spin application:$ spin new -t http-empty\nEnter a name for your new application: myapp\nDescription: My applicationThe above command will provide an empty structure, as shown below:└── myapp\n    └── spin.tomlTo add new components to the application, we simply move into the myapp directory and begin to add components using the spin add subcommand:$ spin add -t http-rust\nEnter a name for your new component: first-http-rust-component\nDescription: The first of many new components\nHTTP path: /first/...\n$ spin add -t http-rust\nEnter a name for your new component: second-http-rust-component\nDescription: The second of many new components\nHTTP path: /second/...After adding two new components, we can see the visual representation of our application. Notice the symmetry; there is no hierarchy or nesting of components:.\n├── first-http-rust-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n├── second-http-rust-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.tomlTo customize each of the two components, we can modify the lib.rs (Rust source code) of each component:use spin_sdk::http::{IntoResponse, Request, Response};\nuse spin_sdk::http_component;\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn handle_first_http_rust_component(req: Request) -> anyhow::Result<impl IntoResponse> {\n    println!(\"Handling request to {:?}\", req.header(\"spin-full-url\"));\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, First Component\")\n        .build())\n}#[http_component]\nfn handle_second_http_rust_component(req: Request) -> anyhow::Result<impl IntoResponse> {\n    println!(\"Handling request to {:?}\", req.header(\"spin-full-url\"));\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, Second Component\")\n        .build())\n}As an additional example of adding more components, let's add a new static file server component:$ spin add -t static-fileserver\nEnter a name for your new component: assets\nHTTP path: /static/...\nDirectory containing the files to serve: assetsAfter the static file server component is added, we create the assets directory (our local directory containing the files to serve) and then add some static content into the assets directory to be served:$ mkdir assets\n$ cp ~/Desktop/my-static-image.jpg assets\n$ cp ~/Desktop/old.txt assets\n$ cp ~/Desktop/new.txt assetsundefinedWhy stop there? We can add even more functionality to our application. Let's now add a redirect component to redirect requests made to /static/old.txt and forward those through to /static/new.txt:$ spin add -t redirect\nEnter a name for your new component: additional-component-redirect\nRedirect from: /static/old.txt\nRedirect to: /static/new.txtWe now have 4 separate components scaffolded for us by Spin. Note the application manifest (the spin.toml file) is correctly configured based on our spin add commands:spin_manifest_version = 2\n\n[application]\nname = \"myapp\"\nversion = \"0.1.0\"\n\n[[trigger.http]]\nroute = \"/first/...\"\ncomponent = \"first-http-rust-component\"\n\n[component.first-http-rust-component]\nsource = \"first-http-rust-component/target/wasm32-wasip1/release/first_http_rust_component.wasm\"\nallowed_outbound_hosts = []\n[component.first-http-rust-component.build]\ncommand = \"cargo build --target wasm32-wasip1 --release\"\nworkdir = \"first-http-rust-component\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]\n\n[[trigger.http]]\nroute = \"/second/...\"\ncomponent = \"second-http-rust-component\"\n\n[component.second-http-rust-component]\nsource = \"second-http-rust-component/target/wasm32-wasip1/release/second_http_rust_component.wasm\"\nallowed_outbound_hosts = []\n[component.second-http-rust-component.build]\ncommand = \"cargo build --target wasm32-wasip1 --release\"\nworkdir = \"second-http-rust-component\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]\n\n[[trigger.http]]\nroute = \"/static/...\"\ncomponent = \"assets\"\n\n[component.assets]\nsource = { url = \"https://github.com/spinframework/spin-fileserver/releases/download/v0.1.0/spin_static_fs.wasm\", digest = \"sha256:96c76d9af86420b39eb6cd7be5550e3cb5d4cc4de572ce0fd1f6a29471536cb4\" }\nfiles = [ { source = \"assets\", destination = \"/\" } ]\n\n[[trigger.http]]\ncomponent = \"additional-component-redirect\"\nroute = \"/static/old.txt\"\n\n[component.additional-component-redirect]\nsource = { url = \"https://github.com/spinframework/spin-redirect/releases/download/v0.1.0/redirect.wasm\", digest = \"sha256:8bee959843f28fef2a02164f5840477db81d350877e1c22cb524f41363468e52\" }\nenvironment = { DESTINATION = \"/static/new.txt\" }Also, note that the application's folder structure, scaffolded for us by Spin via the spin add commands, is symmetrical and shows no nesting of components:├── assets\n│   ├── my-static-image.jpg\n│   ├── new.txt\n│   └── old.txt\n├── first-http-rust-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n├── second-http-rust-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.tomlThis is the recommended Spin application structure.","keywords":"","subsectionKeywords":"","url":"/v3/spin-application-structure#recommended-application-structure"},{"project":"v3","title":"Application Structure","subheading":"Next Steps","content":"undefinedundefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/spin-application-structure#next-steps"},{"project":"v3","title":"SQLite Storage","subheading":"","content":"undefinedundefinedundefinedundefinedSpin provides an interface for you to persist data in an SQLite Database managed by Spin. This database allows Spin developers to persist relational data across application invocations.{{ details \"Why do I need a Spin interface? Why can't I just use my own external database?\" \"You can absolutely still use your own external database either with the undefined. However, if you're interested in quick, local relational storage without any infrastructure set-up then Spin's SQLite Database is a great option.\" }}","subsectionKeywords":"","url":"/v3/sqlite-api-guide"},{"project":"v3","title":"SQLite Storage","subheading":"Granting SQLite Database Permissions to Components","content":"By default, a given component of an app will not have access to any SQLite Databases. Access must be granted specifically to each component via the component manifest.  For example, a component could be given access to the default store using:[component.example]\nsqlite_databases = [\"default\"]undefined","keywords":"","subsectionKeywords":"","url":"/v3/sqlite-api-guide#granting-sqlite-database-permissions-to-components"},{"project":"v3","title":"SQLite Storage","subheading":"Using SQLite Storage From Applications","content":"The Spin SDK surfaces the Spin SQLite Database interface to your language.The set of operations is common across all SDKs:| Operation  | Parameters | Returns | Behavior |\n|------------|------------|---------|----------|\n| open  | name | connection  | Open the database with the specified name. If name is the string \"default\", the default database is opened, provided that the component that was granted access in the component manifest from spin.toml. Otherwise, name must refer to a store defined and configured in a undefined supplied with the application.|\n| execute | connection, sql, parameters | database records | Executes the SQL statement and returns the results of the statement. SELECT statements typically return records or scalars. INSERT, UPDATE, and DELETE statements typically return empty result sets, but may return values in some cases. The execute operation recognizes the undefined. |\n| close | connection | - | Close the specified connection. |The exact detail of calling these operations from your application depends on your language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}Please note, we use serde in this Rust example, so please add serde as a dependency in your application's Cargo.toml file:[dependencies]\nserde = {version = \"1.0\", features = [\"derive\"]}\nserde_json = \"1.0\"undefinedSQLite functions are available in the spin_sdk::sqlite module. The function names match the operations above. For example:use anyhow::Result;\nuse serde::Serialize;\nuse spin_sdk::{\n    http::{Request, Response, IntoResponse},\n    http_component,\n    sqlite::{Connection, Value},\n};\n\n#[http_component]\nfn handle_request(req: Request) -> Result<impl IntoResponse> {\n    let connection = Connection::open_default()?;\n\n    let execute_params = [\n        Value::Text(\"Try out Spin SQLite\".to_owned()),\n        Value::Text(\"Friday\".to_owned()),\n    ];\n    connection.execute(\n        \"INSERT INTO todos (description, due) VALUES (?, ?)\",\n        execute_params.as_slice(),\n    )?;\n\n    let rowset = connection.execute(\n        \"SELECT id, description, due FROM todos\",\n        &[]\n    )?;\n\n    let todos: Vec<_> = rowset.rows().map(|row|\n        ToDo {\n            id: row.get::<u32>(\"id\").unwrap(),\n            description: row.get::<&str>(\"description\").unwrap().to_owned(),\n            due: row.get::<&str>(\"due\").unwrap().to_owned(),\n        }\n    ).collect();\n\n    let body = serde_json::to_vec(&todos)?;\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(body)\n        .build())\n}\n\n// Helper for returning the query results as JSON\n#[derive(Serialize)]\nstruct ToDo {\n    id: u32,\n    description: String,\n    due: String,\n}undefinedundefinedundefinedundefinedundefinedundefined{{ blockEnd }}{{ startTab \"Typescript\"}}undefinedTo use SQLite functions, use undefined to obtain undefined. SqliteConnection provides the execute method as described above. For example:import { AutoRouter } from 'itty-router';\nimport { Sqlite } from '@fermyon/spin-sdk';\n\nlet router = AutoRouter();\nrouter\n    .get(\"/\", () => {\n        let conn = Sqlite.openDefault();\n        let result = conn.execute(\"SELECT * FROM todos WHERE id > (?);\", [1]);\n\n        return new Response(JSON.stringify(result, null, 2));\n    })\n\n//@ts-ignore\naddEventListener('fetch', async (event: FetchEvent) => {\n    event.respondWith(router.fetch(event.request));\n});\nundefinedundefinedundefined{{ blockEnd }}{{ startTab \"Python\"}}undefinedTo use SQLite functions, use the sqlite module in the Python SDK. The undefined and undefined functions return a undefined. The connection object provides the undefined as described above. For example:from spin_sdk import http, sqlite\nfrom spin_sdk.http import Request, Response\nfrom spin_sdk.sqlite import ValueInteger\n\nclass IncomingHandler(http.IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        with sqlite.open_default() as db:\n            result = db.execute(\"SELECT * FROM todos WHERE id > (?);\", [ValueInteger(1)])\n            rows = result.rows\n        \n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(str(rows), \"utf-8\")\n        )undefinedundefinedundefinedundefined{{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedThe Go SDK is implemented as a driver for the standard library's undefined interface.package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\tspinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n\t\"github.com/fermyon/spin/sdk/go/v2/sqlite\"\n)\n\ntype Todo struct {\n\tID          string\n\tDescription string\n\tDue         string\n}\n\nfunc init() {\n\tspinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n\t\tdb := sqlite.Open(\"default\")\n\t\tdefer db.Close()\n\n\t\t_, err := db.Exec(\"INSERT INTO todos (description, due) VALUES (?, ?)\", \"Try out Spin SQLite\", \"Friday\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\trows, err := db.Query(\"SELECT id, description, due FROM todos\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tvar todos []*Todo\n\t\tfor rows.Next() {\n\t\t\tvar todo Todo\n\t\t\tif err := rows.Scan(&todo.ID, &todo.Description, &todo.Due); err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttodos = append(todos, &todo)\n\t\t}\n\t\tjson.NewEncoder(w).Encode(todos)\n\t})\n}\n\nfunc main() {}undefinedA convenience function sqlite.Open() is provided to create a database connection. Because the http.Handle function is inside the init() function the Spin SQLite driver cannot be initialized the same way as other drivers using undefined.{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/sqlite-api-guide#using-sqlite-storage-from-applications"},{"project":"v3","title":"SQLite Storage","subheading":"Preparing an SQLite Database","content":"Although Spin provides SQLite as a built-in database, SQLite still needs you to create its tables.  In most cases, the most convenient way to do this is to use the spin up --sqlite option to run whatever SQL statements you need before your application starts.  This is typically used to create or alter tables, but can be used for whatever other maintenance or troubleshooting tasks you need.You can run a SQL script from a file using the @filename syntax:spin up --sqlite @migration.sqlOr you can pass SQL statements directly on the command line as a (quoted) string:spin up --sqlite \"CREATE TABLE IF NOT EXISTS todos (id INTEGER PRIMARY KEY AUTOINCREMENT, description TEXT NOT NULL, due TEXT NOT NULL)\"As with runtime operations, this flag uses the undefined.You can provide the --sqlite flag more than once; Spin runs the statements (or files) in the order you provide them, and waits for each to complete before running the next.undefined","keywords":"","subsectionKeywords":"","url":"/v3/sqlite-api-guide#preparing-an-sqlite-database"},{"project":"v3","title":"SQLite Storage","subheading":"Custom SQLite Databases","content":"Spin defines a database named \"default\" and provides automatic backing storage.  If you need to customize Spin with additional databases, or to change the backing storage for the default database, you can do so via the --runtime-config-file flag and the runtime-config.toml file.  See undefined for details.","keywords":"","subsectionKeywords":"","url":"/v3/sqlite-api-guide#custom-sqlite-databases"},{"project":"v3","title":"SQLite Storage","subheading":"Granting Access to Custom SQLite Databases","content":"As mentioned above, by default, a given component of an app will not have access to any SQLite Databases. Access must be granted specifically to each component via the component manifest, using the component.sqlite_databases field in the manifest.Components can be given access to different databases, and may be granted access to more than one database. For example:# c1 has no access to any databases\n[component.example]\nname = \"c1\"\n\n# c2 can use the default database, but no custom databases\n[component.example]\nname = \"c2\"\nsqlite_databases = [\"default\"]\n\n# c3 can use the custom databases \"marketing\" and \"sales\", which must be\n# defined in the runtime config file, but cannot use the default database\n[component.example]\nname = \"c3\"\nsqlite_databases = [\"marketing\", \"sales\"]","keywords":"","subsectionKeywords":"","url":"/v3/sqlite-api-guide#granting-access-to-custom-sqlite-databases"},{"project":"v3","title":"Creating Spin templates","subheading":"","content":"undefinedundefinedundefinedundefinedSpin templates allow a Spin developer to quickly create the skeleton of an\napplication or component, ready for the application logic to be filled in.A template consists of two directories, content and metadata.undefinedundefinedFor examples of the directory contents, see the templates directory in the\nundefined.Templates must always be shared in a templates directory.  This allows the\ninstaller to locate them in repos that contain other content.","subsectionKeywords":"","url":"/v3/template-authoring"},{"project":"v3","title":"Creating Spin templates","subheading":"Authoring the Content","content":"Copy all the files that you want to be copied as part of the template into\nthe content directory. If you do nothing more, they will be copied\nverbatim. Often, though, you'll want to allow the user to put their own\nvalues in - for example, a project name, or an HTTP route.To do this, replace the text you want the user to be able to substitute\nwith an expression of the form {{parameter-name}}, where parameter-name\nis an identifier of your choice.  undefined - see below.You can reuse a parameter in more than one place - it will be prompted only once and will get the same value in each place.You can also transform the user value by specifying a filter after a bar:\n{{parameter-name | filter-name}}.  This is particularly useful when you\nwant to conform to specific language conventions. The following filters\nare supported:| Name          | Effect |\n|---------------|--------|\n| kebab_case  | Transforms input into kebab case, e.g. My Application to my-application |\n| snake_case  | Transforms input into snake case, e.g. My Application to my_application |\n| pascal_case | Transforms input into Pascal case, e.g. my application to MyApplication |","keywords":"","subsectionKeywords":"","url":"/v3/template-authoring#authoring-the-content"},{"project":"v3","title":"Creating Spin templates","subheading":"Expression Syntax","content":"Content uses undefined. See the Liquid documentation for the available syntax and control tags.A common pitfall occurs because some entries in spin.toml, such as undefined, use the same double-brace syntax as Liquid does. If you want to generate a line such as my-secret = \"{{ secret }}\", you must escape the double braces, for example using the Liquid undefined. If you don't do this, Liquid will look for a template parameter called secret instead!","keywords":"","subsectionKeywords":"","url":"/v3/template-authoring#expression-syntax"},{"project":"v3","title":"Creating Spin templates","subheading":"Authoring the Manifest","content":"The template manifest is a TOML file. It must be named spin-template.toml:manifest_version = \"1\"\nid = \"my-application\"\ndescription = \"An application\"\ntags = [\"my-tag\"]\n\n[parameters]\n# Example parameter\nproject-name = { type = \"string\", prompt = \"Project name\" }undefinedundefinedundefinedundefinedThe parameters table is where you list the placeholders that you edited\ninto your content for the user to substitute. You should include an entry\nfor each parameter. The key is the parameter name, and the value a JSON\ndocument that contains at minimum a type and prompt.  type must\ncurrently be string.  prompt is displayed when prompting the user\nfor the value to substitute.The document may also have a default, which will be displayed to the user\nand can be accepted by pressing Enter. It may also specify constraints\non what the user is allowed to enter. The following constraints are\nsupported:| Key           | Value and usage |\n|---------------|-----------------|\n| pattern     | A regular expression. The user input must match the regular expression to be accepted. |","keywords":"","subsectionKeywords":"","url":"/v3/template-authoring#authoring-the-manifest"},{"project":"v3","title":"Creating Spin templates","subheading":"Supporting  spin add","content":"The spin add command lets users add your template as a new component in\nan existing application. If you'd like to support this, you'll need to\nadd a few items to your metadata.undefinedundefined| Key             | Value and usage |\n|-----------------|-----------------|\n| snippets      | A subtable with an entry named component, whose value is the name of the file containing the component manifest template. (Don't include the snippets directory prefix - Spin knows to look in the snippets directory.) |\n| skip_files    | Optional array of content files that should undefined be copied when running in \"add component\" mode. For example, if your template contains a spin.toml file, you should use this setting to exclude that, because you want to add a new entry to the existing file, not overwrite it. |\n| skip_parameters | Optional array of parameters that Spin should undefined prompt for when running in \"add component\" mode. |Here is an example add_component table from a HTTP template:[add_component]\nskip_files = [\"spin.toml\"]\nskip_parameters = [\"shared-prefix\"]\n[add_component.snippets]\ncomponent = \"component.txt\"undefined","keywords":"","subsectionKeywords":"","url":"/v3/template-authoring#supporting-spin-add"},{"project":"v3","title":"Creating Spin templates","subheading":"Hosting Templates in Git","content":"You can publish templates in a Git repo.  The templates must be in the /templates\ndirectory, with a subdirectory per template.When a user installs templates from your repo, by default Spin looks for a tag\nto identify a compatible version of the templates.  This tag is of the\nform spin/templates/vX.Y, where X is the major version, and Y the minor\nversion, of the user's copy of Spin. For example, if the user is on\nSpin 0.3.1, templates will be installed from spin/templates/v0.3.  If this\ntag does not exist, Spin installs templates from HEAD.","keywords":"","subsectionKeywords":"","url":"/v3/template-authoring#hosting-templates-in-git"},{"project":"v3","title":"Testing Applications","subheading":"","content":"The undefined allows you to run tests, written in WebAssembly, against a Spin application (where all Spin and WASI APIs are configurable mocks).To use spin test you write test scenarios for your app in any language with WebAssembly component support, and mock out all interactions your app has with the outside world without requiring any code changes to the app itself. That means the code you test in development is the same code that runs in production.undefined","subsectionKeywords":"","url":"/v3/testing-apps"},{"project":"v3","title":"Testing Applications","subheading":"Prerequisites","content":"The example below uses the undefined and undefined(a cargo subcommand for building WebAssembly components).","keywords":"","subsectionKeywords":"","url":"/v3/testing-apps#prerequisites"},{"project":"v3","title":"Testing Applications","subheading":"Installing the Plugin","content":"To run spin test , you’ll first need to install the canary release of the plugin. As spin test matures, we’ll be making stable releases:spin plugin install -u https://github.com/spinframework/spin-test/releases/download/canary/spin-test.jsonThis will install the plugin which can be invoked with spin test.","keywords":"","subsectionKeywords":"","url":"/v3/testing-apps#installing-the-plugin"},{"project":"v3","title":"Testing Applications","subheading":"Creating App and Component","content":"First, create an empty Spin app, change into that app folder and then add a component inside it:$ spin new -t http-empty my-app --accept-defaults\n$ cd my-app/\n$ spin add -t http-rust my-component --accept-defaultsThe above commands will scaffold out the application in the following format:my-app/\n├── my-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.toml","keywords":"","subsectionKeywords":"","url":"/v3/testing-apps#creating-app-and-component"},{"project":"v3","title":"Testing Applications","subheading":"Creating a Test Suite","content":"There is currently first-class support for writing tests in Rust, but any language with support for writing WebAssembly components can be used as long as the fermyon:spin-test/test world is targeted. You can find the definition of this world undefined. For this example, we'll use Rust.We use cargo to create a test suite, and then change into our newly created tests directory:$ cargo new tests --lib\n$ cd testsAfter running the cargo new command we will have the following application structure:my-app/\n├── my-component\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n├── spin.toml\n└── tests\n    ├── Cargo.toml\n    └── src\n        └── lib.rsFrom within that test suite (from inside the tests directory), we then add the spin-test SDK reference:$ cargo add spin-test-sdk --git https://github.com/spinframework/spin-testThen, we open the Cargo.toml file from within in the tests directory and edit to add the crate-type of cdylib:[lib]\ncrate-type = [\"cdylib\"]The my-app/tests/Cargo.toml file will look like this after editing:[package]\nname = \"tests\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nspin-test-sdk = { git = \"https://github.com/spinframework/spin-test\", version = \"0.1.0\" }\n\n[lib]\ncrate-type = [\"cdylib\"]","keywords":"","subsectionKeywords":"","url":"/v3/testing-apps#creating-a-test-suite"},{"project":"v3","title":"Testing Applications","subheading":"Writing a Test","content":"Next, create a test that spin test can run as a compiled WebAssembly component.In this example, we will write some tests appropriate to a JSON API service for information about service users. Here are two such tests written in Rust using the undefined. The first test ensures that the Spin app responds properly to an HTTP request. The second test ensures that the Spin app responds properly when the user data is present in the key-value store - for testing purposes, simulated by inserting it into a \"virtual\" store.Open the my-app/tests/src/lib.rs file and fill it with the following content:use spin_test_sdk::{\n    bindings::{fermyon::spin_test_virt, wasi, wasi::http},\n    spin_test,\n};\n\n#[spin_test]\nfn send_get_request_without_key() {\n    // Perform the request\n    let request = http::types::OutgoingRequest::new(http::types::Headers::new());\n    request.set_path_with_query(Some(\"/\")).unwrap();\n    let response = spin_test_sdk::perform_request(request);\n\n    // Assert response status and body is 404\n    assert_eq!(response.status(), 404);\n}\n\n#[spin_test]\nfn send_get_request_with_invalid_key() {\n    // Perform the request\n    let request = http::types::OutgoingRequest::new(http::types::Headers::new());\n    request.set_path_with_query(Some(\"/x?123\")).unwrap();\n    let response = spin_test_sdk::perform_request(request);\n\n    // Assert response status and body is 404\n    assert_eq!(response.status(), 404);\n}\n\n#[spin_test]\nfn send_get_request_with_invalid_key_id() {\n    // Perform the request\n    let request = http::types::OutgoingRequest::new(http::types::Headers::new());\n    request.set_path_with_query(Some(\"/user?0\")).unwrap();\n    let response = spin_test_sdk::perform_request(request);\n\n    // Assert response status and body is 404\n    assert_eq!(response.status(), 404);\n}\n\n#[spin_test]\nfn cache_hit() {\n    let user_json = r#\"{\"id\":123,\"name\":\"Ryan\"}\"#;\n\n    // Configure the app's virtualised 'default' key-value store ready for the test\n    let key_value = spin_test_virt::key_value::Store::open(\"default\");\n    // Set a specific key with a specific value\n    key_value.set(\"123\", user_json.as_bytes());\n\n    // Make the request against the Spin app\n    let request = wasi::http::types::OutgoingRequest::new(wasi::http::types::Headers::new());\n    request.set_path_with_query(Some(\"/user?123\")).unwrap();\n    let response = spin_test_sdk::perform_request(request);\n\n    // Assert the response status and body\n    assert_eq!(response.status(), 200);\n    let body = response.body_as_string().unwrap();\n    assert_eq!(body, user_json);\n\n    // Assert the key-value store was queried\n    assert_eq!(\n        key_value.calls(),\n        vec![spin_test_virt::key_value::Call::Get(\"123\".to_owned())]\n    );\n}The following points are intended to unpack the above example for your understanding:undefinedundefinedundefinedThe tests above run inside of WebAssembly. Calls, such as Key Value storage and retrieval, never actually leave the WebAssembly sandbox. This means your tests are quick and reproducible as you don’t need to rely on running an actual web server, and you don’t need to ensure any of your app’s dependencies are running. Everything your app interacts with is mocked for you. The isolation benefits from this mocking mean that your application's actual data is never touched. There is also the added benefit of reproducibility whereby you never have to worry about leftover data from previous tests.","keywords":"","subsectionKeywords":"","url":"/v3/testing-apps#writing-a-test"},{"project":"v3","title":"Testing Applications","subheading":"Configure  spin-test","content":"Before you can run the test, you'll need to tell spin-test where your test lives and how to build it. You do this from inside our app’s manifest (the spin.toml file). We change back up into our application's root directory:$ cd ..Then we edit the my-app application's manifest (the spin.toml file) by adding the following block:[component.my-component.tool.spin-test]\nsource = \"tests/target/wasm32-wasip1/release/tests.wasm\"\nbuild = \"cargo component build --release\"\ndir = \"tests\"","keywords":"","subsectionKeywords":"","url":"/v3/testing-apps#configure-spin-test"},{"project":"v3","title":"Testing Applications","subheading":"Updating the App to Pass the Tests","content":"This section provides configuration and business logic at the application level.","keywords":"","subsectionKeywords":"","url":"/v3/testing-apps#updating-the-app-to-pass-the-tests"},{"project":"v3","title":"Testing Applications","subheading":"Configure App Storage","content":"We are using Key Value storage in the application and therefore need to configure the list of allowed key_value_stores in our spin.toml file (in this case we are just using the default). Go ahead and paste the key_value_stores configuration directly inside the [component.my-component] section, as shown below:[component.my-component]\n...\nkey_value_stores = [\"default\"]\n...undefinedAfter editing, the whole my-app/spin.toml file will look like the following:spin_manifest_version = 2\n\n[application]\nname = \"my-app\"\nversion = \"0.1.0\"\nauthors = [\"Fermyon Engineering <engineering@fermyon.com>\"]\ndescription = \"\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"my-component\"\n\n[component.my-component]\nsource = \"my-component/target/wasm32-wasip1/release/my_component.wasm\"\nallowed_outbound_hosts = []\nkey_value_stores = [\"default\"]\n[component.my-component.build]\ncommand = \"cargo build --target wasm32-wasip1 --release\"\nworkdir = \"my-component\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]\n\n[component.my-component.tool.spin-test]\nsource = \"tests/target/wasm32-wasip1/release/tests.wasm\"\nbuild = \"cargo component build --release\"\ndir = \"tests\"","keywords":"","subsectionKeywords":"","url":"/v3/testing-apps#configure-app-storage"},{"project":"v3","title":"Testing Applications","subheading":"Adding Business Logic","content":"The goal of tests is to ensure that the business logic in our application works as intended. We haven't yet updated our \"business logic\" frrom the \"Hello, Fermyon\" app. To make our new tests pass, copy and paste the following code into the application's source file (located at my-app/my-component/src/lib.rs):use spin_sdk::{\n    http::{IntoResponse, Request, Response, Method},\n    http_component,\n    key_value::Store,\n};\n\n#[http_component]\nfn handle_request(req: Request) -> anyhow::Result<impl IntoResponse> {\n    // Open the default key-value store\n    let store = Store::open_default()?;\n\n    let (status, body) = match *req.method() {\n        Method::Get => {\n            // Get the value associated with the request URI, or return a 404 if it's not present\n            match store.get(req.query())? {\n                Some(value) => {\n                    println!(\"Found value for the key {:?}\", req.query());\n                    (200, Some(value))\n                }\n                None => {\n                    println!(\"No value found for the key {:?}\", req.query());\n                    (404, None)\n                }\n            }\n        }\n        // No other methods are currently supported\n        _ => (405, None),\n    };\n    Ok(Response::new(status, body))\n}","keywords":"","subsectionKeywords":"","url":"/v3/testing-apps#adding-business-logic"},{"project":"v3","title":"Testing Applications","subheading":"Building and Running the Test","content":"With the application's configuration and business logic done, we're ready for our test to be run. We can do this by invoking spin-test from the application's root directory (my-app):$ spin build\n$ spin test\n\nrunning 4 tests\nNo value found for the key \"123\"\ntest request-with-invalid-key    ... ok\nFound value for the key \"123\"\ntest cache-hit                   ... ok\nNo value found for the key \"0\"\ntest request-with-invalid-key-id ... ok\nNo value found for the key \"\"\ntest request-without-key         ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 2.08s","keywords":"","subsectionKeywords":"","url":"/v3/testing-apps#building-and-running-the-test"},{"project":"v3","title":"Testing Applications","subheading":"Next Steps","content":"spin-test is still in the early days of development, so you’re likely to run into things that don’t quite work yet. We’d love to hear about your experience so we can prioritize which features and bugs to fix first. We’re excited about the future potential of using WebAssembly components for testing, and we look forward to hearing about your experiences as we continue the development of spin-test.You might also like to learn about spin doctor which is a command-line tool that detects and helps fix issues preventing applications from building and running. For more information see the undefined","keywords":"","subsectionKeywords":"","url":"/v3/testing-apps#next-steps"},{"project":"v3","title":"Triggers","subheading":"","content":"undefinedundefinedA Spin undefined maps an event, such as an HTTP request or a Redis pub-sub message, to a component that handles that event.An application can contain multiple triggers.In Spin 2.2 and earlier, all triggers must be of the same type.  For example, an application can contain triggers for multiple HTTP routes, or for multiple Redis pub-sub channels, but not both.In Spin 2.3 and later, an application can contain triggers of different types.  For example, a single application can serve HTTP on one or more routes, and at the same time subscribe to one or more Redis pub-sub channels.undefined","subsectionKeywords":"","url":"/v3/triggers"},{"project":"v3","title":"Triggers","subheading":"Triggers and Components","content":"How events are specified depends on the type of trigger involved. For example, an undefined is specified by the route it handles. A undefined is specified by the schedule on which it runs. A undefined is specified by the channel it monitors. A trigger always, however, has a component field, specifying the component that handles matching events.  The component can be specified in two ways.","keywords":"","subsectionKeywords":"","url":"/v3/triggers#triggers-and-components"},{"project":"v3","title":"Triggers","subheading":"Mapping a Trigger to a Named Component","content":"An application manifest can define undefined components in the component section. Each component is a WebAssembly component file (or reference) plus the supporting resources it needs, and metadata such as build information. The component name is written as part of the TOML component declaration. For example:[component.checkout]  # The component's name is \"checkout\"\nsource = \"target/wasm32-wasip1/release/checkout.wasm\"\nallowed_outbound_hosts = [\"https://payment-processing.example.com\"]\nkey_value_stores = [\"default\"]\n[component.checkout.build]\ncommand = \"cargo build --target wasm32-wasip1 --release\"To map a trigger to a named component, specify its name in the trigger's component field:[[trigger.http]]\nroute = \"/cart/checkout\"\ncomponent = \"checkout\"","keywords":"","subsectionKeywords":"","url":"/v3/triggers#mapping-a-trigger-to-a-named-component"},{"project":"v3","title":"Triggers","subheading":"Writing the Component Inside the Trigger","content":"Instead of writing the component in a separate section and referencing it by name, you can write it the same fields undefined in the trigger component field.  For example:# Using inline table syntax\n[[trigger.http]]\nroute = \"/cart/...\"\ncomponent = { source = \"dist/cart.wasm\" }\n\n# Nested table syntax\n[[trigger.http]]\nroute = \"/cart/...\"\n[trigger.http.component]\nsource = \"target/wasm32-wasip1/release/checkout.wasm\"\nallowed_outbound_hosts = [\"payment-processing.example.com\"]These behave in the same way: the inline table syntax is more compact for short declarations, but the nested table syntax is easier to read when there are many fields or the values are long.","keywords":"","subsectionKeywords":"","url":"/v3/triggers#writing-the-component-inside-the-trigger"},{"project":"v3","title":"Triggers","subheading":"Choosing Between the Approaches","content":"These ways of writing components achieve the same thing, so which should you choose?Named components have the following advantages:undefinedundefinedInline components have the following advantages:undefinedundefinedIf you are not sure, or are not experienced, we recommend using named components at first, and adopting inline components as and when you find cases where you prefer them.","keywords":"","subsectionKeywords":"","url":"/v3/triggers#choosing-between-the-approaches"},{"project":"v3","title":"Triggers","subheading":"Setting Up Multiple Trigger Types","content":"In this section, we build an application that contains multiple triggers.Here is an example of creating an application with both HTTP and Redis triggers:# Start with an empty application\n$ spin new -t http-empty multiple-trigger-example\nDescription: An application that handles both HTTP requests and Redis messages\n# Change into to the application directory\n$ cd multiple-trigger-example\n# Add an HTTP trigger application\n$ spin add -t http-rust rust-http-trigger-example\nDescription: A Rust HTTP example\nHTTP path: /...\n# Add a Redis trigger application\n$ spin add -t redis-rust rust-redis-trigger-example\nDescription: A Rust redis example\nRedis address: redis://localhost:6379\nRedis channel: oneThe above spin new and spin add commands will scaffold a Spin manifest (spin.toml file) with the following triggers:spin_manifest_version = 2\n\n[application]\nname = \"multiple-trigger-example\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your-name@example.com>\"]\ndescription = \"An application that handles both HTTP requests and Redis messages\"\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"rust-http-trigger-example\"\n\n[component.rust-http-trigger-example]\nsource = \"rust-http-trigger-example/target/wasm32-wasip1/release/rust_http_trigger_example.wasm\"\nallowed_outbound_hosts = []\n[component.rust-http-trigger-example.build]\ncommand = \"cargo build --target wasm32-wasip1 --release\"\nworkdir = \"rust-http-trigger-example\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]\n\n[application.trigger.redis]\naddress = \"redis://localhost:6379\"\n\n[[trigger.redis]]\nchannel = \"one\"\ncomponent = \"rust-redis-trigger-example\"\n\n[component.rust-redis-trigger-example]\nsource = \"rust-redis-trigger-example/target/wasm32-wasip1/release/rust_redis_trigger_example.wasm\"\nallowed_outbound_hosts = []\n[component.rust-redis-trigger-example.build]\ncommand = \"cargo build --target wasm32-wasip1 --release\"\nworkdir = \"rust-redis-trigger-example\"\nwatch = [\"src/**/*.rs\", \"Cargo.toml\"]                             ","keywords":"","subsectionKeywords":"","url":"/v3/triggers#setting-up-multiple-trigger-types"},{"project":"v3","title":"Triggers","subheading":"Cron Trigger","content":"Spin has experimental support for creating and running components on a schedule. Please note that there are only working Cron Trigger app samples written in undefined and undefined at present.undefinedLet's look at how the undefined allows you to deploy an application that runs on a schedule. A Cron trigger maps a cron expression (a schedule) to a specific component. For example:[[trigger.cron]]\ncomponent = \"hello-cron\"\ncron_expression = \"1/2 * * * * *\"undefined","keywords":"","subsectionKeywords":"","url":"/v3/triggers#cron-trigger"},{"project":"v3","title":"Triggers","subheading":"Cron Trigger Expressions","content":"The expression is based on the crontab (cron table) syntax whereby each line is made up of 7 fields that represent the time to execute.#  ┌──────────── sec (0–59)\n#  |    ┌───────────── min (0–59)\n#  |    │  ┌───────────── hour (0–23)\n#  |    │  │  ┌───────────── day of month (1–31)\n#  |    │  │  │  ┌───────────── month (1–12)\n#  |    │  │  │  │  ┌───────────── day of week (0–6)\n#  |    │  │  │  │  |  ┌─────────────- year\n#  |    │  │  │  │  |  │\n#  |    │  │  │  │  |  │\n  1/30  *  *  *  *  *  * undefinedLet's look at a time-based workload inside a Rust application.","keywords":"","subsectionKeywords":"","url":"/v3/triggers#cron-trigger-expressions"},{"project":"v3","title":"Triggers","subheading":"Installing the Cron Trigger Plugin","content":"First, we install the plugin:spin plugins install --url https://github.com/spinframework/spin-trigger-cron/releases/download/canary/trigger-cron.json","keywords":"","subsectionKeywords":"","url":"/v3/triggers#installing-the-cron-trigger-plugin"},{"project":"v3","title":"Triggers","subheading":"Installing the Cron Trigger Template","content":"Then, we install the template:spin templates install --git https://github.com/spinframework/spin-trigger-cron","keywords":"","subsectionKeywords":"","url":"/v3/triggers#installing-the-cron-trigger-template"},{"project":"v3","title":"Triggers","subheading":"Creating the Application","content":"With the plugin and template installed, we create a new application:spin new -t cron-rust hello_cron --accept-defaults","keywords":"","subsectionKeywords":"","url":"/v3/triggers#creating-the-application"},{"project":"v3","title":"Triggers","subheading":"Inspecting the Source Code","content":"The Rust source code for this application is as follows:use spin_cron_sdk::{cron_component, Error, Metadata};\nuse spin_sdk::variables;\n\n#[cron_component]\nasync fn handle_cron_event(metadata: Metadata) -> Result<(), Error> {\n    let key = variables::get(\"something\").unwrap_or_default();\n    println!(\n        \"[{}] Hello this is me running every {}\",\n        metadata.timestamp, key\n    );\n    Ok(())\n}","keywords":"","subsectionKeywords":"","url":"/v3/triggers#inspecting-the-source-code"},{"project":"v3","title":"Triggers","subheading":"Building and Running the Application","content":"We can immediately run this pre-written (template) application and observe the time-driven execution:cd hello_cron\nspin build --up\n\nBuilding component hello-cron with `cargo build --target wasm32-wasip1 --release`\n\n...\n\nFinished building all Spin components\n[1715640447] Hello from a cron component\n[1715640449] Hello from a cron component\n[1715640451] Hello from a cron component\n[1715640453] Hello from a cron component\n[1715640455] Hello from a cron component\n[1715640457] Hello from a cron componentAs we can see from the above output, our application is now running and executing the function every two seconds without the need for any incoming requests or any intervention from users or other machines.If you would like to learn more about using the Spin Cron Trigger, please check out undefined and the undefined.","keywords":"","subsectionKeywords":"","url":"/v3/triggers#building-and-running-the-application"},{"project":"v3","title":"Troubleshooting Application Development","subheading":"","content":"","subsectionKeywords":"","url":"/v3/troubleshooting-application-dev"},{"project":"v3","title":"Troubleshooting Application Development","subheading":"Spin Doctor","content":"The spin doctor command detects problems that could stop your application building and running, and can help to fix them.  These include problems like invalid manifests, missing Wasm files, and missing tools.To troubleshoot using spin doctor, run the command:$ spin doctorundefinedSpin performs a series of checks on your application. If it finds a problem, it prints a description and, if possible, offers to fix it. Here's an example where a stray keystroke has messed up the version field in the application manifest:$ spin doctor\n📟 The Spin Doctor is in.\n🩺 Checking spin.toml...\n\n❗ Diagnosis: Manifest 'spin_manifest_version' must be \"1\", not \"11\"\n🩹 The Spin Doctor can help! Would you like to:\n> Set manifest version to \"1\"\n  Do nothing\n  See more details about the recommended changesIf spin doctor detects a problem it can fix, you can choose to accept the fix, skip it to fix manually later, or see more details before choosing.  If spin doctor can't fix the problem, it displays the problem so you can make your own decision about how to fix it.undefined","keywords":"","subsectionKeywords":"","url":"/v3/troubleshooting-application-dev#spin-doctor"},{"project":"v3","title":"Troubleshooting Application Development","subheading":"Spin Test","content":"The undefined allows you to write test scenarios for your application's business logic. For more information, see undefined.","keywords":"","subsectionKeywords":"","url":"/v3/troubleshooting-application-dev#spin-test"},{"project":"v3","title":"Troubleshooting Application Development","subheading":"Viewing Spin Debug Logs","content":"If you need to follow what Spin is doing internally, set the RUST_LOG environment variable for detailed logs, before running spin up:$ export RUST_LOG=spin=traceundefined","keywords":"","subsectionKeywords":"","url":"/v3/troubleshooting-application-dev#viewing-spin-debug-logs"},{"project":"v3","title":"Upgrade Spin","subheading":"","content":"undefinedundefinedundefined","subsectionKeywords":"","url":"/v3/upgrade"},{"project":"v3","title":"Upgrade Spin","subheading":"Are You on the Latest Version?","content":"The best way to know if you're on the latest version of Spin is to run spin --version:$ spin --versionYou can compare the output from the above command with the undefined listed in the Spin GitHub repository (which is also shown in the image below):undefined","keywords":"","subsectionKeywords":"","url":"/v3/upgrade#are-you-on-the-latest-version"},{"project":"v3","title":"Upgrade Spin","subheading":"Upgrade Spin","content":"Spin can be installed in many ways, and therefore the upgrade procedure can differ between users. Here are a few suggested ways to upgrade Spin to the latest version. If you're not sure how or where you installed your current version of Spin try using the which command on undefined and the where command on undefined, as shown below:{{ tabs \"os\" }}{{ startTab \"Linux\"}}$ which spin{{ blockEnd }}{{ startTab \"macOS\"}}$ which spin{{ blockEnd }}{{ startTab \"Windows\"}}$ where spin{{ blockEnd }}{{ blockEnd }}","keywords":"","subsectionKeywords":"","url":"/v3/upgrade#upgrade-spin"},{"project":"v3","title":"Upgrade Spin","subheading":"Installer","content":"If you originally followed the documentation's undefined, please revisit to reinstall.undefined/usr/local/bin/spin","keywords":"","subsectionKeywords":"","url":"/v3/upgrade#installer"},{"project":"v3","title":"Upgrade Spin","subheading":"Homebrew","content":"If you installed Spin using undefined please use the following commands to upgrade Spin.$ brew update\n$ brew upgrade fermyon/tap/spin","keywords":"","subsectionKeywords":"","url":"/v3/upgrade#homebrew"},{"project":"v3","title":"Upgrade Spin","subheading":"Cargo","content":"If you originally followed the documentation's undefined, please revisit to reinstall.undefined~/.cargo/bin/spin","keywords":"","subsectionKeywords":"","url":"/v3/upgrade#cargo"},{"project":"v3","title":"Upgrade Spin","subheading":"Source","content":"If you followed the documentation's undefined please revisit to reinstall.undefined~/spin/target/release/spin","keywords":"","subsectionKeywords":"","url":"/v3/upgrade#source"},{"project":"v3","title":"Upgrade Spin","subheading":"Troubleshooting","content":"If you have upgraded Spin and don't see the newer version, please consider the following.","keywords":"","subsectionKeywords":"","url":"/v3/upgrade#troubleshooting"},{"project":"v3","title":"Upgrade Spin","subheading":"Not Seeing the Latest Version?","content":"It may be possible that you have installed Spin undefined of the above methods. In this case, the Spin executable that runs is the one that is listed first in your PATH system variable.If you have upgraded Spin yet still see the old version using spin --version this can be due to the order of precedence in your PATH. Try echoing your path to the screen and checking to see whether the location of your intended Spin executable is listed before or after other pre-existing installation paths:echo $PATH\n/Users/my_user/.cargo/bin:/usr/local/binundefinedIn the above case, the undefined's installation will take precedence over the undefined's installation.In this case, you can either remove the Cargo installation of Spin using cargo uninstall spin-cli or update your system path to prioritize the Spin binary path that you prefer.","keywords":"","subsectionKeywords":"","url":"/v3/upgrade#not-seeing-the-latest-version"},{"project":"v3","title":"Building a URL Shortener With Spin","subheading":"","content":"undefinedundefinedundefined","subsectionKeywords":"","url":"/v3/url-shortener-tutorial"},{"project":"v3","title":"Building a URL Shortener With Spin","subheading":"A Simple URL Shortener Built With Spin","content":"This tutorial will walk you through building a Spin component that\nredirects short URLs to their configured destinations.\nIn essence, this is a simple HTTP component that returns a response that contains\nredirect information based on the user-defined routes.This is an evolving tutorial. As Spin allows building more complex components\n(through supporting access to services like databases), this tutorial will be\nupdated to reflect that.","keywords":"","subsectionKeywords":"","url":"/v3/url-shortener-tutorial#a-simple-url-shortener-built-with-spin"},{"project":"v3","title":"Building a URL Shortener With Spin","subheading":"Here Is One We Prepared Earlier","content":"The complete implementation for this tutorial undefined.First, our URL shortener allows users to configure their own final URLs —\ncurrently, that is done through a configuration file that contains multiple\n[[route]] entries, each containing the shortened path as source, and\nthe destination URL:[[route]]\nsource = \"/spin\"\ndestination = \"https://github.com/spinframework/spin\"\n\n[[route]]\nsource = \"/hype\"\ndestination = \"https://www.fermyon.com/blog/how-to-think-about-wasm\"Whenever a request for https://<domain>/spin is sent, our component will\nredirect to https://github.com/spinframework/spin. Now that we have a basic\nunderstanding of how the component should behave, let's see how to implement it\nusing Spin.First, we start with undefined:/// A Spin HTTP component that redirects requests \n/// based on the router configuration.\n#[http_component]\nfn redirect(req: Request) -> Result<Response> {\n    let router = Router::default()?;\n    router.redirect(req)\n}All the component does is create a new router based on the default configuration,\nthen use it to redirect the request. Let's see how the router is defined:#[derive(Debug, Deserialize, Serialize)]\npub struct Route {\n    pub source: String,\n    pub destination: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct Router {\n    #[serde(rename = \"route\")]\n    pub routes: Vec<Route>,\n}The Router structure is a Rust representation of the TOML configuration above.pub fn redirect(self, req: Request) -> Result<Response> {\n    // read the request path from the `spin-path-info` header\n    let path_info = req\n        .headers()\n        .get(\"spin-path-info\")\n        .expect(\"cannot get path info from request headers\");\n    // if the path is not present in the router configuration,\n    // return 404 Not Found.\n    let route = match self.path(path_info.to_str()?) {\n        Some(r) => r,\n        None => return not_found(),\n    };\n    // otherwise, return the redirect to the destination\n    let res = http::Response::builder()\n        .status(http::StatusCode::PERMANENT_REDIRECT)\n        .header(http::header::LOCATION, route.destination)\n        .body(None)?;\n    Ok(res)\n}The redirect function is straightforward — it reads the request path from the\nspin-path-info header (make sure to read the undefined\nfor an overview of the HTTP headers present in Spin components), selects the\ncorresponding destination from the router configuration, then sends the\nHTTP redirect to the new location.At this point, we can build and run the module with Spin:$ spin build\n$ spin upAnd the component can now handle incoming requests:# based on the configuration file, a request\n# to /spin should be redirected\n$ curl -i localhost:3000/spin\nHTTP/1.1 308 Permanent Redirect\nlocation: https://github.com/spinframework/spin\ncontent-length: 0\n# based on the configuration file, a request\n# to /hype should be redirected\n$ curl -i localhost:3000/hype\nHTTP/1.1 308 Permanent Redirect\nlocation: https://www.fermyon.com/blog/how-to-think-about-wasm\ncontent-length: 0\n# /abc is not present in the router configuration,\n# so this returns a 404.\n$ curl -i localhost:3000/abc\nHTTP/1.1 404 Not Found\ncontent-length: 9\n\nNot FoundundefinedWe can now undefined (together\nwith router configuration file):$ spin registry push ghcr.io/alyssa-p-hacker/url-shortener:v1\nPushed with digest sha256:3c408a1b29b3098286c7ea5ab22f47248ccfadcc63ad5596ca0d85e3f522c43dAnd now we can run the application directly from the registry:$ spin up -f ghcr.io/alyssa-p-hacker/url-shortener:v1\n\nServing http://127.0.0.1:3000\nAvailable Routes:\n  shortener: http://127.0.0.1:3000 (wildcard)","keywords":"","subsectionKeywords":"","url":"/v3/url-shortener-tutorial#here-is-one-we-prepared-earlier"},{"project":"v3","title":"Building a URL Shortener With Spin","subheading":"Conclusion","content":"In this tutorial we built a simple URL shortener as a Spin component.\nIn the future we will expand this tutorial by storing the router configuration\nin a database supported by Spin, and potentially create another component that\ncan be used to add new routes to the configuration.","keywords":"","subsectionKeywords":"","url":"/v3/url-shortener-tutorial#conclusion"},{"project":"v3","title":"Application Variables","subheading":"","content":"undefinedundefinedundefinedSpin supports dynamic application variables. Instead of being static, their values can be updated without modifying the application, creating a simpler experience for rotating secrets, updating API endpoints, and more.These variables are defined in a Spin application manifest (in the [variables] section), and their values can be set or overridden at runtime by an undefined. When running Spin locally, the variables provider can be undefined for secrets, undefined, or host environment variables.For information about configuring application variables providers, refer to the undefined.","subsectionKeywords":"","url":"/v3/variables"},{"project":"v3","title":"Application Variables","subheading":"Adding Variables to Your Applications","content":"Variables are added to an application under the top-level [variables] section of an application manifest (spin.toml). Each entry must either have a default value or be marked as required = true. “Required” entries must be undefined with a value.For example, consider an application which makes an outbound API call using a bearer token. To configure this using variables, you would:undefinedundefinedundefined[variables]\napi_token = { required = true }\napi_uri = { default = \"http://my-api.com\" }Variables are surfaced to a specific component by adding a [component.(name).variables] section to the component and referencing them within it. The [component.(name).variables] section contains a mapping of component variables and values. Entries can be static (like api_version below) or reference an updatable application variable (like token below) using undefined-inspired string templates. Only components that explicitly use variables in their configuration section will get access to them. This enables only exposing variables (such as secrets) to the desired components of an application.[component.(name).variables]\ntoken = \"\\{{ api_token }}\"\napi_uri = \"\\{{ api_uri }}\"\napi_version = \"v1\"When a component variable references an application variable, its value will dynamically update as the application variable changes. For example, if the api_token variable is provided using the undefined, it can be updated by changing the value in HashiCorp Vault. The next time the component gets the value of token, the latest value of api_token will be returned by the provider. See the undefined to learn how to use Spin's configuration SDKs to get configuration variables within applications.Variables can also be used in other sections of the application manifest that benefit from dynamic configuration. In these cases, the variables are substituted at application load time rather than dynamically updated while the application is running. For example, the allowed_outbound_hosts can be dynamically configured using variables as follows:[component.(name)]\nallowed_outbound_hosts = [ \"\\{{ api_uri }}\" ]All in all, an application manifest with api_token and api_uri variables and a component that uses them would look similar to the following:spin_manifest_version = 2\n\n[application]\nname = \"api-consumer\"\nversion = \"0.1.0\"\ndescription = \"A Spin app that makes API requests\"\n\n[variables]\napi_token = { required = true }\napi_uri = { default = \"http://my-api.com\" }\n\n[[trigger.http]]\nroute = \"/...\"\ncomponent = \"api-consumer\"\n\n[component.api-consumer]\nsource = \"app.wasm\"\n[component.api-consumer.variables]\ntoken = \"\\{{ api_token }}\"\napi_uri = \"\\{{ api_uri }}\napi_version = \"v1\"","keywords":"","subsectionKeywords":"","url":"/v3/variables#adding-variables-to-your-applications"},{"project":"v3","title":"Application Variables","subheading":"Using Variables From Applications","content":"The Spin SDK surfaces the Spin configuration interface to your language. The undefined consists of one operation:| Operation  | Parameters         | Returns             | Behavior |\n|------------|--------------------|---------------------|----------|\n| get      | Variable name      | Variable value      | Gets the value of the variable from the configured provider |To illustrate the variables API, each of the following examples makes a request to some API with a bearer token. The API URI, version, and token are all passed as application variables. The application manifest associated with the examples would look similar to the one described undefined.The exact details of calling the config SDK from a Spin application depends on the language:{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}undefinedThe interface is available in the spin_sdk::variables module and is named get.use spin_sdk::{\n    http::{IntoResponse, Method, Request, Response},\n    http_component, variables,\n};\n\n#[http_component]\nasync fn handle_api_call_with_token(_req: Request) -> anyhow::Result<impl IntoResponse> {\n    let token = variables::get(\"token\")?;\n    let api_uri = variables::get(\"api_uri\")?;\n    let version = variables::get(\"version\")?;\n    let versioned_api_uri = format!(\"{}/{}\", api_uri, version);\n    let request = Request::builder()\n        .method(Method::Get)\n        .uri(versioned_api_uri)\n        .header(\"Authorization\", format!(\"Bearer {}\", token))\n        .build();\n    let response: Response = spin_sdk::http::send(request).await?;\n    // Do something with the response ...\n    Ok(Response::builder()\n        .status(200)\n        .build())\n}{{ blockEnd }}{{ startTab \"TypeScript\"}}undefinedimport { AutoRouter } from 'itty-router';\nimport { Variables } from '@fermyon/spin-sdk';\n\nlet router = AutoRouter();\n\nrouter\n    .get(\"/\", () => {\n        let token = Variables.get(\"token\")\n        let apiUri = Variables.get(\"api_uri\")\n        let version = Variables.get(\"version\")\n        let versionedAPIUri = `${apiUri}/${version}`\n        let response = await fetch(\n          versionedAPIUri,\n          {\n            headers: {\n              'Authorization': 'Bearer ' + token\n            }\n          }\n        );\n\n        return new Response(\"Used an API\");\n    })\n\n//@ts-ignore\naddEventListener('fetch', async (event: FetchEvent) => {\n    event.respondWith(router.fetch(event.request));\n});\n{{ blockEnd }}{{ startTab \"Python\"}}undefinedThe variables module has a function called get(https://fermyon.github.io/spin-python-sdk/variables.html#spin_sdk.variables.get).from spin_sdk.http import IncomingHandler, Request, Response, send\nfrom spin_sdk import variables\n\nclass IncomingHandler(IncomingHandler):\n    def handle_request(self, request: Request) -> Response:\n        token = variables.get(\"token\")\n        api_uri = variables.get(\"api_uri\")\n        version = variables.get(\"version\")\n        versioned_api_uri = f\"{api_uri}/{version}\"\n        headers = {\n            \"Authorization\": f\"Bearer {token}\"\n        }\n        response = send(Request(\"GET\", versioned_api_uri, headers, None))\n        # Do something with the response ...\n        return Response(\n            200,\n            {\"content-type\": \"text/plain\"},\n            bytes(\"Used an API\", \"utf-8\")\n        ){{ blockEnd }}{{ startTab \"TinyGo\"}}undefinedThe function is available in the github.com/fermyon/spin/sdk/go/v2/variables package and is named Get. See undefined for reference documentation.import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\n\tspinhttp \"github.com/fermyon/spin/sdk/go/v2/http\"\n\t\"github.com/fermyon/spin/sdk/go/v2/variables\"\n)\n\nfunc init() {\n\tspinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n\t\ttoken, err := variables.Get(\"token\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tapiUri, err := variables.Get(\"api_uri\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tversion, err := variables.Get(\"version\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tversionedApiUri := fmt.Sprintf(\"%s/%s\", apiUri, version)\n\n\t\trequest, err := http.NewRequest(\"GET\", versionedApiUri, bytes.NewBuffer([]byte(\"\")))\n\t\trequest.Header.Add(\"Authorization\", \"Bearer \"+token)\n\t\tresponse, err := spinhttp.Send(request)\n\t\t// Do something with the response ...\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tfmt.Fprintln(w, \"Used an API\")\n\t})\n}\n\nfunc main() {}{{ blockEnd }}{{ blockEnd }}To build and run the application, we issue the following commands:# Build the application\n$ spin build\n# Run the application, setting the values of the API token and URI via the environment variable provider\n# using the `SPIN_VARIABLE` prefix (upper case is necessary as shown here)\n$ SPIN_VARIABLE_API_TOKEN=\"your-token-here\" SPIN_VARIABLE_API_URI=\"http://my-best-api.com\" spin upAssuming you have configured you application to use an API, to test the application, simply query\nthe app endpoint:$ curl -i localhost:3000\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 11\ndate: Wed, 31 Jul 2024 22:03:35 GMT\n\nUsed an API","keywords":"","subsectionKeywords":"","url":"/v3/variables#using-variables-from-applications"},{"project":"v3","title":"Application Variables","subheading":"Troubleshooting","content":"undefinedIf you run into the following error, you've most likely not set the variable, either through the environment variable provider using the SPIN_VARIABLE_ prefix or through another provider.Handler returned an error: Error::Provider(\"no provider resolved required variable \\\"YOUR_VARIABLE\\\"\")See undefined for information on setting variable values via environment variables, or configuring secure variable providers.undefinedIf you run into the following error, you've most likely not configured the component section in the spin.toml to have access to the variable specified.Handler returned an error: Error::Undefined(\"no variable for \\\"<component-id>\\\".\\\"your-variable\\\"\")To fix this, edit the spin.toml and add to the [component.<component-id>.variables] table a line such as <your-variable> = \"{{ app-variable }}\". See undefined for more information","keywords":"","subsectionKeywords":"","url":"/v3/variables#troubleshooting"},{"project":"v3","title":"Writing Spin Applications","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedA Spin application consists of a set of WebAssembly (Wasm) undefined, and a undefined that lists those components with some data about when and how to run them.  This page describes how to write components, manifests, and hence applications.","subsectionKeywords":"","url":"/v3/writing-apps"},{"project":"v3","title":"Writing Spin Applications","subheading":"Writing an Application Manifest","content":"undefinedA Spin undefined is a undefined file that contains:undefinedundefinedundefinedundefinedBy convention, the Spin manifest file is usually called spin.toml.This example is the manifest for a simple HTTP application with a single trigger executed when the /hello endpoint is accessed:spin_manifest_version = 2\n\n# General identification information\n[application]\nname = \"spin-hello-world\"\nversion = \"1.0.0\"\ndescription = \"A simple application that returns hello world.\"\n\n# The application's sole trigger. This application responds to HTTP requests\n# on the path \"/hello\", and handles them using the \"hello\" component.\n[[trigger.http]]\nroute = \"/hello\"\ncomponent = \"hello\"\n\n# The \"hello\" component\n[component.hello]\ndescription = \"A simple component that returns hello world.\"\n# The Wasm module to run for the component\nsource = \"target/wasm32-wasip1/release/helloworld.wasm\"\n# How to build the Wasm module from source\n[component.hello.build]\ncommand = \"cargo build --target wasm32-wasip1 --release\"You can look up the various fields in the undefined, but let's look at the key fields in more detail.","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#writing-an-application-manifest"},{"project":"v3","title":"Writing Spin Applications","subheading":"The  trigger  Fields","content":"An application contains one or more undefined.  Each trigger specifies a type, an event of that type that the application responds to, and a component to handle that event.The description above might sound a bit abstract. Let's clarify it with a concrete example. The most common trigger type is http, for which events are distinguished by the route. So an HTTP trigger might look like this:# double square brackets because there could be multiple 'trigger.http' tables\n[[trigger.http]]       # the type is part of the TOML \"section\"\nroute = \"/hello\"       # the route (event) that this trigger responds to\ncomponent = \"greeter\"  # the component to handle the triggerPut the type (http), event (route = \"/hello\"), and component (greeter) together, and this is saying \"when the application gets an HTTP request to /hello, respond to it using the greeter component.For more details about http triggers, see the undefined documentation.Another trigger type is redis, which is triggered by Redis pub-sub messages. For the redis type, the trigger event is specified by a pub-sub channel, e.g. channel = \"alerts\". See the undefined documentation for more information.Multiple triggers may refer to the same component. For example, you could have another trigger on /dober-dan which also invokes the greeter component.Some triggers have additional application-level configuration options.  For example, the Redis trigger allows you to provide an address field, which tells Spin the default server for components that do not specify servers.  See the undefined documentation for more details.","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#the-trigger-fields"},{"project":"v3","title":"Writing Spin Applications","subheading":"The Component Name","content":"Component names are identifier strings.  While not significant in themselves, they must be unique within the application.  Triggers use names to refer to components, and Spin uses the name in logging and error messages to tell you which component a message applies to.Each component is a TOML table, and the name is written as part of the table header. For example:[component.greeter]","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#the-component-name"},{"project":"v3","title":"Writing Spin Applications","subheading":"The Component  source","content":"Each component has a source field which tells Spin where to load the Wasm module from.For components that you are working on locally, set it to the file path to the compiled Wasm module file.  This must be a relative path from the directory containing spin.toml.[component.shopping-cart]\nsource = \"dist/cart.wasm\"For components that are published on the Web, provide a url field containing the URL of the Wasm module, and a digest field indicating the expected SHA256 hash of the module contents.  The digest must be prefixed with the string sha256:.  Spin uses the digest to check that the module is what you were expecting, and won't load the module if the content doesn't match.[component.asset-server]\nsource = { url = \"https://github.com/spinframework/spin-fileserver/releases/download/v0.0.1/spin_static_fs.wasm\", digest = \"sha256:650376c33a0756b1a52cad7ca670f1126391b79050df0321407da9c741d32375\" }Multiple components can have the same source.  An example is a document archive, where one component might serve user interface assets (CSS, images, etc.) on one route, while another serves the documents themselves on another route - both using the same file server module, but with different settings.","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#the-component-source"},{"project":"v3","title":"Writing Spin Applications","subheading":"Writing a Component Wasm Module","content":"undefinedAt the Wasm level, a Spin component is a Wasm component or module that exports a handler for the application trigger.  At the developer level, a Spin component is a library or program that implements your event handling logic, and uses Spin interfaces, libraries, or tools to associate that with the events handled by Spin.See the Language Guides section for how to do this in your preferred language. As an example, this is a component written in the Rust language. The hello_world function uses an attribute #[http_component] to identify the function as handling a Spin HTTP event. The function takes a Request and returns a anyhow::Result<impl IntoResponse>.use spin_sdk::http::{IntoResponse, Request, Response};\nuse spin_sdk::http_component;\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn hello_world(req: Request) -> anyhow::Result<impl IntoResponse> {\n    println!(\"Handling request to {:?}\", req.header(\"spin-full-url\"));\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(\"Hello, Fermyon\")\n        .build())\n}​​","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#writing-a-component-wasm-module"},{"project":"v3","title":"Writing Spin Applications","subheading":"Creating an Application From a Template","content":"If you've installed the Spin templates for your preferred language, you can use them to get started without having to write a manifest or the boilerplate code yourself.  To do this, run the spin new command, and choose the template that matches the type of application you want to create, and the language you want to use.{{ tabs \"sdk-type\" }}{{ startTab \"Rust\"}}Choose the http-rust template to create a new HTTP application, or redis-rust to create a new Redis application.$ spin new\nPick a template to start your application with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-csharp (HTTP request handler using C# (EXPERIMENTAL))\n  http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n> http-rust (HTTP request handler using Rust)\n  http-swift (HTTP request handler using SwiftWasm)\n  http-zig (HTTP request handler using Zig)\n  redis-go (Redis message handler using (Tiny)Go)\n  redis-rust (Redis message handler using Rust)\n\nEnter a name for your new application: hello_rust\nProject description: My first Rust Spin application\nHTTP path: /...{{ blockEnd }}{{ startTab \"TypeScript\"}}Choose the http-ts or http-js template to create a new HTTP application, according to whether you want to use TypeScript or JavaScript.undefined$ spin new\nPick a template to start your application with:\n  http-js (HTTP request handler using Javascript)\n> http-ts (HTTP request handler using Typescript)\nEnter a name for your new application: hello_typescript\nProject description: My first TypeScript Spin application\nHTTP path: /...{{ blockEnd }}{{ startTab \"Python\"}}Choose the http-py template to create a new HTTP application.undefined$ spin new\nPick a template to start your application with:\n> http-py (HTTP request handler using Python)\nEnter a name for your new application: hello_python\nDescription: My first Python Spin application\nHTTP path: /...{{ blockEnd }}{{ startTab \"TinyGo\"}}Choose the http-go template to create a HTTP application, or redis-go to create a Redis application.$ spin new\nPick a template to start your application with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-empty (HTTP application with no components)\n> http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n  http-php (HTTP request handler using PHP)\n  http-rust (HTTP request handler using Rust)\nEnter a name for your new application: hello_go\nDescription: My first Go Spin application\nHTTP path: /...{{ blockEnd }}{{ blockEnd }}All of these templates create a manifest containing a single component, and the source code for a minimal \"hello world\" component.","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#creating-an-application-from-a-template"},{"project":"v3","title":"Writing Spin Applications","subheading":"Adding a New Component to an Application","content":"To add a new component to an existing application using a template, run the spin add command. This works in a very similar way to spin new, except that it expects the spin.toml file to already exist, and adds the details for the new component to that spin.toml.undefined","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#adding-a-new-component-to-an-application"},{"project":"v3","title":"Writing Spin Applications","subheading":"Including Files with Components","content":"You can include files with a component.  This means that:undefinedundefinedTo do this, use the files field in the component manifest:[component.asset-server]\nfiles = [ \"images/**/*.jpg\", { source = \"styles/dist\", destination = \"/styles\" } ]The files field is an array listing the files, patterns and directories you want to include. Each element of the array can be:undefinedundefinedIf your files list would match some files or directories that you undefined want included, you can use the exclude_files field to omit them.undefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#including-files-with-components"},{"project":"v3","title":"Writing Spin Applications","subheading":"Adding Environment Variables to Components","content":"Environment variables can be provided to components via the Spin application manifest.To do this, use the environment field in the component manifest:[component.pet-info]\nenvironment = { PET = \"CAT\", FOOD = \"WATERMELON\" }The field accepts a map of environment variable key/value pairs. They are mapped inside the component at runtime.The environment variables can then be accessed inside the component. For example, in Rust:use spin_sdk::http::{IntoResponse, Request, Response};\nuse spin_sdk::http_component;\n\n#[http_component]\nfn handle_hello_rust(req: Request) -> anyhow::Result<impl IntoResponse> {\n    let response = format!(\"My {} likes to eat {}\", std::env::var(\"PET\")?, std::env::var(\"FOOD\")?);\n    Ok(Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/plain\")\n        .body(response)\n        .build())\n}","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#adding-environment-variables-to-components"},{"project":"v3","title":"Writing Spin Applications","subheading":"Granting Networking Permissions to Components","content":"By default, Spin components are not allowed to make outgoing network requests.  This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing.To grant a component permission to make outbound requests to a particular address, use the allowed_outbound_hosts field in the component manifest. Each entry must comprise a host name or IP address undefined a port. For example:[component.talkative]\nallowed_outbound_hosts = [\"redis://redis.example.com:6379\", \"https://api.example.com:8080\"]If a port is specified, the component can make requests only to that port.  If no port is specified, the component can make requests only to the default port for the scheme (e.g. port 443 for the https scheme, port 5432 for the postgres scheme).  If you need to allow requests to undefined port, use the wildcard * (e.g. mysql://db.example.com:*).undefinedThe Wasm module can send network traffic undefined to the hosts specified in these two fields. Requests to other hosts (or other ports) will fail with an error.{{ details \"This feels like extra work! Why do I have to list the hosts?\" \"This comes from the Wasm principle of deny by default: the user of a component, rather than the component itself, should decide what resource it's allowed to access. But this isn't just an abstract principle: it's critical to being able to trust third party components. For example, suppose you add bad-boy-brians-totally-legitimate-file-server.wasm to your application. Unless you unwisely grant it network permissions, you can be undefined that it doesn't access your Postgres database or send information to evildoers.\" }}For development-time convenience, you can also pass the string \"*://*:*\" in the allowed_outbound_hosts collection.  This allows the component to make network requests to undefined host and on any port.  However, once you've determined which hosts your code needs, you should remove this string, and list the hosts instead.  Other Spin implementations may restrict host access, and may disallow components that ask to connect to anything and everything!","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#granting-networking-permissions-to-components"},{"project":"v3","title":"Writing Spin Applications","subheading":"Granting Storage Permissions to Components","content":"By default, Spin components are not allowed to access Spin's storage services.  This follows the general Wasm rule that modules must be explicitly granted capabilities, which is important to sandboxing.  To grant a component permission to use a Spin-provided store, use the key_value_stores field in the component manifest:[component.squirrel]\nkey_value_stores = [ \"default\" ]See undefined for more information.","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#granting-storage-permissions-to-components"},{"project":"v3","title":"Writing Spin Applications","subheading":"Example Manifests","content":"This section shows some examples of Spin component manifests.","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#example-manifests"},{"project":"v3","title":"Writing Spin Applications","subheading":"Including a Directory of Files","content":"This example shows a Spin HTTP component that includes all the files in static/ under the application directory, made available to the Wasm module at the / path.[[trigger.http]]\nroute = \"/static/...\"\ncomponent = \"fileserver\"\n\n[component.fileserver]\nsource = \"modules/spin_static_fs.wasm\"\nfiles = [ { source = \"static/\", destination = \"/\" } ]","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#including-a-directory-of-files"},{"project":"v3","title":"Writing Spin Applications","subheading":"Using Public Components","content":"This is similar to the file server component above, but gets the Wasm module from a public release instead of a local copy.  Notice that the files are still drawn from a local path.  This is a way in which you can use off-the-shelf component logic with your own application data.[[trigger.http]]\nroute = \"/static/...\"\ncomponent = \"fileserver\"\n\n[component.fileserver]\nsource = { url = \"https://github.com/spinframework/spin-fileserver/releases/download/v0.0.1/spin_static_fs.wasm\", digest = \"sha256:650376c33a0756b1a52cad7ca670f1126391b79050df0321407da9c741d32375\" }\nfiles = [ { source = \"static/\", destination = \"/\" } ]","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#using-public-components"},{"project":"v3","title":"Writing Spin Applications","subheading":"Customizing the Executor","content":"This example shows an HTTP component whose Wasm module, instead of using the default Spin HTTP interface, uses the CGI-like WAGI (WebAssembly Gateway Interface) protocol. Spin can't work out the application model from the component, so the manifest needs to tell Spin to use WAGI instead of its default mode. It does this via the executor field. This is specific to the HTTP trigger so it goes under trigger.http.In addition, this module does not provide its WAGI functionality via the default _start entry point, but via a custom entry point named serve-wagi.  The executor table needs to tell Spin this via the entrypoint field.  Finally, this component needs to run the WAGI entry point with a specific set of command line arguments, which are expressed in the WAGI executor's argv field.[[trigger.http]]\nroute = \"/...\"\ncomponent = \"env\"\nexecutor = { type = \"wagi\", argv = \"test ${SCRIPT_NAME} ${ARGS} done\", entrypoint = \"serve-wagi\" }\n\n[component.env]\nsource = \"modules/env_wagi.wasm\"\nfiles = [ \"content/**/*\" , \"templates/*\", \"scripts/*\", \"config/*\"]","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#customizing-the-executor"},{"project":"v3","title":"Writing Spin Applications","subheading":"Setting the Redis Channel to Monitor","content":"The example shows a Redis component.  The manifest sets the channel field to say which channel the component should monitor.  In this case, the component is invoked for new messages on the messages channel.[[trigger.redis]]\nchannel = \"messages\"\ncomponent = \"echo-message\"\n\n[component.echo-message]\nsource = \"spinredis.wasm\"","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#setting-the-redis-channel-to-monitor"},{"project":"v3","title":"Writing Spin Applications","subheading":"Using Component Dependencies","content":"Few of us write applications without relying on libraries. Traditionally, those libraries have had to come from the language ecosystem - e.g. npm for JavaScript, pip for Python, etc. - and you can still work this way in Spin. However, the WebAssembly Component Model means that you can also depend on other WebAssembly components. The process of combining your application component with the Wasm components it depends on is called undefined, and Spin supports this natively.undefinedTo use composition through Spin, your component must import a undefined, and the dependency must export the same WIT interface. The details of working with WIT interfaces is language-specific, and is beyond the scope of the Spin documentation. You can learn more from the undefined. This section focuses on describing the dependency composition support in Spin.","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#using-component-dependencies"},{"project":"v3","title":"Writing Spin Applications","subheading":"Declaring Component Dependencies","content":"To declare a component dependency, create a [component.(name).dependencies] table in your Spin manifest, and list all the WIT interfaces you import (other than the ones that Spin itself satisfies), together with the packages that you would like to use to satisfy those imports.For example, suppose your component imports a WIT interface named security:http/malice for detecting malicious HTTP requests. This interface might be defined by a vendor or standards body, and might have multiple implementations. Suppose Bargain Security, Inc. provides an HTTP inspection package which includes an implementation of this interface, and that they publish this in the registry.example.com registry as bargains:inspection@2.0.0. You can then set up your dependency as follows:[component.my-app.dependencies]\n\"security:http/malice\" = { package = \"bargains:inspection\", version = \"2.0.0\", registry = \"packages.example.com\" }During loading, Spin will download the package from the registry, locate its security:http/malice export, and wire up your imports to that export so that when your component calls a function in the WIT interface, that call is dispatched to the Bargain Security package.undefined","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#declaring-component-dependencies"},{"project":"v3","title":"Writing Spin Applications","subheading":"Specifying Dependencies","content":"Spin supports three sources for dependencies.","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#specifying-dependencies"},{"project":"v3","title":"Writing Spin Applications","subheading":"Dependencies from a Registry","content":"To use a dependency from a registry, specify the following fields:| Field      | Required?   | Description                                                                                  | Example |\n|------------|-------------|----------------------------------------------------------------------------------------------|---------|\n| version  | Required    | A undefined for the package version to use.      | \">= 1.1.0\" |\n| package  | Optional    | The name of the package to use. If omitted, this defaults to the package name of the imported interface. | \"bargains:inspection\" |\n| registry | Optional    | The registry that hosts the package. If omitted, this defaults to your system default registry. | \"registry.example.com\" |\n| export   | Optional    | The name of the export in the package. If omitted, this defaults to the name of the import.  | \"more-secure:checking-it-out/web\" |If you don't need any of the optional fields, you can provide the version constraint as a plain string instead of writing out the table:# Use the `security:http` package in the default registry\n\"security:http/malice\" = \"2.0.0\"","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#dependencies-from-a-registry"},{"project":"v3","title":"Writing Spin Applications","subheading":"Dependencies from a Local Component","content":"To use a dependency from a component on your file system, specify the following fields:| Field      | Required?   | Description                                                                                  | Example |\n|------------|-------------|----------------------------------------------------------------------------------------------|---------|\n| path     | Required    | The path to the Wasm file containing the component.                                          | \"../validation/request-checker.wasm\" |\n| export   | Optional    | The name of the export in the package. If omitted, this defaults to the name of the import.  | \"more-secure:checking-it-out/web\" |","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#dependencies-from-a-local-component"},{"project":"v3","title":"Writing Spin Applications","subheading":"Dependencies from a URL","content":"To use a dependency from an HTTP URL, such as a GitHub release, specify the following fields:| Field      | Required?   | Description                                                                                  | Example |\n|------------|-------------|----------------------------------------------------------------------------------------------|---------|\n| url      | Required    | The URL of the Wasm file containing the component.                                           | \"https://example.com/downloads/request-checker.wasm\" |\n| digest   | Required    | The SHA256 digest of the Wasm file. This is required for integrity checking.                 | \"sha256:650376c33a0756b1a52cad7ca670f1126391b79050df0321407da9c741d32375\" |\n| export   | Optional    | The name of the export in the package. If omitted, this defaults to the name of the import.  | \"more-secure:checking-it-out/web\" |","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#dependencies-from-a-url"},{"project":"v3","title":"Writing Spin Applications","subheading":"Mapping All Imports from a Package","content":"If you are importing several interfaces from the same WIT package, and want them all satisfied by the same Wasm package, you can omit the interface from the dependency name. For example, suppose you import the malice, tomfoolery, and shenanigans WIT interfaces from the security:http package, and that your Bargain Security package exports all three of them.  You can write:[component.my-app.dependencies]\n\"security:http\" = { package = \"bargains:inspection\", version = \"2.0.0\", registry = \"packages.example.com\" }and Spin will map all of your security:http imports to the matching exports from the package.","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#mapping-all-imports-from-a-package"},{"project":"v3","title":"Writing Spin Applications","subheading":"Dependency Permissions","content":"By default, dependencies do not have access to Spin resources that require permission to be given in the manifest - network hosts, key-value stores, SQLite databases, variables, etc.If a component has a dependency which requires resource access, you can grant it by setting the dependencies_inherit_configuration flag in the Spin component manifest:[component.my-app]\ndependencies_inherit_configuration = trueThis grants undefined dependencies access to undefined resources listed in the Spin component manifest. You should therefore set this only if you trust undefined dependencies.undefined","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#dependency-permissions"},{"project":"v3","title":"Writing Spin Applications","subheading":"Next Steps","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefined","keywords":"","subsectionKeywords":"","url":"/v3/writing-apps#next-steps"}]